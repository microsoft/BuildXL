// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Diagnostics.ContractsLight;
using System.IO;
using System.Threading;
using System.Threading.Tasks;
using BuildXL.Cache.ContentStore.Distributed.Redis.Credentials;
using BuildXL.Cache.ContentStore.Exceptions;
using BuildXL.Cache.ContentStore.FileSystem;
using BuildXL.Cache.ContentStore.Hashing;
using BuildXL.Cache.ContentStore.Interfaces.Distributed;
using BuildXL.Cache.ContentStore.Interfaces.FileSystem;
using BuildXL.Cache.ContentStore.Interfaces.Logging;
using BuildXL.Cache.ContentStore.Interfaces.Results;
using BuildXL.Cache.ContentStore.Interfaces.Sessions;
using BuildXL.Cache.ContentStore.Interfaces.Stores;
using BuildXL.Cache.ContentStore.Interfaces.Time;
using BuildXL.Cache.ContentStore.Interfaces.Tracing;
using BuildXL.Cache.ContentStore.Logging;
using BuildXL.Cache.ContentStore.Service;
using BuildXL.Cache.ContentStore.Sessions;
using BuildXL.Cache.ContentStore.Stores;
using BuildXL.Cache.ContentStore.Tracing;
using BuildXL.Cache.Host.Configuration;
using BuildXL.Cache.Host.Service;
using CLAP;

// ReSharper disable UnusedMember.Global
namespace BuildXL.Cache.ContentStore.App
{
    /// <summary>
    ///     Core application implementation with CLAP verbs.
    /// </summary>
    internal sealed partial class Application : IDisposable
    {
        private const string HashTypeDescription = "Content hash type (SHA1/SHA256/MD5/Vso0/DedupChunk/DedupNode)";
        private readonly IAbsFileSystem _fileSystem;
        private readonly ConsoleLog _consoleLog;
        private readonly Logger _logger;
        private readonly Tracer _tracer;
        private bool _waitForDebugger;
        private FileLog _fileLog;
        private Severity _fileLogSeverity = Severity.Diagnostic;
        private bool _logAutoFlush;
        private string _logDirectoryPath;
        private long _logMaxFileSize;
        private int _logMaxFileCount;
        private bool _pause;
        private string _scenario;
        private uint _connectionsPerSession;
        private uint _retryIntervalSeconds;
        private uint _retryCount;

        /// <summary>
        ///     Initializes a new instance of the <see cref="Application"/> class.
        /// </summary>
        public Application()
        {
            _consoleLog = new ConsoleLog(Severity.Warning);
            _logger = new Logger(true, _consoleLog);
            _fileSystem = new PassThroughFileSystem(_logger);
            _tracer = new Tracer(nameof(Application));
        }

        /// <inheritdoc />
        [SuppressMessage("Microsoft.Usage", "CA2213:DisposableFieldsShouldBeDisposed", MessageId = "_fileLog")]
        public void Dispose()
        {
            _logger.Dispose();
            _fileLog?.Dispose();
            _consoleLog.Dispose();
            _fileSystem.Dispose();
        }

        /// <summary>
        ///     Show user help.
        /// </summary>
        /// <param name="help">Help string generated by CLAP.</param>
        /// <remarks>
        ///     This is intended to only be called by CLAP.
        /// </remarks>
        [Help(Aliases = "help,h,?")]
        public void ShowHelp(string help)
        {
            Contract.Requires(help != null);
            _logger.Always("ContentStore Tool");
            _logger.Always(help);
        }

        /// <summary>
        ///     Handle verb exception.
        /// </summary>
        /// <remarks>
        ///     This is intended to only be called by CLAP.
        /// </remarks>
        [Error]
        public void HandleError(ExceptionContext exceptionContext)
        {
            Contract.Requires(exceptionContext != null);
            _logger.Error(exceptionContext.Exception.InnerException != null
                ? $"{exceptionContext.Exception.Message}: {exceptionContext.Exception.InnerException.Message}"
                : exceptionContext.Exception.Message);
            exceptionContext.ReThrow = false;
        }

        /// <summary>
        ///     Set option to wait for debugger to attach.
        /// </summary>
        [Global("WaitForDebugger", Description = "Wait for debugger to attach")]
        public void SetWaitForDebugger(bool waitForDebugger)
        {
            _waitForDebugger = waitForDebugger;
        }

        /// <summary>
        ///     Set the console log line format to short or long form.
        /// </summary>
        [Global("LogLongForm", Description = "Use long logging form on console")]
        public void SetLogLongLayout(bool value)
        {
            foreach (var consoleLog in _logger.GetLog<ConsoleLog>())
            {
                consoleLog.UseShortLayout = !value;
            }
        }

        /// <summary>
        ///     Set the console log severity filter.
        /// </summary>
        [Global("LogSeverity", Description = "Set console severity filter")]
        public void SetLogSeverity(Severity logSeverity)
        {
            foreach (var consoleLog in _logger.GetLog<ConsoleLog>())
            {
                consoleLog.CurrentSeverity = logSeverity;
            }
        }

        /// <summary>
        ///     Set the file log severity filter.
        /// </summary>
        [Global("LogFileSeverity", Description = "Set file log severity filter")]
        public void SetLogFileSeverity(Severity severity)
        {
            _fileLogSeverity = severity;
        }

        /// <summary>
        ///     Enable automatic log file flushing.
        /// </summary>
        [Global("LogAutoFlush", Description = "Enable automatic log file flushing")]
        public void SetLogAutoFlush(bool logAutoFlush)
        {
            _logAutoFlush = logAutoFlush;
        }

        /// <summary>
        ///     Self explanatory.
        /// </summary>
        [Global("LogDirectoryPath", Description = "Set log directory path")]
        public void SetLogDirectoryPath(string path)
        {
            _logDirectoryPath = path;
        }

        /// <summary>
        ///     Set log rolling max file size.
        /// </summary>
        [Global("LogMaxFileSizeMB", Description = "Set log rolling max file size in MB")]
        public void SetLogMaxFileSizeMB(long value)
        {
            _logMaxFileSize = value * 1024 * 1024;
        }

        /// <summary>
        ///     Set log rolling max file count.
        /// </summary>
        [Global("LogMaxFileCount", Description = "Set log rolling max file count")]
        public void SetLogMaxFileCount(int value)
        {
            _logMaxFileCount = value;
        }
        
        /// <summary>
        ///     Set option to pause process before exiting.
        /// </summary>
        [Global("Pause", Description = "Pause before exit")]
        public void Pause(bool pause)
        {
            _pause = pause;
        }

        /// <summary>
        ///     Set alternate CASaaS scenario name.
        /// </summary>
        [Global("Scenario", Description = "Alternate CASaaS scenario name")]
        public void Scenario(string scenario)
        {
            _scenario = scenario;
        }

        /// <summary>
        ///     Set level of sensitivity to CASaaS system resource usage. Set to ensure purging occurs offline.
        /// </summary>
        [Global("Sensitivity", Description = "Level of sensitivity to system resource usage")]
        [Obsolete]
        public void Sensitivity(Sensitivity sensitivity)
        {
        }

        /// <summary>
        ///     Set number of pipe connections to use per session to service.
        /// </summary>
        [Global("ConnectionsPerSession", Description = "Number of pipe connections to use per session to service")]
        public void ConnectionsPerSession(uint value)
        {
            _connectionsPerSession = value;
        }

        /// <summary>
        ///     Set number of seconds between each client retry.
        /// </summary>
        [Global("RetryIntervalSeconds", Description = "Number of seconds between each client retry to service")]
        public void RetryIntervalSeconds(uint value)
        {
            _retryIntervalSeconds = value;
        }

        /// <summary>
        ///     Set maximum number of client retries to service before giving up.
        /// </summary>
        [Global("RetryCount", Description = "Maximum number of client retries to service before giving up")]
        public void RetryCount(uint value)
        {
            _retryCount = value;
        }

        private static void SetThreadPoolSizes()
        {
            ThreadPool.GetMaxThreads(out var workerThreads, out var completionPortThreads);
            workerThreads = Math.Max(workerThreads, Environment.ProcessorCount * 16);
            completionPortThreads = workerThreads;
            ThreadPool.SetMaxThreads(workerThreads, completionPortThreads);

            ThreadPool.GetMinThreads(out workerThreads, out completionPortThreads);
            workerThreads = Math.Max(workerThreads, Environment.ProcessorCount * 16);
            completionPortThreads = workerThreads;
            ThreadPool.SetMinThreads(workerThreads, completionPortThreads);
        }

        private static HashType GetHashTypeByNameOrDefault(string name)
        {
            return name?.FindHashTypeByName() ?? HashType.Vso0;
        }

        private void PauseUntilKeyboardHit()
        {
            if (!_pause)
            {
                return;
            }

            Console.WriteLine("Press a key to continue");
            Console.ReadKey(true);
        }

        private void Initialize()
        {
            if (_waitForDebugger)
            {
                _logger.Warning("Waiting for debugger to attach. Hit any key to bypass.");

                while (!Debugger.IsAttached)
                {
                    Thread.Sleep(TimeSpan.FromSeconds(1));
                }

                Debugger.Break();
            }

            SetThreadPoolSizes();

            if (_fileLog == null)
            {
                _fileLog = new FileLog(_logDirectoryPath, null, _fileLogSeverity, _logAutoFlush, _logMaxFileSize, _logMaxFileCount);
                _logger.AddLog(_fileLog);
            }
        }

        private void RunFileSystemContentStoreInternal(AbsolutePath rootPath, System.Func<Context, FileSystemContentStoreInternal, Task> funcAsync)
        {
            Initialize();

            try
            {
                var context = new Context(_logger);

                using (var store = CreateInternal(rootPath))
                {
                    try
                    {
                        var result = store.StartupAsync(context).Result;
                        if (!result)
                        {
                            Trace(result, context, "Failed to start store");
                            return;
                        }

                        funcAsync(context, store).Wait();
                    }
                    finally
                    {
                        var result = store.ShutdownAsync(context).Result;
                        if (!result)
                        {
                            context.Error($"Failed to shutdown store, error=[{result.ErrorMessage}]");
                        }
                    }
                }
            }
            catch (AggregateException exception)
            {
                _logger.Error(exception.InnerException?.Message);
            }
        }

        private FileSystemContentStoreInternal CreateInternal(AbsolutePath rootPath)
        {
            return new FileSystemContentStoreInternal(
                _fileSystem, SystemClock.Instance, rootPath, new ConfigurationModel(ContentStoreConfiguration.CreateWithMaxSizeQuotaMB(Constants.OneMB)));
        }

        private void RunContentStore(string cacheName, string cachePath, ServiceClientRpcConfiguration rpcConfiguration, Func<Context, IContentSession, Task> funcAsync)
        {
            VerifyCachePathOrNameProvided(cacheName, cachePath);

            if (cacheName != null)
            {
                RunServiceClientContentStore(cacheName, rpcConfiguration, funcAsync);
            }
            else
            {
                RunFileSystemContentStore(new AbsolutePath(cachePath), funcAsync);
            }

            PauseUntilKeyboardHit();
        }

        private void RunFileSystemContentStore(AbsolutePath rootPath, System.Func<Context, IContentSession, Task> funcAsync)
        {
            System.Func<IContentStore> createFunc = () => new FileSystemContentStore(
                _fileSystem, SystemClock.Instance, rootPath, new ConfigurationModel(ContentStoreConfiguration.CreateWithMaxSizeQuotaMB(Constants.OneMB)));
            RunContentStore(createFunc, funcAsync);
        }

        private void RunServiceClientContentStore(string cacheName, ServiceClientRpcConfiguration rpcConfiguration, Func<Context, IContentSession, Task> funcAsync)
        {
            System.Func<IContentStore> createFunc = () => new ServiceClientContentStore(
                _logger, _fileSystem, new ServiceClientContentStoreConfiguration(cacheName, rpcConfiguration, _scenario)
                                      {
                                          RetryCount = _retryCount,
                                          RetryIntervalSeconds = _retryIntervalSeconds,
                                      });
            RunContentStore(createFunc, funcAsync);
        }

        private void RunContentStore(
            Func<IContentStore> createStoreFunc,
            Func<Context, IContentSession, Task> funcAsync)
        {
            Initialize();
            var context = new Context(_logger);

            try
            {
                using (var store = createStoreFunc())
                {
                    try
                    {
                        var startupResult = store.StartupAsync(new Context(_logger)).Result;
                        if (!startupResult.Succeeded)
                        {
                            Trace(startupResult, context, "Failed to start store");
                            return;
                        }

                        var createSessionResult = store.CreateSession(new Context(_logger), "tool", ImplicitPin.None);
                        if (!createSessionResult.Succeeded)
                        {
                            Trace(createSessionResult, context, "Failed to create session");
                            return;
                        }

                        using (var session = createSessionResult.Session)
                        {
                            try
                            {
                                var sessionBoolResult = session.StartupAsync(new Context(_logger)).Result;
                                if (!sessionBoolResult.Succeeded)
                                {
                                    Trace(sessionBoolResult, context, "Failed to start session");
                                    return;
                                }

                                funcAsync(new Context(_logger), session).Wait();
                            }
                            finally
                            {
                                var sessionBoolResult = session.ShutdownAsync(new Context(_logger)).Result;
                                if (!sessionBoolResult.Succeeded)
                                {
                                    _tracer.Error(context, $"Failed to shutdown session, error=[{sessionBoolResult.ErrorMessage}]");
                                }
                            }
                        }
                    }
                    finally
                    {
                        var r = store.ShutdownAsync(new Context(_logger)).Result;
                        if (!r.Succeeded)
                        {
                            _tracer.Error(context, $"Failed to shutdown store, error=[{r.ErrorMessage}]");
                        }
                    }
                }
            }
            catch (Exception exception)
            {
                _tracer.Error(context, exception, "Unhandled exception in RunContentStore.");
            }
        }

        private void Trace(ResultBase result, Context context, string message)
        {
            _tracer.Error(context, $"{message}, result=[{result}]");
            _tracer.Debug(context, $"{result.Diagnostics}");
        }

        private void VerifyCachePathOrNameProvided(string name, string path)
        {
            if ((string.IsNullOrEmpty(path) && string.IsNullOrEmpty(name)) ||
                (!string.IsNullOrEmpty(path) && !string.IsNullOrEmpty(name)))
            {
                throw new CacheException($"Cache {nameof(path)} or {nameof(name)} must be provided, but not both");
            }
        }

        internal DistributedCacheServiceArguments CreateDistributedCacheServiceArguments(
            IAbsolutePathFileCopier copier, IAbsolutePathTransformer pathTransformer, DistributedContentSettings dcs, HostInfo host, string cacheName, string cacheRootPath, uint grpcPort, int maxSizeQuotaMB, string dataRootPath, CancellationToken ct, int? bufferSizeForGrpcCopies = null)
        {
            var distributedCacheServiceHost = new EnvironmentVariableHost();

            var localCasSettings = LocalCasSettings.Default(
                maxSizeQuotaMB: maxSizeQuotaMB,
                cacheRootPath: cacheRootPath,
                cacheName: cacheName,
                grpcPort: grpcPort,
                grpcPortFileName: _scenario);
            localCasSettings.PreferredCacheDrive = Path.GetPathRoot(cacheRootPath);
            localCasSettings.ServiceSettings = new LocalCasServiceSettings(60, scenarioName: _scenario, grpcPort: grpcPort, grpcPortFileName: _scenario, bufferSizeForGrpcCopies: bufferSizeForGrpcCopies);

            var config = new DistributedCacheServiceConfiguration(localCasSettings, dcs);

            return new DistributedCacheServiceArguments(_logger, copier, pathTransformer, distributedCacheServiceHost, host, ct, dataRootPath, config, null);
        }
    }
}
