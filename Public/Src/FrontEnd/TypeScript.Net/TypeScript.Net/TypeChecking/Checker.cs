// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Diagnostics.ContractsLight;
using System.Linq;
using System.Text;
using System.Threading;
using BuildXL.Utilities;
using BuildXL.Utilities.Collections;
using BuildXL.FrontEnd.Script.Constants;
using JetBrains.Annotations;
using TypeScript.Net.Binding;
using TypeScript.Net.Core;
using TypeScript.Net.Diagnostics;
using TypeScript.Net.Extensions;
using TypeScript.Net.Parsing;
using TypeScript.Net.Types;
using static BuildXL.Utilities.Collections.CollectionUtilities;
using static BuildXL.Utilities.FormattableStringEx;
using static TypeScript.Net.Core.CoreUtilities;
using static TypeScript.Net.Diagnostics.DiagnosticUtilities;
using static TypeScript.Net.Extensions.CollectionExtensions;
using static TypeScript.Net.Extensions.NodeArrayExtensions;
using static TypeScript.Net.Scanning.Scanner;
using static TypeScript.Net.Types.NodeUtilities;
using static TypeScript.Net.Types.SymbolTable;
using static TypeScript.Net.Utils;
using CancellationToken = TypeScript.Net.Types.CancellationToken;
using ISymbol = TypeScript.Net.Types.ISymbol;
using SymbolTable = TypeScript.Net.Types.SymbolTable;

namespace TypeScript.Net.TypeChecking
{
    internal enum TypeSystemPropertyName
    {
        Type,
        ResolvedBaseConstructorType,
        DeclaredType,
        ResolvedReturnType,
    }

    /// <nodoc/>
    [SuppressMessage("Microsoft.Design", "CA1001:TypesThatOwnDisposableFieldsShouldBeDisposable", Justification = "Marking this as disposable leads us down the rabbit hole. Adding to technical debt: ")]
    public sealed partial class Checker : ITypeChecker, IDisposable
    {
        private readonly ThreadSafeCounters m_counters;

        /// <inheritdoc />
        public int GetNextTypeId() => m_counters.GetNextTypeId();

        /// <nodoc/>
        public int GetNodeId(INode node) => m_counters.GetNodeId(node);

        /// <nodoc/>
        public int GetSymbolId(ISymbol symbol) => m_counters.GetSymbolId(symbol);

        private int GetMergeId(ISymbol symbol) => m_counters.GetMergeId(symbol);

        private readonly List<ISymbol> m_mergedSymbols = new List<ISymbol>
        {
            // Dummy symbol to keep the list 1-index based. This symbol is never accessed.
            null,
        };

        private void RecordMergedSymbol(ISymbol target, ISymbol source)
        {
            int mergeId = GetMergeId(source);
            m_mergedSymbols.AddOrUpdateAtomic(target, mergeId);
        }

        #region Private Fields
        private readonly int m_degreeOfParallelism;
        private readonly bool m_trackFileToFileDependencies;

        /// <summary>
        /// If true, then the checker will keep all the computed information (like ResolvedSymbol) in external table.
        /// If false, then the checker will update a node fields in more efficient way but not suited for IDE.
        /// </summary>
        private bool m_interactiveMode;

        private readonly TypeCheckerHost m_host;
        private readonly bool m_produceDiagnostics;

        /// <summary>
        /// Cancellation that controls whether or not we can cancel in the middle of type checking.
        /// In general cancelling is *not* safe for the type checker.  We might be in the middle of
        /// computing something, and we will leave our internals in an inconsistent state.  Callers
        /// who set the cancellation token should catch if a cancellation exception occurs, and
        /// should throw away and create a new TypeChecker.
        ///
        /// Currently we only support setting the cancellation token when getting diagnostics.  This
        /// is because diagnostics can be quite expensive, and we want to allow hosts to bail out if
        /// they no longer need the information (for example, if the user started editing again).
        /// </summary>
        private CancellationToken m_cancellationToken;

        private static readonly ITypeMapper s_identityMapper = new TypeMapper(t => IdentityMapperFn(t));

        private static readonly List<ISignature> s_emptySignatureList = new List<ISignature>();
        private static readonly IReadOnlyList<IType> s_emptyTypeList = new List<IType>();
        private static readonly IEnumerable<ISignature> s_emptySignatureEnumerable = s_emptySignatureList;

        /// <summary>
        /// Signatures for well-known template expressions like p``, d``, f`` etc.
        /// </summary>
        private readonly ConcurrentDictionary<string, ISignature> m_taggedSignatures = new ConcurrentDictionary<string, ISignature>();

        private readonly ConcurrentDictionary<string, IType> m_taggedTypes = new ConcurrentDictionary<string, IType>();

        private static readonly ISymbolTable s_emptySymbols = new SymbolTable(isReadonly: true);

        private readonly ICompilerOptions m_compilerOptions;
        private readonly ScriptTarget m_languageVersion;
        private readonly ModuleKind m_modulekind;
        private readonly bool m_allowSyntheticDefaultImports;

        private readonly ISymbol m_undefinedSymbol;
        private readonly ISymbol m_argumentsSymbol;

        private readonly ISymbol m_unknownSymbol;
        private readonly ISymbol m_resolvingSymbol;

        private readonly IIntrinsicType m_anyType;
        private readonly IIntrinsicType m_stringType;
        private readonly IIntrinsicType m_numberType;
        private readonly IIntrinsicType m_booleanType;
        private readonly IIntrinsicType m_esSymbolType;
        private readonly IIntrinsicType m_voidType;
        private readonly IIntrinsicType m_undefinedType;
        private readonly IIntrinsicType m_nullType;
        private readonly IIntrinsicType m_unknownType;

        private readonly IResolvedType m_emptyObjectType;
        private readonly IResolvedType m_emptyUnionType;

        private readonly IGenericType m_emptyGenericType;

        private readonly IResolvedType m_anyFunctionType;

        private readonly IResolvedType m_noConstraintType;

        private readonly ISignature m_anySignature;
        private readonly ISignature m_unknownSignature;

        private readonly ISymbolTable m_globals = new SymbolTable();

        private /*readonly*/ ISourceFile[] m_sourceFiles;

        // Effectively, all the following fields are readonly (initalized in the InitializeTypeChecker method).
        private /*readonly*/ ISymbol m_globalEsSymbolConstructorSymbol;

        private /*readonly*/ IType m_globalObjectType;
        private /*readonly*/ IType m_globalFunctionType;
        private /*readonly*/ IGenericType m_globalArrayType;
        private /*readonly*/ IType m_globalStringType;
        private /*readonly*/ IType m_globalNumberType;
        private /*readonly*/ IType m_globalBooleanType;
        private /*readonly*/ IType m_globalRegExpType;
        private /*readonly*/ IType m_globalTemplateStringsArrayType;
        private /*readonly*/ IType m_globalEsSymbolType;
        private /*readonly*/ IGenericType m_globalIterableType;
        private /*readonly*/ IGenericType m_globalIteratorType;
        private /*readonly*/ IGenericType m_globalIterableIteratorType;

        private /*readonly */ IType m_anyArrayType;
        private /*readonly*/ Func<IObjectType> m_getGlobalTypedPropertyDescriptorType;
        private /*readonly*/ Func<IObjectType> m_getGlobalPromiseType;
        private /*readonly*/ Func<IObjectType> m_tryGetGlobalPromiseType;
        private /*readonly*/ Func<IObjectType> m_getGlobalPromiseLikeType;
        private /*readonly*/ Func<IObjectType> m_getInstantiatedGlobalPromiseLikeType;
        private /*readonly*/ Func<IObjectType> m_getGlobalPromiseConstructorLikeType;
        private /*readonly*/ Func<IObjectType> m_getGlobalThenableType;

        private readonly Map<ITupleType> m_tupleTypes = new Map<ITupleType>();
        private readonly Map<IUnionType> m_unionTypes = new Map<IUnionType>();
        private readonly Map<IIntersectionType> m_intersectionTypes = new Map<IIntersectionType>();
        private readonly Map<IStringLiteralType> m_stringLiteralTypes = new Map<IStringLiteralType>();

        #region Per file checker's state

        /// <summary>
        /// Extra checker's state used for file analysis.
        /// </summary>
        /// <remark>
        /// This type is crucial for making the checker thread-safe.
        /// Checker requires some state and instead of using global state
        /// this data structure represents a state per file being analyzed.
        /// </remark>
        private class PerFileCheckState
        {
            private ConcurrentQueue<INode> m_deferredNodes;
            private ConcurrentQueue<INode> m_potentialThisCollisions;

            public bool EmitExtends;

            public bool EmitDecorate;
            public bool EmitParam;
            public bool EmitAwaiter;

#pragma warning disable CA2227 // Collection properties should be read only
            public ConcurrentQueue<INode> DeferredNodes
#pragma warning restore CA2227 // Collection properties should be read only
            {
                get
                {
                    // Creating lazily to avoid redundant allocations.
                    if (m_deferredNodes == null)
                    {
                        lock (this)
                        {
                            if (m_deferredNodes == null)
                            {
                                m_deferredNodes = new ConcurrentQueue<INode>();
                            }
                        }
                    }

                    return m_deferredNodes;
                }

                set
                {
                    m_deferredNodes = value;
                }
            }

#pragma warning disable CA2227 // Collection properties should be read only
            public ConcurrentQueue<INode> PotentialThisCollisions
#pragma warning restore CA2227 // Collection properties should be read only
            {
                get
                {
                    // Creating lazily to avoid redundant allocations.
                    if (m_potentialThisCollisions == null)
                    {
                        lock (this)
                        {
                            if (m_potentialThisCollisions == null)
                            {
                                m_potentialThisCollisions = new ConcurrentQueue<INode>();
                            }
                        }
                    }

                    return m_potentialThisCollisions;
                }

                set
                {
                    m_potentialThisCollisions = value;
                }
            }
        }

        private readonly ConcurrentDictionary<ISourceFile, PerFileCheckState> m_perFileCheckerState = new ConcurrentDictionary<ISourceFile, PerFileCheckState>();

        private readonly ConcurrentDictionary<string, string> m_resolvedModulePathMap = new ConcurrentDictionary<string, string>();

        // Not threadsafe, but DScript doesn't support async/await, so this is fine for now.
        private readonly List<int> m_awaitedTypeStack = new List<int>();

        private static readonly ISourceFile s_nullSourceFile = new SourceFile();

        private PerFileCheckState GetPerFileState(INode node) => m_perFileCheckerState.GetOrAdd(node.GetSourceFile() ?? s_nullSourceFile, s => new PerFileCheckState());

        #endregion

        // Old per-checker state. Threadsafe, because immutable.
        private readonly bool m_emitGenerator = false;

        #region ThreadLocal state

        // The following fields are thread-local that helps to avoid synchronization.
        // They're only used to resolve recursion-like problems during type inference and/or overload resolution.

        // Thread local storage for contextual types for a node under analysis.
        private readonly ThreadLocal<Dictionary<IExpression, IType>> m_contextualTypes =
            new ThreadLocal<Dictionary<IExpression, IType>>(() => new Dictionary<IExpression, IType>());

        private readonly ThreadLocal<List</*TODO: TypeSystemEntity*/ object>> m_resolutionTargets =
            new ThreadLocal<List<object>>(() => new List<object>());

        private readonly ThreadLocal<List<bool>> m_resolutionResults = new ThreadLocal<List<bool>>(() => new List<bool>());

        private readonly ThreadLocal<List<TypeSystemPropertyName>> m_resolutionPropertyNames =
            new ThreadLocal<List<TypeSystemPropertyName>>(() => new List<TypeSystemPropertyName>());

        private readonly ThreadLocal<Dictionary<ISymbolLinks, AliasResolutionState>> m_targetResolutionSet
            = new ThreadLocal<Dictionary<ISymbolLinks, AliasResolutionState>>(() => new Dictionary<ISymbolLinks, AliasResolutionState>());

        private readonly ThreadLocal<HashSet<INode>> m_resolvedSignatureSet =
            new ThreadLocal<HashSet<INode>>(() => new HashSet<INode>());

        private readonly ThreadLocal<HashSet<ISymbol>> m_setReferenceSymbolResolutionCache =
            new ThreadLocal<HashSet<ISymbol>>(() => new HashSet<ISymbol>());
        #endregion

        // Using reasonably big default size to avoid reallocations for large builds.
        // TODO: compute default size based on a number of specs and/or nodes in all specs.
#pragma warning disable SA1203 // Constants must appear before fields
        private const int DefaultSize = 10000;
#pragma warning restore SA1203 // Constants must appear before fields
        private readonly ConcurrentVector<ISymbolLinks> m_symbolLinks = new ConcurrentVector<ISymbolLinks>(DefaultSize);
        private readonly ConcurrentVector<NodeLinks> m_nodeLinks = new ConcurrentVector<NodeLinks>(DefaultSize);

        private readonly IDiagnosticCollection m_diagnostics = CreateDiagnosticCollection();

        private bool m_isScriptFile = false;

        // DScript-specific. In the same way each source file contains a local symbol table and a symbol export,
        // a DScript implicit-reference module has its equivalent here. We keep a symbol table per module
        // representing module-internal symbols and an export symbol per module representing its exported surface.
        private readonly Map<ISymbolTable> m_moduleTableInternals = new Map<ISymbolTable>();
        private readonly ConcurrentDictionary<string, ISymbol> m_moduleExports = new ConcurrentDictionary<string, ISymbol>();

        // Per-module symbol representing all internal values of a module. Represents the '$' namespace. Constructed on demand
        // the first time a module mentions '$'.
        private readonly ConcurrentDictionary<string, ISymbol> m_moduleInternals = new ConcurrentDictionary<string, ISymbol>();

        // Table of  internal symbols per file. A file that is in a V2 module has access to all internal symbols of the module (minus
        // the export specifiers of that same file). This dictionary is constructed on demand to avoid recomputations.
        // This dictionary is not populated during regular type checking, but used when checking for symbol visibility in, for example,
        // the public surface printer
        private readonly ConcurrentDictionary<string, ISymbolTable> m_internalsPerFile = new ConcurrentDictionary<string, ISymbolTable>();

        private readonly struct TypeAndFlag
        {
            public readonly IType Type;
            public readonly TypeFlags Flags;

            public TypeAndFlag(IType type, TypeFlags flags)
            {
                Type = type;
                Flags = flags;
            }
        }

        private readonly Map<TypeAndFlag> m_primitiveTypeInfo;

        private readonly ConcurrentMap<RelationComparisonResult> m_subtypeRelation = new ConcurrentMap<RelationComparisonResult>();
        private readonly ConcurrentMap<RelationComparisonResult> m_assignableRelation = new ConcurrentMap<RelationComparisonResult>();

        // Ported from commit 9e5f2604
        private readonly ConcurrentMap<RelationComparisonResult> m_comparableRelation = new ConcurrentMap<RelationComparisonResult>();
        private readonly ConcurrentMap<RelationComparisonResult> m_identityRelation = new ConcurrentMap<RelationComparisonResult>();

        // This is for caching the result of GetSymbolDisplayBuilder. Do not accessed directly.
        private ISymbolDisplayBuilder m_displayBuilder;

        private readonly ISymbolTable m_builtinGlobals;

        #endregion

        private Checker(TypeCheckerHost host, bool produceDiagnostics, int degreeOfParallelism, bool trackFileToFileDependencies, bool interactiveMode, int nextMergeId, int nextNodeId, int nextSymbolId)
        {
            // HINT: In the original implementation this logic was in the createTypeChecker function.
            // But because we can't use TypeScript idioms (with local variables and capturing lambdas),
            // this initialization is happening in the constructor.
            m_counters = new ThreadSafeCounters(nextMergeId, nextNodeId, nextSymbolId);

            m_host = host;
            m_produceDiagnostics = produceDiagnostics;
            m_degreeOfParallelism = degreeOfParallelism;
            m_trackFileToFileDependencies = trackFileToFileDependencies;
            m_interactiveMode = interactiveMode;
            m_compilerOptions = host.GetCompilerOptions();
            m_languageVersion = m_compilerOptions.Target.HasValue ? m_compilerOptions.Target.Value : ScriptTarget.Es3;
            m_modulekind = m_compilerOptions.Module.HasValue ? m_compilerOptions.Module.Value : (m_languageVersion == ScriptTarget.Es3 ? ModuleKind.Es6 : ModuleKind.None);
            m_allowSyntheticDefaultImports = m_compilerOptions.AllowSyntheticDefaultImports.HasValue ? m_compilerOptions.AllowSyntheticDefaultImports.Value : m_modulekind == ModuleKind.System;

            m_undefinedSymbol = CreateSymbol(
                SymbolFlags.Property | SymbolFlags.Transient,
                "undefined",
                new SymbolData { Declarations = new List<IDeclaration>() });

            m_argumentsSymbol = CreateSymbol(SymbolFlags.Property | SymbolFlags.Transient, "arguments");

            m_unknownSymbol = CreateSymbol(SymbolFlags.Property | SymbolFlags.Transient, "unknown");
            m_resolvingSymbol = CreateSymbol(SymbolFlags.Transient, "__resolving__");

            m_anyType = CreateIntrinsicType(TypeFlags.Any, "any");
            m_stringType = CreateIntrinsicType(TypeFlags.String, "string");
            m_numberType = CreateIntrinsicType(TypeFlags.Number, "number");
            m_booleanType = CreateIntrinsicType(TypeFlags.Boolean, "boolean");
            m_esSymbolType = CreateIntrinsicType(TypeFlags.EsSymbol, "symbol");
            m_voidType = CreateIntrinsicType(TypeFlags.Void, "void");
            m_undefinedType = CreateIntrinsicType(TypeFlags.Undefined | TypeFlags.ContainsUndefinedOrNull, "undefined");
            m_nullType = CreateIntrinsicType(TypeFlags.Null | TypeFlags.ContainsUndefinedOrNull, "null");
            m_unknownType = CreateIntrinsicType(TypeFlags.Any, "unknown");

            m_emptyObjectType = CreateAnonymousType(null, s_emptySymbols, s_emptySignatureEnumerable, s_emptySignatureEnumerable, null, null);
            m_emptyUnionType = m_emptyObjectType;

            m_emptyGenericType = CreateGenericType(null, s_emptySymbols, s_emptySignatureEnumerable, s_emptySignatureEnumerable, null, null);

            m_anyFunctionType = CreateAnonymousType(null, s_emptySymbols, s_emptySignatureEnumerable, s_emptySignatureEnumerable, null, null);

            // The anyFunctionType contains the anyFunctionType by definition. The flag is further propagated
            // in getPropagatingFlagsOfTypes, and it is checked in inferFromTypes.
            m_anyFunctionType.Flags |= TypeFlags.ContainsAnyFunctionType;

            m_noConstraintType = CreateAnonymousType(null, s_emptySymbols, s_emptySignatureEnumerable, s_emptySignatureEnumerable, null, null);

            m_anySignature = CreateSignature(null, null, new List<ISymbol>(), m_anyType, 0, /*hasRestParameter*/ false, /*hasStringLiterals*/
                false);
            m_unknownSignature = CreateSignature(null, null, new List<ISymbol>(), m_unknownType, 0, /*hasRestParameter*/ false,
                /*hasStringLiterals*/ false);

            m_builtinGlobals = new SymbolTable();
            m_builtinGlobals[m_undefinedSymbol.Name] = m_undefinedSymbol;

            // custom
            m_primitiveTypeInfo = CreatePrimitiveTypeInfo();
        }

        /// <summary>
        /// If the source files exposed by the host have already been type checked before, it is important to pass the right merge, node and symbol ids from the previous
        /// checker, so old information gets properly invalidated
        /// </summary>
        public static ITypeChecker CreateTypeChecker(
            TypeCheckerHost host,
            bool produceDiagnostics,
            int degreeOfParallelism,
            bool trackFileToFileDependencies = true,
            bool interactiveMode = false,
            int nextMergeId = 0,
            int nextNodeId = ThreadSafeCounters.DefaultMinNodeId,
            int nextSymbolId = 0)
        {
            var checker = new Checker(
                host,
                produceDiagnostics,
                degreeOfParallelism,
                trackFileToFileDependencies,
                interactiveMode,
                nextMergeId,
                nextNodeId,
                nextSymbolId);
            checker.InitializeTypeChecker();
            return checker;
        }

        /// <inheritdoc/>
        public int GetNodeCount()
        {
            return m_host.GetSourceFiles().Sum(f => f.NodeCount);
        }

        /// <inheritdoc/>
        public int GetIdentifierCount()
        {
            return m_host.GetSourceFiles().Sum(f => f.IdentifierCount);
        }

        /// <inheritdoc/>
        public int GetSymbolCount()
        {
            return m_host.GetSourceFiles().Sum(f => f.SymbolCount) + m_counters.GetSymbolCount();
        }

        /// <inheritdoc/>
        public int GetTypeCount() => m_counters.GetTypeCount();

        /// <inheritdoc/>
        public int GetCurrentMergeId()
        {
            return m_counters.GetCurrentMergeId();
        }

        /// <inheritdoc/>
        public int GetCurrentNodeId()
        {
            return m_counters.GetCurrentNodeId();
        }

        /// <inheritdoc/>
        public int GetCurrentSymbolId()
        {
            return m_counters.GetCurrentSymbolId();
        }

        /// <inheritdoc/>
        public bool IsUndefinedSymbol(ISymbol symbol)
        {
            return symbol == m_undefinedSymbol;
        }

        /// <inheritdoc/>
        public bool IsArgumentsSymbol(ISymbol symbol)
        {
            return symbol == m_argumentsSymbol;
        }

        private void Error(INode location, IDiagnosticMessage message, params object[] args)
        {
            var diagnostic = location != null
                ? Diagnostic.CreateDiagnosticForNode(location, message, args)
                : Diagnostic.CreateCompilerDiagnostic(message, args);
            m_diagnostics.Add(diagnostic);
        }

        private void Error(INode location, IDiagnosticMessage message)
        {
            var diagnostic = location != null
                ? Diagnostic.CreateDiagnosticForNode(location, message)
                : Diagnostic.CreateCompilerDiagnostic(message);
            m_diagnostics.Add(diagnostic);
        }

        private Symbol CreateSymbol(SymbolFlags flags, string name, SymbolData extraState, ISymbol originalSymbol)
        {
            m_counters.IncrementSymbolCount();
            return PublicSymbol.Create(flags, name, ref extraState, originalSymbol);
        }

        private Symbol CreateSymbol(SymbolFlags flags, string name, SymbolData extraState, bool isBuildXLModule)
        {
            m_counters.IncrementSymbolCount();
            return ExtendedSymbol.Create(flags, name, ref extraState, isBuildXLModule);
        }

        private Symbol CreateSymbol(SymbolFlags flags, string name, SymbolData extraState)
        {
            m_counters.IncrementSymbolCount();
            return Symbol.Create(flags, name, ref extraState);
        }

        private Symbol CreateSymbol(SymbolFlags flags, string name)
        {
            m_counters.IncrementSymbolCount();
            return Symbol.Create(flags, name);
        }

        [System.Diagnostics.Contracts.Pure]
        private static SymbolFlags GetExcludedSymbolFlags(SymbolFlags flags)
        {
            SymbolFlags result = SymbolFlags.None;
            if ((flags & SymbolFlags.BlockScopedVariable) != SymbolFlags.None)
            {
                result |= SymbolFlags.BlockScopedVariableExcludes;
            }

            if ((flags & SymbolFlags.FunctionScopedVariable) != SymbolFlags.None)
            {
                result |= SymbolFlags.FunctionScopedVariableExcludes;
            }

            if ((flags & SymbolFlags.Property) != SymbolFlags.None)
            {
                result |= SymbolFlags.PropertyExcludes;
            }

            if ((flags & SymbolFlags.EnumMember) != SymbolFlags.None)
            {
                result |= SymbolFlags.EnumMemberExcludes;
            }

            if ((flags & SymbolFlags.Function) != SymbolFlags.None)
            {
                result |= SymbolFlags.FunctionExcludes;
            }

            if ((flags & SymbolFlags.Class) != SymbolFlags.None)
            {
                result |= SymbolFlags.ClassExcludes;
            }

            if ((flags & SymbolFlags.Interface) != SymbolFlags.None)
            {
                result |= SymbolFlags.InterfaceExcludes;
            }

            if ((flags & SymbolFlags.RegularEnum) != SymbolFlags.None)
            {
                result |= SymbolFlags.RegularEnumExcludes;
            }

            if ((flags & SymbolFlags.ConstEnum) != SymbolFlags.None)
            {
                result |= SymbolFlags.ConstEnumExcludes;
            }

            if ((flags & SymbolFlags.ValueModule) != SymbolFlags.None)
            {
                result |= SymbolFlags.ValueModuleExcludes;
            }

            if ((flags & SymbolFlags.Method) != SymbolFlags.None)
            {
                result |= SymbolFlags.MethodExcludes;
            }

            if ((flags & SymbolFlags.GetAccessor) != SymbolFlags.None)
            {
                result |= SymbolFlags.GetAccessorExcludes;
            }

            if ((flags & SymbolFlags.SetAccessor) != SymbolFlags.None)
            {
                result |= SymbolFlags.SetAccessorExcludes;
            }

            if ((flags & SymbolFlags.TypeParameter) != SymbolFlags.None)
            {
                result |= SymbolFlags.TypeParameterExcludes;
            }

            if ((flags & SymbolFlags.TypeAlias) != SymbolFlags.None)
            {
                result |= SymbolFlags.TypeAliasExcludes;
            }

            if ((flags & SymbolFlags.Alias) != SymbolFlags.None)
            {
                result |= SymbolFlags.AliasExcludes;
            }

            return result;
        }

        private ISymbol CloneSymbol(ISymbol symbol)
        {
            var result = CreateSymbol(
                symbol.Flags | SymbolFlags.Merged,
                symbol.Name,
                new SymbolData
                {
                    ReadOnlyDeclarations = symbol.DeclarationList.ToList(),
                    Parent = symbol.Parent,
                    ValueDeclaration = symbol.ValueDeclaration,
                    Members = CloneSymbolTable(symbol.Members),
                    Exports = CloneSymbolTable(symbol.Exports),
                });

            RecordMergedSymbol(result, symbol);
            return result;
        }

        private void MergeSymbol(ISymbol target, ISymbol source)
        {
            if ((target.Flags & GetExcludedSymbolFlags(source.Flags)) == SymbolFlags.None)
            {
                target.Merge(source, this);
                RecordMergedSymbol(target, source);
            }
            else
            {
                var message = (target.Flags & SymbolFlags.BlockScopedVariable) != SymbolFlags.None ||
                              (source.Flags & SymbolFlags.BlockScopedVariable) != SymbolFlags.None
                    ? Errors.Cannot_redeclare_block_scoped_variable_0
                    : Errors.Duplicate_identifier_0;

                foreach (var node in source.DeclarationList)
                {
                    Error(node.Name.ResolveUnionType(), message, SymbolToString(source));
                }

                foreach (var node in target.DeclarationList)
                {
                    Error(node.Name.ResolveUnionType(), message, SymbolToString(source));
                }
            }
        }

        /// <summary>
        /// The exclusion parameter is DScript-specific and it determines,
        /// if present, what symbols to exclude from cloning
        /// </summary>
        [CanBeNull]
        private static ISymbolTable CloneSymbolTable([CanBeNull]ISymbolTable symbolTable, Func<ISymbol, bool> exclude = null)
        {
            if (symbolTable == null)
            {
                return null;
            }

            ISymbolTable result = new SymbolTable();
            foreach (var kvp in symbolTable)
            {
                if (exclude == null || !exclude(kvp.Value))
                {
                    result[kvp.Key] = kvp.Value;
                }
            }

            return result;
        }

        /// <summary>
        /// Recursively removes all non-public symbols from namespaces in the symbol table
        /// </summary>
        [CanBeNull]
        private ISymbolTable FilterNonPublicNamespaceMembers([CanBeNull]ISymbolTable symbolTable)
        {
            if (symbolTable == null)
            {
                return null;
            }

            ISymbolTable result = new SymbolTable(symbolTable.Count);
            foreach (var kvp in symbolTable)
            {
                var symbol = kvp.Value;
                // Directly skip non-public symbols
                if ((symbol.Flags & SymbolFlags.ScriptPublic) != SymbolFlags.None)
                {
                    // If the symbol is a namespace, we keep only its public surface
                    if ((symbol.Flags & SymbolFlags.Namespace) != SymbolFlags.None)
                    {
                        symbol = ClonePublicSurfaceOfSymbol(kvp.Value);
                    }
                    result[kvp.Key] = symbol;
                }
            }

            return result;
        }

        private ISymbol ClonePublicSurfaceOfSymbol(ISymbol symbol)
        {
            // We create a new symbol that is the public version of the given one and recursively filter its exports
            var result = CreateSymbol(
                symbol.Flags,
                symbol.Name,
                new SymbolData
                {
                    // We only keep the public declarations
                    ReadOnlyDeclarations = symbol.DeclarationList.Where(
                        declaration =>
                            (GetCombinedFlagsIncludingExportSpecifiers(declaration) & NodeFlags.ScriptPublic) != NodeFlags.None).ToList(),
                    Parent = symbol.Parent,
                    ValueDeclaration = symbol.ValueDeclaration,
                    Members = symbol.Members,
                    // We only keep the public symbols of exports
                    Exports = FilterNonPublicNamespaceMembers(symbol.Exports),
                },
                originalSymbol: symbol);
            
            return result;
        }

        private void AddFileSymbolInformationToModule(string moduleName, ISourceFile file)
        {
            // Create the internal table for that module if this is the first time we see it
            ISymbolTable internalSymbolTable = m_moduleTableInternals.GetOrCreateSymbolTable(moduleName);

            var exports = file.Symbol?.Exports;
            if (exports == null)
            {
                // Nothing to merge.
                return;
            }

            // We merge the exports of the file symbol, since internal symbols are exported
            // from a strict TS point of view
            MergeSymbolTable(internalSymbolTable, exports);
        }

        /// <summary>
        /// The exclusion argument in the original TypeScript code is a list of symbol names. Here we generalize it to a function.
        /// </summary>
        public void MergeSymbolTable([NotNull]ISymbolTable target, [NotNull]ISymbolTable source)
        {
            foreach (var kvp in source)
            {
                var id = kvp.Key;
                var sourceSymbol = kvp.Value;
                if (!HasProperty(target, id))
                {
                    target[id] = sourceSymbol;
                }
                else
                {
                    var symbol = target[id];
                    if ((symbol.Flags & SymbolFlags.Merged) == SymbolFlags.None)
                    {
                        target[id] = symbol = CloneSymbol(symbol);
                    }

                    MergeSymbol(symbol, kvp.Value);
                }
            }
        }

        private static void AddDeclarationDiagnostic(IDiagnosticCollection diagnostics, IDeclaration declaration, string id, IDiagnosticMessage msg)
        {
            diagnostics.Add(Diagnostic.CreateDiagnosticForNode(declaration, msg, id));
        }

        private void AddToSymbolTable(ISymbolTable target, ISymbolTable source, IDiagnosticMessage message)
        {
            foreach (var id in source)
            {
                ISymbol targetSymbol;
                if (TryGetProperty(target, id.Key, out targetSymbol))
                {
                    // Error on redeclarations
                    foreach (var declaration in targetSymbol.DeclarationList)
                    {
                        AddDeclarationDiagnostic(m_diagnostics, declaration, id.Key, message);
                    }
                }
                else
                {
                    target[id.Key] = id.Value;
                }
            }
        }

        [NotNull]
        private ISymbolLinks GetSymbolLinks([NotNull]ISymbol symbol)
        {
            if ((symbol.Flags & SymbolFlags.Transient) != SymbolFlags.None)
            {
                return (ITransientSymbol)symbol;
            }

            int id = GetSymbolId(symbol);

            return m_symbolLinks.GetOrAdd(id, () => new SymbolLinks());
        }

        [NotNull]
        private NodeLinks GetNodeLinks([NotNull]INode node)
        {
            int nodeId = GetNodeId(node);

            return m_nodeLinks.GetOrAdd(nodeId, () => new NodeLinks());
        }

        [CanBeNull]
        private NodeLinks TryGetNodeLinks([NotNull] INode node)
        {
            int nodeId = GetNodeId(node);
            return m_nodeLinks.Get(nodeId);
        }

        private static ISourceFile GetSourceFile(INode node)
        {
            return node.GetSourceFile();
        }

        private bool IsGlobalSourceFile(INode node)
        {
            // For DScript files this is always false.
            // It is very important to check this first, because this method called a lot of times.
            if (m_isScriptFile)
            {
                // DScript files are not a global files.
                return false;
            }

            if (node.Kind != SyntaxKind.SourceFile)
            {
                return false;
            }

            var sourceFile = (ISourceFile)node;
            return !SourceFileExtensions.IsExternalOrCommonJsModule(sourceFile);
        }

        /// <summary>
        /// Is this type one of the apparent types created from the primitive types.
        /// </summary>
        private bool IsPrimitiveApparentType(IType type)
        {
            return type == m_globalStringType ||
                   type == m_globalNumberType ||
                   type == m_globalBooleanType ||
                   type == m_globalEsSymbolType;
        }

        private ISymbol GetSymbol(ISymbolTable symbols, string name, SymbolFlags meaning)
        {
            ISymbol symbol = null;
            if (meaning != SymbolFlags.None && TryGetProperty(symbols, name, out symbol))
            {
                Contract.Assert((symbol.Flags & SymbolFlags.Instantiated) == SymbolFlags.None, "Should never get an instantiated symbol here.");
                if ((symbol.Flags & meaning) != SymbolFlags.None)
                {
                    return symbol;
                }

                if ((symbol.Flags & SymbolFlags.Alias) != SymbolFlags.None)
                {
                    var target = ResolveAlias(symbol);

                    // Unknown symbol means an error occurred in alias resolution, treat it as positive answer to avoid cascading errors
                    if (target == m_unknownSymbol || (target.Flags & meaning) != SymbolFlags.None)
                    {
                        return symbol;
                    }
                }
            }

            // return null if we can't find a symbol.
            return null;
        }

        /// <summary>
        /// Get symbols that represent parameter-property-declaration as parameter and as property declaration
        /// </summary>
        /// <param name="parameter">a parameterDeclaration node</param>
        /// <param name="parameterName">a name of the parameter to get the symbols for.</param>
        /// <returns>a tuple of two symbols</returns>
        private Tuple<ISymbol, ISymbol> GetSymbolsOfParameterPropertyDeclaration(IParameterDeclaration parameter, string parameterName)
        {
            var constructorDeclaration = parameter.Parent;
            var classDeclaration = parameter.Parent.Parent;

            var parameterSymbol = GetSymbol(constructorDeclaration.Locals, parameterName, SymbolFlags.Value);
            var propertySymbol = GetSymbol(classDeclaration.Symbol.Members, parameterName, SymbolFlags.Value);

            if (parameterSymbol != null && propertySymbol != null)
            {
                return Tuple.Create(parameterSymbol, propertySymbol);
            }

            Contract.Assert(false, "There should exist two symbols, one as property declaration and one as parameter declaration");
            return null;
        }

        private bool IsBlockScopedNameDeclaredBeforeUse(IDeclaration declaration, INode usage)
        {
            var declarationFile = declaration.GetSourceFile();
            var useFile = usage.GetSourceFile();

            if (declarationFile != useFile)
            {
                if ((m_modulekind != ModuleKind.None) ||
                    (!m_compilerOptions.OutFile && !m_compilerOptions.Out))
                {
                    // nodes are in different files and order cannot be determined
                    return true;
                }

                var sourceFiles = m_host.GetSourceFiles();
                return sourceFiles.IndexOf(declarationFile) <= sourceFiles.IndexOf(useFile);
            }

            if (declaration.Pos <= usage.Pos)
            {
                // declaration is before usage
                // still might be illegal if usage is in the initializer of the variable declaration
                return declaration.Kind != SyntaxKind.VariableDeclaration ||
                       !IsImmediatelyUsedInInitializerOfBlockScopedVariable(declaration.Cast<IVariableDeclaration>(), usage);
            }

            // declaration is after usage
            // can be legal if usage is deferred (i.e., inside function or in initializer of instance property)
            return IsUsedInFunctionOrNonStaticProperty(declaration, usage);
        }

        private static bool IsImmediatelyUsedInInitializerOfBlockScopedVariable(IVariableDeclaration declaration, INode usage)
        {
            var container = GetEnclosingBlockScopeContainer(declaration);

            if (declaration.Parent.Parent.Kind == SyntaxKind.VariableStatement ||
                declaration.Parent.Parent.Kind == SyntaxKind.ForStatement)
            {
                // variable statement/for statement case,
                // use site should not be inside variable declaration (initializer of declaration or binding element)
                return IsSameScopeDescendentOf(usage, declaration, container);
            }
            else if (declaration.Parent.Parent.Kind == SyntaxKind.ForOfStatement ||
                     declaration.Parent.Parent.Kind == SyntaxKind.ForInStatement)
            {
                // ForIn/ForOf case - use site should not be used in expression part
                var expression = declaration.Parent.Parent.Kind == SyntaxKind.ForInStatement
                    ? declaration.Parent.Parent.Cast<IForInStatement>().Expression
                    : declaration.Parent.Parent.Cast<IForOfStatement>().Expression;

                return IsSameScopeDescendentOf(usage, expression, container);
            }

            return false;
        }

        private static bool IsUsedInFunctionOrNonStaticProperty(IDeclaration declaration, INode usage)
        {
            var container = GetEnclosingBlockScopeContainer(declaration);
            var current = usage;

            while (current != null)
            {
                if (current.ResolveUnionType() == container.ResolveUnionType())
                {
                    return false;
                }

                if (IsFunctionLike(current) != null)
                {
                    return true;
                }

                var initializerOfNonStaticProperty =
                    current.Parent != null &&
                    current.Parent.Kind == SyntaxKind.PropertyDeclaration &&
                    (current.Parent.Flags & NodeFlags.Static) == NodeFlags.None &&
                    current.Parent.Cast<IPropertyDeclaration>().Initializer.ResolveUnionType() == current.ResolveUnionType();

                if (initializerOfNonStaticProperty)
                {
                    return true;
                }

                current = current.Parent;
            }

            return false;
        }

        /// <summary>
        /// Resolve a given name for a given meaning at a given location. An error is reported if the name was not found and
        /// the nameNotFoundMessage argument is not null. Returns the resolved symbol, or null if no symbol with
        /// the given name can be found.
        ///
        /// HINT: Created a function overload because ResolveName's last parameter (nameArg)
        ///       is defined in TS implementation as (string | Identifier) type, and it seems unnecessary
        ///       to create a type union just for this.
        /// </summary>
        [CanBeNull]
        private ISymbol ResolveName(INode location, string name, SymbolFlags meaning, IDiagnosticMessage nameNotFoundMessage, IIdentifier nameArg)
        {
            return ResolveName(location, name, meaning, nameNotFoundMessage, nameArgAsString: null, nameArg: nameArg);
        }

        // Resolve a given name for a given meaning at a given location. An error is reported if the name was not found and
        // the nameNotFoundMessage argument is not null. Returns the resolved symbol, or null if no symbol with
        // the given name can be found.
        [CanBeNull]
        private ISymbol ResolveName(INode location, string name, SymbolFlags meaning, IDiagnosticMessage nameNotFoundMessage, string nameArgAsString, IIdentifier nameArg = null)
        {
            ISymbol result = null;
            INode lastLocation = null;
            INode propertyWithInvalidInitializer = null;
            INode errorLocation = location;
            INode grandparent = null;

            // HINT: TypeScript implementation uses goto-style label to break out of loop from the switch statement
            //       Switching to state check in the loop's condition.
            bool breakLoop = false;

            // DScript-specific. If we are trying to resolve the special namespace $, then
            // the resolution is fixed: this name cannot be shadowed by any other name
            // (there are lint rules that block naming any entity $ anyway)
            // Additionally, $ has to be the first qualification on a qualified name, and therefore it is always
            // a reference to the module (or source file in legacy modules) associated to the place
            // where the reference occurs
            if (name == Names.RootNamespace && (meaning & SymbolFlags.Namespace) != SymbolFlags.None)
            {
                var sourceFile = location.GetSourceFile();
                ModuleName moduleName;

                // V2 case, we return a (unique per module) symbol representing all internal values
                if (TryGetOwningModuleWithImplicitSemantics(sourceFile.FileName, out moduleName))
                {
                    return GetInternalModuleSymbol(moduleName.Name);
                }

                // V1 case, the $ symbol represents the source file, there are no implicit semantics
                return sourceFile.Symbol;
            }

            while (location != null && !breakLoop)
            {
                // Locals of a source file are not in scope (because they get merged into the global symbol table)
                if (location.Locals != null && !IsGlobalSourceFile(location))
                {
                    result = GetSymbol(location.Locals, name, meaning);
                    if (result != null)
                    {
                        var useResult = true;
                        if (IsFunctionLike(location) != null &&
                            lastLocation != null &&

                            // Can't compare nodes directly, because Body could be a union wrapper
                            lastLocation.ResolveUnionType() != location.Cast<IFunctionLikeDeclaration>().Body.ResolveUnionType())
                        {
                            // symbol lookup restrictions for function-like declarations
                            // - Type parameters of a function are in scope in the entire function declaration, including the parameter
                            //   list and return type. However, local types are only in scope in the function body.
                            // - parameters are only in the scope of function body
                            if ((meaning & result.Flags & SymbolFlags.Type) != SymbolFlags.None)
                            {
                                useResult = (result.Flags & SymbolFlags.TypeParameter) != SymbolFlags.None

                                    // type parameters are visible in parameter list, return type and type parameter list
                                    ? lastLocation.ResolveUnionType() == location.Cast<IFunctionLikeDeclaration>().Type.ResolveUnionType() ||
                                      lastLocation.Kind == SyntaxKind.Parameter ||
                                      lastLocation.Kind == SyntaxKind.TypeParameter

                                    // local types not visible outside the body
                                    : false;
                            }

                            if ((meaning & SymbolFlags.Value) != SymbolFlags.None &&
                                (result.Flags & SymbolFlags.FunctionScopedVariable) != SymbolFlags.None)
                            {
                                // parameters are visible only inside function body, parameter list and return type
                                // technically for parameter list case here we might mix parameters and variables declared in function,
                                // however it is detected separately when checking initializers of parameters
                                // to make sure that they reference no variables declared after them.
                                useResult =
                                    lastLocation.Kind == SyntaxKind.Parameter ||
                                    (lastLocation.ResolveUnionType() == location.Cast<IFunctionLikeDeclaration>().Type.ResolveUnionType() &&
                                     result.ValueDeclaration.Kind == SyntaxKind.Parameter);
                            }
                        }

                        if (useResult)
                        {
                            breakLoop = true;
                            break;
                        }
                        else
                        {
                            result = null;
                        }
                    }
                }

                switch (location.Kind)
                {
                    case SyntaxKind.SourceFile:
                    case SyntaxKind.ModuleDeclaration:
                        if (IsGlobalSourceFile(location))
                        {
                            break;
                        }

                        // DScript-specific. If the lookup reached the source file level and the source file is owned by a module with implicit
                        // reference semantics, the module exports that is used is the one that holds all internal values from the module. In that
                        // way all internal values will behave as implicitly imported. Otherwise, we preserve the original TS logic.
                        ModuleName moduleName;
                        ISymbolTable moduleExports = GetInternalModuleExports(location, out moduleName);

                        // TODO: revisit. Adding this to avoid a crash
                        if (moduleExports == null)
                        {
                            result = null;
                            breakLoop = true;
                            break;
                        }

                        if ((location.Kind == SyntaxKind.SourceFile) ||
                            (location.Kind == SyntaxKind.ModuleDeclaration &&
                             location.Cast<IModuleDeclaration>().Name.Kind == SyntaxKind.StringLiteral))
                        {
                            // It's an external module. First see if the module has an export default and if the local
                            // name of that export default matches.
                            result = moduleExports["default"];
                            if (result != null)
                            {
                                ISymbol localSymbol = GetLocalSymbolForExportDefault(result);
                                if ((localSymbol != null) &&
                                    (result.Flags & meaning) != SymbolFlags.None &&
                                    (localSymbol.Name == name))
                                {
                                    breakLoop = true;
                                    break;
                                }

                                result = null;
                            }

                            // Because of module/namespace merging, a module's exports are in scope,
                            // yet we never want to treat an export specifier as putting a member in scope.
                            // Therefore, if the name we find is purely an export specifier, it is not actually considered in scope.
                            // Two things to note about this:
                            //     1. We have to check this without calling getSymbol. The problem with calling getSymbol
                            //        on an export specifier is that it might find the export specifier itself, and try to
                            //        resolve it as an alias. This will cause the checker to consider the export specifier
                            //        a circular alias reference when it might not be.
                            //     2. We check == SymbolFlags.Alias in order to check that the symbol is *purely*
                            //        an alias. If we used &, we'd be throwing out symbols that have non alias aspects,
                            //        which is not the desired behavior.
                            if (HasProperty(moduleExports, name) &&
                                moduleExports[name].Flags == SymbolFlags.Alias)
                            {
                                var moduleExportDeclaration = GetDeclarationOfKind(moduleExports[name], SyntaxKind.ExportSpecifier);
                                if (moduleExportDeclaration != null)
                                {
                                    // DScript-specific. If the export specifier resides in a module with V2 semantics
                                    // the symbol *is* in scope for other specs in the same module
                                    // But this is the case only for other specs, in the same spec the symbol is not in scope, so we keep
                                    // the semantics of export specifiers (e.g. export {a as b} does not introduce b in the local scope)
                                    if (moduleName != ModuleName.Invalid && moduleExportDeclaration.GetSourceFile() != location)
                                    {
                                        result = moduleExports[name];
                                        breakLoop = true;
                                    }

                                    break;
                                }
                            }
                        }

                        result = GetSymbol(moduleExports, name, meaning & SymbolFlags.ModuleMember);
                        if (result != null)
                        {
                            breakLoop = true;
                            break;
                        }

                        break;
                    case SyntaxKind.EnumDeclaration:
                        result = GetSymbol(GetSymbolOfNode(location).Exports, name, meaning & SymbolFlags.EnumMember);
                        if (result != null)
                        {
                            breakLoop = true;
                            break;
                        }

                        break;
                    case SyntaxKind.PropertyDeclaration:
                    case SyntaxKind.PropertySignature:
                        // TypeScript 1.0 spec (April 2014): 8.4.1
                        // Initializer expressions for instance member variables are evaluated in the scope
                        // of the class constructor body but are not permitted to reference parameters or
                        // local variables of the constructor. This effectively means that entities from outer scopes
                        // by the same name as a constructor parameter or local variable are inaccessible
                        // in initializer expressions for instance member variables.
                        if ((IsClassLike(location.Parent) != null) &&
                            (location.Flags & NodeFlags.Static) == NodeFlags.None)
                        {
                            IConstructorDeclaration ctor = FindConstructorDeclaration(location.Parent.Cast<IClassLikeDeclaration>());
                            if (ctor != null && ctor.Locals != null)
                            {
                                if (GetSymbol(ctor.Locals, name, meaning & SymbolFlags.Value) != null)
                                {
                                    // Remember the property node, it will be used later to report appropriate error
                                    propertyWithInvalidInitializer = location;
                                }
                            }
                        }

                        break;
                    case SyntaxKind.ClassDeclaration:
                    case SyntaxKind.ClassExpression:
                    case SyntaxKind.InterfaceDeclaration:
                        result = GetSymbol(GetSymbolOfNode(location).Members, name, meaning & SymbolFlags.Type);
                        if (result != null)
                        {
                            if ((lastLocation != null) &&
                                (lastLocation.Flags & NodeFlags.Static) != NodeFlags.None)
                            {
                                // TypeScript 1.0 spec (April 2014): 3.4.1
                                // The scope of a type parameter extends over the entire declaration with which the type
                                // parameter list is associated, with the exception of static member declarations in classes.
                                Error(errorLocation, Errors.Static_members_cannot_reference_class_type_parameters);
                                return null;
                            }

                            breakLoop = true;
                            break;
                        }

                        if ((location.Kind == SyntaxKind.ClassExpression) &&
                            (meaning & SymbolFlags.Class) != SymbolFlags.None)
                        {
                            var className = location.Cast<IClassExpression>().Name;
                            if (className != null && name.Equals(className.Text))
                            {
                                result = location.Symbol;
                                breakLoop = true;
                                break;
                            }
                        }

                        break;

                    // It is not legal to reference a class's own type parameters from a computed property name that
                    // belongs to the class. For example:
                    //
                    //   function foo<T>() { return '' }
                    //   class C<T> { // <-- Class's own type parameter T
                    //       [foo<T>()]() { } // <-- Reference to T from class's own computed property
                    //   }
                    case SyntaxKind.ComputedPropertyName:
                        grandparent = location.Parent.Parent;
                        if (IsClassLike(grandparent) != null ||
                            grandparent.Kind == SyntaxKind.InterfaceDeclaration)
                        {
                            // A reference to this grandparent's type parameters would be an error
                            result = GetSymbol(GetSymbolOfNode(grandparent).Members, name, meaning & SymbolFlags.Type);
                            if (result != null)
                            {
                                Error(errorLocation, Errors.A_computed_property_name_cannot_reference_a_type_parameter_from_its_containing_type);
                                return null;
                            }
                        }

                        break;
                    case SyntaxKind.MethodDeclaration:
                    case SyntaxKind.MethodSignature:
                    case SyntaxKind.Constructor:
                    case SyntaxKind.GetAccessor:
                    case SyntaxKind.SetAccessor:
                    case SyntaxKind.FunctionDeclaration:
                    case SyntaxKind.ArrowFunction:
                        if ((meaning & SymbolFlags.Variable) != SymbolFlags.None && name.Equals("arguments"))
                        {
                            result = m_argumentsSymbol;
                            breakLoop = true;
                            break;
                        }

                        break;
                    case SyntaxKind.FunctionExpression:
                        if ((meaning & SymbolFlags.Variable) != SymbolFlags.None && name.Equals("arguments"))
                        {
                            result = m_argumentsSymbol;
                            breakLoop = true;
                            break;
                        }

                        if ((meaning & SymbolFlags.Function) != SymbolFlags.None)
                        {
                            var functionName = location.Cast<IFunctionExpression>().Name;
                            if (functionName != null && name.Equals(functionName.Text))
                            {
                                result = location.Symbol;
                                breakLoop = true;
                                break;
                            }
                        }

                        break;
                    case SyntaxKind.Decorator:
                        // Decorators are resolved at the class declaration. Resolving at the parameter
                        // or member would result in looking up locals in the method.
                        //
                        //   function y() {}
                        //   class C {
                        //       method(@y x, y) {} // <-- decorator y should be resolved at the class declaration, not the parameter.
                        //   }
                        if (location.Parent != null && location.Parent.Kind == SyntaxKind.Parameter)
                        {
                            location = location.Parent;
                        }

                        // function y() {}
                        // class C {
                        //       @y method(x, y) {} // <-- decorator y should be resolved at the class declaration, not the method.
                        // }
                        if (location.Parent != null && IsClassElement(location.Parent))
                        {
                            location = location.Parent;
                        }

                        break;
                }

                lastLocation = location;
                location = location.Parent;
            }

            if (result == null)
            {
                result = GetSymbol(m_globals, name, meaning);
            }

            if (result == null)
            {
                if (nameNotFoundMessage != null)
                {
                    Error(errorLocation, nameNotFoundMessage, nameArgAsString ?? (nameArgAsString = DeclarationNameToString(nameArg)));
                }

                return null;
            }

            // Perform extra checks only if error reporting was requested
            if (nameNotFoundMessage != null)
            {
                if (propertyWithInvalidInitializer != null)
                {
                    // We have a match, but the reference occurred within a property initializer and the identifier also binds
                    // to a local variable in the constructor where the code will be emitted.

                    // TODO: Verify equivalence - const propertyName = (<PropertyDeclaration>propertyWithInvalidInitializer).Name;
                    var propertyName = propertyWithInvalidInitializer.Kind == SyntaxKind.PropertyDeclaration
                        ? propertyWithInvalidInitializer.Cast<IPropertyDeclaration>().Name
                        : propertyWithInvalidInitializer.Cast<IPropertySignature>().Name;

                    Error(
                        errorLocation,
                        Errors.Initializer_of_instance_member_variable_0_cannot_reference_identifier_1_declared_in_the_constructor,
                        DeclarationNameToString(propertyName),
                        nameArgAsString ?? (nameArgAsString = DeclarationNameToString(nameArg)));

                    return null;
                }

                // Only check for block-scoped variable if we are looking for the
                // name with variable meaning
                //      For example,
                //          declare module foo {
                //              interface bar {}
                //          }
                //      const foo/*1*/: foo/*2*/.bar;
                // The foo at /*1*/ and /*2*/ will share same symbol with two meaning
                // block - scope variable and namespace module. However, only when we
                // try to resolve name in /*1*/ which is used in variable position,
                // we want to check for block- scoped
                if ((meaning & SymbolFlags.BlockScopedVariable) != SymbolFlags.None)
                {
                    ISymbol exportOrLocalSymbol = GetExportSymbolOfValueSymbolIfExported(result);
                    if ((exportOrLocalSymbol.Flags & SymbolFlags.BlockScopedVariable) != SymbolFlags.None)
                    {
                        CheckResolvedBlockScopedVariable(exportOrLocalSymbol, errorLocation);
                    }
                }
            }

            return result;
        }

        private ISymbolTable GetInternalModuleExports(INode location, out ModuleName moduleName)
        {
            moduleName = ModuleName.Invalid;
            ISymbolTable moduleExports;
            if (location.Kind == SyntaxKind.SourceFile && TryGetOwningModuleWithImplicitSemantics(((ISourceFile)location).FileName, out moduleName))
            {
                moduleExports = m_moduleTableInternals[moduleName.Name];
            }
            else
            {
                moduleExports = GetSymbolOfNode(location)?.Exports;
            }

            return moduleExports;
        }

        private ISymbolTable GetModuleExportsOfSymbol(INode enclosingDeclaration, ISymbol symbol)
        {
            // If the symbol is not a DScript module, then there is no DScript-specific behavior, just return
            // the regular exports
            if (!symbol.IsBuildXLModule)
            {
                return GetExportsOfSymbol(symbol);
            }

            // Otherwise, try to get if the module is v1 or v2
            var symbolDeclaration = symbol.GetFirstDeclarationOrDefault();
            if (symbolDeclaration == null)
            {
                return null;
            }

            ModuleName referencedModule;
            var success = m_host.TryGetOwningModule(symbolDeclaration.GetSourceFile().Path.AbsolutePath, out referencedModule);
            Contract.Assert(success);

            // If the symbol lives in a V1 module, then the exports are associated to the symbols directly
            if (!referencedModule.ProjectReferencesAreImplicit)
            {
                return GetExportsOfSymbol(symbol);
            }

            // So this is the V2 case

            // Depending on whether the enclosing declaration lives in the same module where the symbol is
            // defined, the enclosing declaration has access to internals or public exports
            ModuleName referencingModule;
            success = m_host.TryGetOwningModule(enclosingDeclaration.GetSourceFile().Path.AbsolutePath, out referencingModule);
            Contract.Assert(success);

            // If we are in the same module, then the symbol already has all its internals resolved
            if (referencedModule == referencingModule)
            {
                return GetExportsOfSymbol(symbol);
            }

            // Otherwise, we need to present the public exports of the symbol
            ISymbolTable moduleInternalSymbolTable;
            if (m_moduleTableInternals.TryGetValueAtomic(referencedModule.Name, out moduleInternalSymbolTable))
            {
                var resultingSymbol = ResolveScriptPublicModuleName(referencedModule.Name, moduleInternalSymbolTable);

                // Otherwise the symbol is a public module and we get is exports in the usual way
                return GetExportsOfSymbol(resultingSymbol);
            }

            return null;
        }

        private bool TryGetOwningModuleWithImplicitSemantics(string filename, out ModuleName moduleName)
        {
            if (m_host.TryGetOwningModule(filename, out moduleName) && moduleName.ProjectReferencesAreImplicit)
            {
                return true;
            }

            moduleName = ModuleName.Invalid;
            return false;
        }

        private void CheckResolvedBlockScopedVariable(ISymbol result, INode errorLocation)
        {
            Contract.Requires((result.Flags & SymbolFlags.BlockScopedVariable) != SymbolFlags.None);

            // Block-scoped variables cannot be used before their definition
            IDeclaration declaration = null;
            foreach (var d in result.DeclarationList)
            {
                if (IsBlockOrCatchScoped(d))
                {
                    declaration = d;
                    break;
                }
            }

            Contract.Assert(declaration != null, "Block-scoped variable declaration is null");

            if (!IsBlockScopedNameDeclaredBeforeUse(GetAncestor(declaration, SyntaxKind.VariableDeclaration).Cast<IDeclaration>(), errorLocation))
            {
                Error(
                    errorLocation,
                    Errors.Block_scoped_variable_0_used_before_its_declaration,
                    DeclarationNameToString(declaration.Name));
            }
        }

        /// <summary>
        /// Starting from 'initial' node walk up the parent chain until 'stopAt' node is reached.
        /// If at any point current node is equal to 'parent' node - return true.
        /// Return false if 'stopAt' node is reached or IsFunctionLike(current) == true.
        /// </summary>
        private static bool IsSameScopeDescendentOf(INode initial, INode parent, INode stopAt)
        {
            if (parent == null)
            {
                return false;
            }

            for (var current = initial; (current != null) && (current.ResolveUnionType() != stopAt.ResolveUnionType()) && (IsFunctionLike(current) == null); current = current.Parent)
            {
                if (current.ResolveUnionType() == parent.ResolveUnionType())
                {
                    return true;
                }
            }

            return false;
        }

        private static AnyImportSyntax GetAnyImportSyntax(INode node)
        {
            if (IsAliasSymbolDeclaration(node))
            {
                if (node.Kind == SyntaxKind.ImportEqualsDeclaration)
                {
                    return new AnyImportSyntax(node.Cast<IImportEqualsDeclaration>());
                }

                while (node != null && node.Kind != SyntaxKind.ImportDeclaration)
                {
                    node = node.Parent;
                }

                return new AnyImportSyntax(node.Cast<IImportDeclaration>());
            }

            return null;
        }

        [System.Diagnostics.Contracts.Pure]
        [CanBeNull]
        private static IDeclaration GetDeclarationOfAliasSymbol(ISymbol symbol)
        {
            foreach (var d in symbol.DeclarationList)
            {
                if (IsAliasSymbolDeclaration(d))
                {
                    return d;
                }
            }

            return null;
        }

        private ISymbol GetTargetOfImportEqualsDeclaration(IImportEqualsDeclaration node)
        {
            if (node.ModuleReference.Kind == SyntaxKind.ExternalModuleReference)
            {
                return ResolveExternalModuleSymbol(
                            ResolveExternalModuleName(
                                node,
                                GetExternalModuleImportEqualsDeclarationExpression(node)));
            }

            return GetSymbolOfPartOfRightHandSideOfImportEquals(node.ModuleReference, node);
        }

        private ISymbol GetTargetOfImportClause(IImportClause node)
        {
            ISymbol moduleSymbol = ResolveExternalModuleName(node, node.Parent.Cast<IImportDeclaration>().ModuleSpecifier);
            if (moduleSymbol != null)
            {
                ISymbol exportDefaultSymbol = ResolveSymbol(moduleSymbol.Exports["default"]);
                if (exportDefaultSymbol == null && !m_allowSyntheticDefaultImports)
                {
                    Error(node.Name, Errors.Module_0_has_no_default_export, SymbolToString(moduleSymbol));
                }
                else if (exportDefaultSymbol == null && m_allowSyntheticDefaultImports)
                {
                    return ResolveSymbol(moduleSymbol.Exports["export="]) ?? ResolveSymbol(moduleSymbol);
                }

                return exportDefaultSymbol;
            }

            return null;
        }

        private ISymbol GetTargetOfNamespaceImport(INamespaceImport node)
        {
            var moduleSpecifier = node.Parent.Parent.Cast<IImportDeclaration>().ModuleSpecifier;
            return ResolveEsModuleSymbol(ResolveExternalModuleName(node, moduleSpecifier), moduleSpecifier);
        }

        // This function creates a synthetic symbol that combines the value side of one symbol with the
        // type/namespace side of another symbol. Consider this example:
        //
        //   declare module graphics {
        //       interface Point {
        //           x: number;
        //           y: number;
        //       }
        //   }
        //   declare var graphics: {
        //       Point: new (x: number, y: number) => graphics.Point;
        //   }
        //   declare module "graphics" {
        //       export = graphics;
        //   }
        //
        // An 'import { Point } from "graphics"' needs to create a symbol that combines the value side 'Point'
        // property with the type/namespace side interface 'Point'.
        private ISymbol CombineValueAndTypeSymbols(ISymbol valueSymbol, ISymbol typeSymbol)
        {
            if ((valueSymbol.Flags & (SymbolFlags.Type | SymbolFlags.Namespace)) != SymbolFlags.None)
            {
                return valueSymbol;
            }

            var result = CreateSymbol(
                valueSymbol.Flags | typeSymbol.Flags,
                valueSymbol.Name,
                new SymbolData
                {
                    Declarations = valueSymbol.DeclarationList.Concat(typeSymbol.DeclarationList).ToList(),
                    Parent = valueSymbol.Parent ?? typeSymbol.Parent,
                    ValueDeclaration = valueSymbol.ValueDeclaration,
                    Members = typeSymbol.Members,
                    Exports = valueSymbol.Exports,
                });

            return result;
        }

        private ISymbol GetExportOfModule(ISymbol symbol, string name)
        {
            if ((symbol.Flags & SymbolFlags.Module) != SymbolFlags.None)
            {
                ISymbolTable exports = GetExportsOfSymbol(symbol);
                if (HasProperty(exports, name))
                {
                    return ResolveSymbol(exports[name]);
                }
            }

            return null;
        }

        private ISymbol GetPropertyOfVariable(ISymbol symbol, string name)
        {
            if ((symbol.Flags & SymbolFlags.Variable) != SymbolFlags.None)
            {
                var typeAnnotation = symbol.ValueDeclaration.Cast<IVariableDeclaration>().Type;
                if (typeAnnotation != null)
                {
                    return ResolveSymbol(GetPropertyOfType(GetTypeFromTypeNode(typeAnnotation), name));
                }
            }

            return null;
        }

        private ISymbol GetExternalModuleMember(/*HINT: IImportDeclaration | IExportDeclaration*/ INode node, IImportOrExportSpecifier specifier)
        {
            var moduleSpecifier = node.Kind == SyntaxKind.ImportDeclaration
                ? node.Cast<IImportDeclaration>().ModuleSpecifier
                : node.Cast<IExportDeclaration>().ModuleSpecifier;

            ISymbol moduleSymbol = ResolveExternalModuleName(node, moduleSpecifier);
            ISymbol targetSymbol = ResolveEsModuleSymbol(moduleSymbol, moduleSpecifier);

            if (targetSymbol != null)
            {
                var name = specifier.PropertyName ?? specifier.Name;

                if (!string.IsNullOrEmpty(name.Text))
                {
                    var symbolFromModule = GetExportOfModule(targetSymbol, name.Text);
                    var symbolFromVariable = GetPropertyOfVariable(targetSymbol, name.Text);
                    var symbol = (symbolFromModule != null) && (symbolFromVariable != null)
                        ? CombineValueAndTypeSymbols(symbolFromVariable, symbolFromModule)
                        : symbolFromModule ?? symbolFromVariable;

                    if (symbol == null)
                    {
                        Error(
                            name,
                            m_moduleTableInternals.ContainsKeyAtomic(name.Text) ?
                                Errors.Module_0_has_no_public_member_1 :
                                Errors.Module_0_has_no_exported_member_1,
                            GetFullyQualifiedName(moduleSymbol),
                            DeclarationNameToString(name));
                    }

                    // An import or export using a specifier always sets a dependency on the symbol coming
                    // from the external module, since we may need to type check the referencing spec
                    // and the symbol better be there
                    RecordFile2FileRelationships(node, symbol, ignoreSourceFileOrNamespace: false);

                    return symbol;
                }
            }

            return null;
        }

        private ISymbol GetTargetOfImportSpecifier(IImportSpecifier node)
        {
            return GetExternalModuleMember(/*<ImportDeclaration>*/node.Parent.Parent.Parent, node);
        }

        private ISymbol GetTargetOfExportSpecifier(IExportSpecifier node, bool resolveAliasRecursively)
        {
            return node.Parent.Parent.Cast<IExportDeclaration>().ModuleSpecifier != null
                ? GetExternalModuleMember(/*<ExportDeclaration>*/node.Parent.Parent, node)
                : ResolveEntityName(node.PropertyName ?? node.Name, SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace, resolveAliasRecursively: resolveAliasRecursively);
        }

        private ISymbol GetTargetOfExportAssignment(IExportAssignment node)
        {
            return ResolveEntityName(/*<Identifier>*/node.Expression, SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace);
        }

        [CanBeNull]
        private ISymbol GetTargetOfAliasDeclaration([CanBeNull]IDeclaration node, bool resolveAliasRecursively)
        {
            if (node == null)
            {
                return null;
            }

            switch (node.Kind)
            {
                case SyntaxKind.ImportEqualsDeclaration:
                    return GetTargetOfImportEqualsDeclaration(node.Cast<IImportEqualsDeclaration>());
                case SyntaxKind.ImportClause:
                    return GetTargetOfImportClause(node.Cast<IImportClause>());
                case SyntaxKind.NamespaceImport:
                    return GetTargetOfNamespaceImport(node.Cast<INamespaceImport>());
                case SyntaxKind.ImportSpecifier:
                    return GetTargetOfImportSpecifier(node.Cast<IImportSpecifier>());
                case SyntaxKind.ExportSpecifier:
                    return GetTargetOfExportSpecifier(node.Cast<IExportSpecifier>(), resolveAliasRecursively);
                case SyntaxKind.ExportAssignment:
                    return GetTargetOfExportAssignment(node.Cast<IExportAssignment>());
            }

            return null;
        }

        private ISymbol ResolveSymbol(ISymbol symbol)
        {
            return (symbol != null) &&
                   (symbol.Flags & SymbolFlags.Alias) != SymbolFlags.None &&
                   (symbol.Flags & (SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace)) == SymbolFlags.None
                ? ResolveAlias(symbol)
                : symbol;
        }

        private enum AliasResolutionState : byte
        {
            Resolving,
            Cycle,
        }

        [NotNull]
        private ISymbol ResolveAlias([NotNull]ISymbol symbol, bool resolveAliasRecursively = true)
        {
            Contract.Ensures(Contract.Result<ISymbol>() != null);
            Contract.Assert((symbol.Flags & SymbolFlags.Alias) != SymbolFlags.None, "Should only get Alias here.");

            // Current implementation is relying on a thread local "custom stack" for cycle detection.
            // This could (potentially) cause performance issues.
            // If this will happen, the implementation should be changed to more efficient one
            // (few ideas: ConcurrentDictionary<ManagedThreadId, Dictionary>, using links.Target to
            // keep the resolution state between invocations).

            // The alias resolution can be done recursively or not. Each case is cached in a different member
            // of the symbol links for future retrieval (Target for the recursive one, which is the original
            // checker behavior, and DirectTarget for the non-recursive one)
            if (resolveAliasRecursively)
            {
                return GetSymbolLinks(symbol).GetOrSetTarget(
                    (checker: this, symbol),
                    (links, tpl) => { return GetTargetOfAlias(tpl, links, resolveAliasRecursively: true); });
            }
            else
            {
                // TODO: when resolving recursively, we could populate the direct targets as well
                return GetSymbolLinks(symbol).GetOrSetDirectTarget(
                    (checker: this, symbol),
                    (links, tpl) => { return GetTargetOfAlias(tpl, links, resolveAliasRecursively: false); });
            }
        }

        private static ISymbol GetTargetOfAlias((Checker checker, ISymbol symbol) tpl, ISymbolLinks links, bool resolveAliasRecursively)
        {
            
            if (tpl.checker.m_targetResolutionSet.Value.ContainsKey(links))
            {
                tpl.checker.m_targetResolutionSet.Value[links] = AliasResolutionState.Cycle;
                return tpl.checker.m_unknownSymbol;
            }

            try
            {
                tpl.checker.m_targetResolutionSet.Value.Add(links, AliasResolutionState.Resolving);

                var declaration = GetDeclarationOfAliasSymbol(tpl.symbol);
                var target = tpl.checker.GetTargetOfAliasDeclaration(declaration, resolveAliasRecursively);

                if (tpl.checker.m_targetResolutionSet.Value[links] == AliasResolutionState.Resolving)
                {
                    return target ?? tpl.checker.m_unknownSymbol;
                }

                tpl.checker.Error(declaration, Errors.Circular_definition_of_import_alias_0, tpl.checker.SymbolToString(tpl.symbol));

                return tpl.checker.m_unknownSymbol;
            }
            finally
            {
                tpl.checker.m_targetResolutionSet.Value.Remove(links);
            }
        }

        private void MarkExportAsReferenced([NotNull] /*ImportEqualsDeclaration | ExportAssignment | ExportSpecifier*/ INode node)
        {
            ISymbol symbol = GetSymbolOfNode(node);
            var target = ResolveAlias(symbol);
            if (target != null)
            {
                var markAlias =
                (target == m_unknownSymbol && m_compilerOptions.IsolatedModules.HasValue && m_compilerOptions.IsolatedModules.Value) ||
                (target != m_unknownSymbol && (target.Flags & SymbolFlags.Value) != SymbolFlags.None && !IsConstEnumOrConstEnumOnlyModule(target));

                if (markAlias)
                {
                    MarkAliasSymbolAsReferenced(symbol);
                }
            }
        }

        // When an alias symbol is referenced, we need to mark the entity it references as referenced and in turn repeat that until
        // we reach a non-alias or an exported entity (which is always considered referenced). We do this by checking the target of
        // the alias as an expression (which recursively takes us back here if the target references another alias).
        private void MarkAliasSymbolAsReferenced([NotNull]ISymbol symbol)
        {
            // Using thread-local cache to avoid stack overflow
            if (m_setReferenceSymbolResolutionCache.Value.Contains(symbol))
            {
                return;
            }

            GetSymbolLinks(symbol).GetOrSetReferenced(
               (checker: this, symbol),
                (links, tuple) =>
                {
                    var @this = tuple.checker;
                    var capturedSsymbol = tuple.symbol;

                    // Original implementation mutated the links at the beginning of the call back
                    // to avoid infinite recursion.
                    // To make solution thread-safe, new implementation relies on a thread-local state.
                    @this.m_setReferenceSymbolResolutionCache.Value.Add(capturedSsymbol);

                    try
                    {
                        var node = GetDeclarationOfAliasSymbol(capturedSsymbol);
                        Contract.Assert(node != null, "node != null");

                        if (node.Kind == SyntaxKind.ExportAssignment)
                        {
                            // export default <symbol>
                            @this.CheckExpressionCached(node.Cast<IExportAssignment>().Expression);
                        }
                        else if (node.Kind == SyntaxKind.ExportSpecifier)
                        {
                            // export { < symbol > } or export { < symbol > as foo }
                            @this.CheckExpressionCached(node.Cast<IExportSpecifier>().PropertyName ?? node.Cast<IExportSpecifier>().Name);
                        }
                        else if (IsInternalModuleImportEqualsDeclaration(node))
                        {
                            // import foo = <symbol>
                            @this.CheckExpressionCached(node.Cast<IImportEqualsDeclaration>().ModuleReference.Cast<IExpression>());
                        }

                        return true;
                    }
                    finally
                    {
                        @this.m_setReferenceSymbolResolutionCache.Value.Remove(capturedSsymbol);
                    }
                });
        }

        // TODO: Does this function need to change for DScript imports?
        // This function is only for imports with entity names
        [CanBeNull]
        private ISymbol GetSymbolOfPartOfRightHandSideOfImportEquals([NotNull]INode entityName, IImportEqualsDeclaration importDeclaration = null)
        {
            if (importDeclaration == null)
            {
                importDeclaration = GetAncestor(entityName, SyntaxKind.ImportEqualsDeclaration)?.Cast<ImportEqualsDeclaration>();
                Contract.Assert(importDeclaration != null);
            }

            // There are three things we might try to look for. In the following examples,
            // the search term is enclosed in |...|:
            //
            //     import a = |b|; // Namespace
            //     import a = |b.c|; // Value, type, namespace
            //     import a = |b.c|.d; // Namespace
            if (entityName.Kind == SyntaxKind.Identifier && IsRightSideOfQualifiedNameOrPropertyAccess(entityName))
            {
                entityName = entityName.Parent.Cast<IQualifiedName>();
            }

            // Check for case 1 and 3 in the above example
            if (entityName.Kind == SyntaxKind.Identifier || entityName.Parent.Kind == SyntaxKind.QualifiedName)
            {
                return ResolveEntityName(entityName, SymbolFlags.Namespace);
            }
            else
            {
                // Case 2 in above example
                // entityName.Kind could be a QualifiedName or a Missing identifier
                Contract.Assert(entityName.Parent.Kind == SyntaxKind.ImportEqualsDeclaration);
                return ResolveEntityName(entityName, SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace);
            }
        }

        /// <summary>
        /// Returns fully qualified name of the <paramref name="symbol"/>.
        /// </summary>
        public string GetFullyQualifiedName([NotNull]ISymbol symbol)
        {
            // This is DS specific change in behavior.
            // Original TS implementation will provide a filePath as a prefix for a fully-qualified name.
            // DS implementation doesn't prints a fileName.

            // This could be changed back if new behavior will lead to some issues.
            return IsNullOrSourceFile(symbol.Parent) ? SymbolToString(symbol) : I($"{GetFullyQualifiedName(symbol.Parent)}.{SymbolToString(symbol)}");
        }

        private static bool IsNullOrSourceFile(ISymbol symbol)
        {
            if (symbol == null)
            {
                return true;
            }

            var declaration = symbol.DeclarationList.FirstOrDefault();
            if (declaration?.Kind == SyntaxKind.SourceFile)
            {
                return true;
            }

            return false;
        }

        /// <nodoc />
        public ISymbol ResolveEntryByName(INode currentNode, string name, SymbolFlags blockScopedVariable)
        {
            return ResolveName(currentNode, name, blockScopedVariable, null, name);
        }

        // Resolves a qualified name and any involved aliases
        [CanBeNull]
        private ISymbol ResolveEntityName(/*HINT: EntityName | Expression*/ INode name, SymbolFlags meaning, bool ignoreErrors = false, bool resolveAliasRecursively = true)
        {
            if (NodeIsMissing(name))
            {
                return null;
            }

            ISymbol symbol = null;
            if (name.Kind == SyntaxKind.Identifier)
            {
                var message = meaning == SymbolFlags.Namespace
                    ? Errors.Cannot_find_namespace_0
                    : Errors.Cannot_find_name_0;

                symbol = ResolveName(name, name.Cast<IIdentifier>().Text, meaning, ignoreErrors ? null : message, name.Cast<IIdentifier>());
                if (symbol == null)
                {
                    return null;
                }
            }
            else if (name.Kind == SyntaxKind.QualifiedName || name.Kind == SyntaxKind.PropertyAccessExpression)
            {
                var left = name.Kind == SyntaxKind.QualifiedName
                    ? name.Cast<IQualifiedName>().Left
                    : name.Cast<IPropertyAccessExpression>().Expression;

                var right = name.Kind == SyntaxKind.QualifiedName
                    ? name.Cast<IQualifiedName>().Right
                    : name.Cast<IPropertyAccessExpression>().Name;

                var @namespace = ResolveEntityName(left, SymbolFlags.Namespace, ignoreErrors);
                if (@namespace == null || @namespace == m_unknownSymbol || NodeIsMissing(right))
                {
                    return null;
                }

                symbol = GetSymbol(
                    GetExportsOfSymbol(@namespace),
                    right.Text,
                    meaning);
                if (symbol == null)
                {
                    if (!ignoreErrors)
                    {
                        Error(
                            right,
                            Errors.Module_0_has_no_exported_member_1,
                            GetFullyQualifiedName(@namespace),
                            DeclarationNameToString(right));
                    }

                    return null;
                }
            }
            else
            {
                Contract.Assert(false, I($"Unknown entity name kind {name.Kind}."));
            }

            Contract.Assert((symbol.Flags & SymbolFlags.Instantiated) == SymbolFlags.None, "Should never get an instantiated symbol here.");
            return (symbol.Flags & meaning) != SymbolFlags.None || !resolveAliasRecursively ? symbol : ResolveAlias(symbol);
        }

        /// <inheritdoc/>
        public string TryGetResolvedModulePath(ISourceFile sourceFile, string moduleName, HashSet<ISourceFile> filteredSpecs)
        {
            // Not using GetOrAdd to avoid closure allocation.
            if (m_resolvedModulePathMap.TryGetValue(moduleName, out var result))
            {
                return result;
            }

            result = DoTryGetResolvedModulePath(sourceFile, moduleName, filteredSpecs);
            m_resolvedModulePathMap[moduleName] = result;
            return result;
        }

        private string DoTryGetResolvedModulePath(ISourceFile sourceFile, string moduleName, HashSet<ISourceFile> filteredSpecs)
        {
            // This module has the following informal postcondition:
            // It should never return a path to a file that was filtered out.
            ISymbolTable moduleInternalSymbolTable;
            if (m_moduleTableInternals.TryGetValueAtomic(moduleName, out moduleInternalSymbolTable))
            {
                // We need to pick a file from the module 'moduleName'.
                // To make this logic deterministic, we'll look for a file name in module 'moduleName' that contains a top-level qualifier declaration.
                // Each module have a top-level qualifier declaration (implicit or explicit) and this declaration can't be filtered out.
                var qualifierSymbol = moduleInternalSymbolTable[Names.CurrentQualifier];
                Contract.Assert(qualifierSymbol != null, "Every V2 module should contain explicit or implicit top level qualifier declaration.");

                // The file that declares qualifier may be filtered out.
                // This is legitimately possible only in one case: when the import alias is never used in the file.
                // In this case the result will be null.
                var qualifierDeclaration = (INode)qualifierSymbol.DeclarationList.FirstOrDefault(d => filteredSpecs == null || !filteredSpecs.Contains(d.GetSourceFile()));
                return qualifierDeclaration?.GetSourceFile().Path.AbsolutePath;
            }

            var resolvedModule = SourceFileExtensions.GetResolvedModule(sourceFile, moduleName);

            if (resolvedModule != null)
            {
                var resolvedFile = m_host.GetSourceFile(resolvedModule.ResolvedFileName);

                // Making sure that the target spec was not filtered out.
                if (resolvedFile != null && (filteredSpecs == null || !filteredSpecs.Contains(resolvedFile)))
                {
                    return resolvedFile.Path.AbsolutePath;
                }
            }

            return null;
        }

        private ISymbol ResolveExternalModuleName(INode location, IExpression moduleReferenceExpression)
        {
            if (moduleReferenceExpression.Kind != SyntaxKind.StringLiteral)
            {
                return null;
            }

            var moduleReferenceLiteral = moduleReferenceExpression.Cast<ILiteralExpression>();

            // Module names are escaped in our symbol table.  However, string literal values aren't.
            // Escape the name in the "importFrom(...)" clause to ensure we find the right symbol.
            var moduleName = EscapeIdentifier(moduleReferenceLiteral.Text);

            if (moduleName == null)
            {
                return null;
            }

            var isRelative = IsExternalModuleNameRelative(moduleName);
            if (!isRelative)
            {
                var symbol = GetSymbol(m_globals, string.Concat("\"", moduleName, "\""), SymbolFlags.ValueModule);
                if (symbol != null)
                {
                    return symbol;
                }
            }

            // Tracking file to module dependencies
            var currentSourceFile = (SourceFile)GetSourceFile(location);
            if (currentSourceFile != null)
            {
                AddUpStreamModuleDependency(moduleName, currentSourceFile);
            }

            // DScript-specific. If the referenced module is an implicit project reference module, the main file doesn't apply
            // and the symbol has to be computed based on the module public values.
            ISymbolTable moduleInternalSymbolTable;
            if (m_moduleTableInternals.TryGetValueAtomic(moduleReferenceLiteral.Text, out moduleInternalSymbolTable))
            {
                var resultingSymbol = ResolveScriptPublicModuleName(moduleReferenceLiteral.Text, moduleInternalSymbolTable);
                return resultingSymbol;
            }

            var resolvedModule = SourceFileExtensions.GetResolvedModule(currentSourceFile, moduleReferenceLiteral.Text);

            // This is the case of modules with explicit references, so what follows is the regular TS treatment
            ISourceFile sourceFile = resolvedModule != null ? m_host.GetSourceFile(resolvedModule.ResolvedFileName) : null;
            if (sourceFile != null)
            {
                if (sourceFile.Symbol != null)
                {
                    // The symbol represents a main package used by V1 module.
                    // We need to add a dependency to the main file here to avoid
                    // a failure at runtime if there is no explicit references to a symbols from the main file.
                    // Here is an example why it is needed:
                    //
                    // Sdk.Transformers package:
                    // Cmd.dsc:
                    // export namespace Cmd {export const x = 42;}
                    // package.dsc:
                    // export {Cmd};
                    //
                    // Bond.dsc
                    // import {Cmd} from "Sdk.Transformers";
                    // Need to specify ignoreSourceFileOrNamespace as false because the resolved symbol is a file
                    // but in this case we don't want to ignore it.
                    RecordFile2FileRelationships(location, sourceFile.Symbol, ignoreSourceFileOrNamespace: false);
                    return sourceFile.Symbol;
                }

                Error(moduleReferenceLiteral, Errors.File_0_is_not_a_module, sourceFile.FileName);
                return null;
            }

            Error(moduleReferenceLiteral, Errors.Cannot_find_module_0, moduleName);
            return null;
        }

        private static void AddUpStreamModuleDependency(string targetModuleName, SourceFile currentSourceFile)
        {
            if (targetModuleName == null)
            {
                return;
            }

            currentSourceFile.AddModuleDependency(targetModuleName);
        }

        private ISymbol ResolveScriptPublicModuleName(string moduleName, ISymbolTable moduleInternalSymbolTable)
        {
            ISymbol exportSymbol = m_moduleExports.GetOrAdd(moduleName, key =>
            {
                // TODO: do we need to consider the case where a module just contains const enums?

                // The exports of the export symbol are the public symbols of the internal module table (for that module)
                // So we just clone the table excluding the symbols that are not public.
                var exports = FilterNonPublicNamespaceMembers(moduleInternalSymbolTable);

                Contract.Assert(exports != null);

                // We create a symbol that looks like a module and only has the symbols flagged with @@public
                var result = CreateSymbol(
                    SymbolFlags.ValueModule,
                    moduleName,
                    new SymbolData
                    {
                        ConstEnumOnlyModule = false,
                        Exports = exports,
                        Declarations = GetAggregatedSourceFileDeclarations(exports),
                    },
                    isBuildXLModule: true);

                return result;
            });

            return exportSymbol;
        }

        private ISymbol GetInternalModuleSymbol(string moduleName)
        {
            ISymbol moduleSymbol = m_moduleInternals.GetOrAddWithState(
                (checker: this, moduleName),
                moduleName,
                (tpl, key) =>
                {
                    var @this = tpl.checker;
                    var capturedModuleName = tpl.moduleName;

                    // We know that targetModuleName represents a module with implicit semantics, so the internal
                    // table is already populated
                    var internalsTable = @this.m_moduleTableInternals[capturedModuleName];
                    var declarations = GetAggregatedSourceFileDeclarations(internalsTable);

                    // We create a symbol that represents all internal values of a module
                    var result = @this.CreateSymbol(
                        SymbolFlags.ValueModule,
                        capturedModuleName,
                        new SymbolData
                        {
                            ConstEnumOnlyModule = false,
                            Declarations = declarations,
                            Exports = internalsTable,
                            ValueDeclaration = declarations.FirstOrDefault(),
                        },
                        isBuildXLModule: true);

                    return result;
                });

            return moduleSymbol;
        }

        private static List<IDeclaration> GetAggregatedSourceFileDeclarations(ISymbolTable symbolTable)
        {
            // It is important to define the list of declarations as a collection of source files
            // This mimics what happens on a real source file. Ast conversion checks for the source file
            // kind when generating a location based symbol reference and sets a special position for the whole file
            var declarations = new HashSet<IDeclaration>();
            foreach (var kvp in symbolTable)
            {
                var symbol = kvp.Value;

                // This could be retrieving an injected node, but that's fine. We rely on this behavior for the case
                // where there are no real exported declarations, since 'withQualifier' is always exported. This
                // guarantees that there is at least one declaration (and therefore one source file path to be extracted later)
                var declaration = symbol.DeclarationList.FirstOrDefault();
                if (declaration != null)
                {
                    var sourceFile = declaration.GetSourceFile();
                    declarations.Add(sourceFile);
                }
            }

            return declarations.ToList();
        }

        // An external module with an 'export =' declaration resolves to the target of the 'export =' declaration,
        // and an external module with no 'export =' declaration resolves to the module itself.
        private ISymbol ResolveExternalModuleSymbol(ISymbol moduleSymbol)
        {
            ISymbol result = null;
            if (moduleSymbol != null)
            {
                result = ResolveSymbol(moduleSymbol.Exports["export="]);
            }

            result = result ?? moduleSymbol;
            return result;
        }

        // An external module with an 'export =' declaration may be referenced as an ES6 module provided the 'export ='
        // references a symbol that is at least declared as a module or a variable. The target of the 'export =' may
        // combine other declarations with the module or variable (e.g. a class/module, function/module, interface/variable).
        private ISymbol ResolveEsModuleSymbol(ISymbol moduleSymbol, IExpression moduleReferenceExpression)
        {
            var symbol = ResolveExternalModuleSymbol(moduleSymbol);
            if ((symbol != null) &&
                (symbol.Flags & (SymbolFlags.Module | SymbolFlags.Variable)) == SymbolFlags.None)
            {
                Error(
                    moduleReferenceExpression,
                    Errors.Module_0_resolves_to_a_non_module_entity_and_cannot_be_imported_using_this_construct,
                    SymbolToString(moduleSymbol));

                symbol = null;
            }

            return symbol;
        }

        private static ISymbol GetExportAssignmentSymbol(ISymbol moduleSymbol)
        {
            return moduleSymbol.Exports["export="];
        }

        /// <nodoc />
        public IReadOnlyList<ISymbol> GetExportsOfModuleAsArray(ISymbol moduleSymbol)
        {
            return SymbolsToArray(GetExportsOfModule(moduleSymbol));
        }

        private ISymbolTable GetExportsOfSymbol(ISymbol symbol)
        {
            return (symbol.Flags & SymbolFlags.Module) != SymbolFlags.None
                ? GetExportsOfModule(symbol)
                : (symbol.Exports ?? s_emptySymbols);
        }

        /// <inheritdoc/>
        public ISymbol GetAliasedSymbol(ISymbol symbol, bool resolveAliasRecursively = true)
        {
            return ResolveAlias(symbol, resolveAliasRecursively);
        }

        /// <inheritdoc/>
        public ISymbolTable GetExportsOfModule(ISymbol moduleSymbol)
        {
            return GetSymbolLinks(moduleSymbol).GetOrSetResolvedExports((checker: this, moduleSymbol), (links, tuple) =>
            {
                return tuple.checker.GetExportsForModule(tuple.moduleSymbol);
            });
        }

        internal struct ExportCollisionTracker
        {
            private ExportCollisionTracker(List<IExportDeclaration> duplicates)
            {
                ExportsWithDuplicate = duplicates;
                SpecifierText = null;
            }

            public static ExportCollisionTracker Create()
            {
                return new ExportCollisionTracker(new List<IExportDeclaration>());
            }

            public List<IExportDeclaration> ExportsWithDuplicate { get; }

            public string SpecifierText { get; set; }
        }

        /// <summary>
        /// Extends one symbol table with another while collecting information on name collisions for error message generation into the `lookupTable` argument
        /// Not passing `lookupTable` and `exportNode` disables this collection, and just extends the tables
        /// </summary>
        private void ExtendExportSymbols(ISymbolTable target, ISymbolTable source, Map<ExportCollisionTracker> lookupTable = null,
            IExportDeclaration exportNode = null)
        {
            if (source == null)
            {
                // Nothing to do here
                return;
            }

            foreach (var kvp in source)
            {
                var id = kvp.Key;
                var symbol = kvp.Value;
                if (!id.Equals("default") && !HasProperty(target, id))
                {
                    target[id] = symbol;
                    if (lookupTable != null && exportNode != null)
                    {
                        var collisionTracker = ExportCollisionTracker.Create();
                        collisionTracker.SpecifierText = GetTextOfNode(exportNode.ModuleSpecifier);

                        lookupTable[id] = collisionTracker;
                    }
                }
                else if (lookupTable != null && exportNode != null && !id.Equals("default") && HasProperty(target, id) &&
                         ResolveSymbol(target[id]) != ResolveSymbol(source[id]))
                {
                    lookupTable[id].ExportsWithDuplicate.Add(exportNode);
                }
            }
        }

        // TODO: Verify equivalence with typescript implementation
        private ISymbolTable GetExportsForModule(ISymbol moduleSymbol)
        {
            List<ISymbol> visitedSymbols = new List<ISymbol>();
            return Visit(moduleSymbol, visitedSymbols) ?? moduleSymbol.Exports;
        }

        // The ES6 spec permits export * declarations in a module to circularly reference the module itself. For example,
        // module 'a' can 'export * from "b"' and 'b' can 'export * from "a"' without error.
        private ISymbolTable Visit(ISymbol symbol, List<ISymbol> visitedSymbols)
        {
            if (!(symbol != null && (symbol.Flags & SymbolFlags.HasExports) != SymbolFlags.None && !visitedSymbols.Contains(symbol)))
            {
                return null;
            }

            visitedSymbols.Add(symbol);

            var symbols = CloneSymbolTable(symbol.Exports);

            // All export * declarations are collected in an __export symbol by the binder
            var exportStars = symbol.Exports["__export"];
            if (exportStars != null)
            {
                ISymbolTable nestedSymbols = new SymbolTable();
                var lookupTable = new Map<ExportCollisionTracker>();

                foreach (var node in exportStars.DeclarationList)
                {
                    var resolvedModule = ResolveExternalModuleName(node, node.As<IExportDeclaration>()?.ModuleSpecifier);
                    var exportedSymbols = Visit(resolvedModule, visitedSymbols);
                    ExtendExportSymbols(
                        nestedSymbols,
                        exportedSymbols,
                        lookupTable,
                        node.As<IExportDeclaration>());
                }

                foreach (var id in lookupTable.Keys)
                {
                    // TODO: Verify equivalence - const { exportsWithDuplicate } = lookupTable[id];
                    var collisionTracker = lookupTable[id];

                    // It's not an error if the file with multiple `export *`s with duplicate names exports a member with that name itself
                    if (id.Equals("export=") ||
                        !(collisionTracker.ExportsWithDuplicate?.Count > 0) ||
                        HasProperty(symbols, id))
                    {
                        continue;
                    }

                    foreach (var node in collisionTracker.ExportsWithDuplicate)
                    {
                        m_diagnostics.Add(
                            Diagnostic.CreateDiagnosticForNode(node, Errors.Module_0_has_already_exported_a_member_named_1_Consider_explicitly_re_exporting_to_resolve_the_ambiguity, lookupTable[id].SpecifierText, id));
                    }
                }

                ExtendExportSymbols(symbols, nestedSymbols);
            }

            return symbols;
        }

        [CanBeNull]
        private ISymbol GetMergedSymbol([CanBeNull]ISymbol symbol)
        {
            var mergeId = symbol != null ? GetMergeId(symbol) : 0;
            return m_mergedSymbols.GetOrDefaultAtomic(mergeId) ?? symbol;
        }

        [CanBeNull]
        private ISymbol GetSymbolOfNode([NotNull]INode node)
        {
            return GetMergedSymbol(node.Symbol);
        }

        [CanBeNull]
        private ISymbol GetParentOfSymbol([NotNull]ISymbol symbol)
        {
            return GetMergedSymbol(symbol.Parent);
        }

        [CanBeNull]
        private ISymbol GetExportSymbolOfValueSymbolIfExported([CanBeNull]ISymbol symbol)
        {
            return (symbol != null) && (symbol.Flags & SymbolFlags.ExportValue) != SymbolFlags.None
                ? GetMergedSymbol(symbol.ExportSymbol)
                : symbol;
        }

        private bool SymbolIsValue([NotNull]ISymbol symbol)
        {
            // If it is an instantiated symbol, then it is a value if the symbol it is an
            // instantiation of is a value.
            if ((symbol.Flags & SymbolFlags.Instantiated) != SymbolFlags.None)
            {
                return SymbolIsValue(GetSymbolLinks(symbol).Target);
            }

            // If the symbol has the value flag, it is trivially a value.
            if ((symbol.Flags & SymbolFlags.Value) != SymbolFlags.None)
            {
                return true;
            }

            // If it is an alias, then it is a value if the symbol it resolves to is a value.
            if ((symbol.Flags & SymbolFlags.Alias) != SymbolFlags.None)
            {
                return (ResolveAlias(symbol).Flags & SymbolFlags.Value) != SymbolFlags.None;
            }

            return false;
        }

        private static IConstructorDeclaration FindConstructorDeclaration(IClassLikeDeclaration node)
        {
            var members = node.Members;
            foreach (var member in members)
            {
                if (member.Kind == SyntaxKind.Constructor && NodeIsPresent(member.Cast<IConstructorDeclaration>().Body))
                {
                    return member.Cast<IConstructorDeclaration>();
                }
            }

            return null;
        }

        private TType CreateType<TType>(TypeFlags flags, ISymbol symbol = null) where TType : IType, new()
        {
            return TypeAllocator.CreateType<TType>(this, flags, symbol);
        }

        private IIntrinsicType CreateIntrinsicType(TypeFlags kind, string intrinsicName)
        {
            var type = CreateType<IntrinsicType>(kind);
            type.IntrinsicName = intrinsicName;
            return type;
        }

        private TObjectType CreateObjectType<TObjectType>(TypeFlags kind, ISymbol symbol = null) where TObjectType : IObjectType, new()
        {
            return TypeAllocator.CreateObjectType<TObjectType>(this, kind, symbol);
        }

        private GenericType CreateGenericType(TypeFlags kind, ISymbol symbol, List<ITypeParameter> outerTypeParameters, List<ITypeParameter> localTypeParameters)
        {
            GenericType type = CreateObjectType<GenericType>(kind, symbol);

            type.Flags |= TypeFlags.Reference;
            type.TypeParameters = outerTypeParameters.Concatenate(localTypeParameters);
            type.OuterTypeParameters = outerTypeParameters;
            type.LocalTypeParameters = localTypeParameters;

            type.Instantiations[GetTypeListId(type.TypeParameters)] = type;
            type.Target = type;
            type.TypeArguments = type.TypeParameters?.ToList();

            type.ThisType = CreateType<TypeParameter>(TypeFlags.TypeParameter | TypeFlags.ThisType, symbol);
            type.ThisType.Constraint = type;

            return type;
        }

        // A reserved member name starts with two underscores, but the third character cannot be an underscore
        // or the @ symbol. A third underscore indicates an escaped form of an identifer that started
        // with at least two underscores. The @ character indicates that the name is denoted by a well known ES
        // Symbol instance.
        private static bool IsReservedMemberName(string name)
        {
            return (name.CharCodeAt(0) == Scanning.CharacterCodes._) &&
                   (name.CharCodeAt(1) == Scanning.CharacterCodes._) &&
                   (name.CharCodeAt(2) != Scanning.CharacterCodes._) &&
                   (name.CharCodeAt(2) != Scanning.CharacterCodes.At);
        }

        private IReadOnlyList<ISymbol> GetNamedMembers(ISymbolTable members)
        {
            List<ISymbol> result = null;
            foreach (var kvp in members)
            {
                var id = kvp.Key;
                ISymbol symbol = kvp.Value;
                if (!IsReservedMemberName(id))
                {
                    if (SymbolIsValue(symbol))
                    {
                        result = result ?? new List<ISymbol>(members.Count);
                        result.Add(symbol);
                    }
                }
            }

            return (IReadOnlyList<ISymbol>)result ?? EmptyArray<ISymbol>();
        }

        // TODO: most likely this method should change actual type (i.e., CLR type) of type argument and should create ResolvedType instead!
        private IResolvedType SetObjectTypeMembers(
            IObjectType type, ISymbolTable members, IEnumerable<ISignature> callSignatures, IEnumerable<ISignature> constructSignatures,
            IType stringIndexType, IType numberIndexType)
        {
            var resolvedData = new ResolvedTypeData()
            {
                Members = members,
                Properties = GetNamedMembers(members),

                // Still not sure about correctness, because typescript implementation assigns references, that could cause cascade changes!
                CallSignatures = new List<ISignature>(callSignatures ?? Enumerable.Empty<ISignature>()), // TODO: Verify correctness
                ConstructSignatures = new List<ISignature>(constructSignatures ?? Enumerable.Empty<ISignature>()),
                StringIndexType = stringIndexType,
                NumberIndexType = numberIndexType,
            };

            return type.Resolve(resolvedData);
        }

        private IResolvedType CreateAnonymousType(ISymbol symbol, ISymbolTable members, IEnumerable<ISignature> callSignatures,
            IEnumerable<ISignature> constructSignatures, IType stringIndexType, IType numberIndexType)
        {
            return SetObjectTypeMembers(
                CreateObjectType<ResolvedType>(TypeFlags.Anonymous, symbol),
                members,
                callSignatures,
                constructSignatures,
                stringIndexType,
                numberIndexType);
        }

        /// <summary>
        /// Invokes the given callback for each symbol table in the scope of the enclosing declaration
        /// </summary>
        /// <remarks>
        /// The callback can signal de iteration to stop by returning default(T). This is a slight divergence
        /// from the original TypeScript implementation due to falsy vs value type differences
        /// </remarks>
        private T ForEachSymbolTableInScope<T>(INode enclosingDeclaration, Func<ISymbolTable, T> callback)
        {
            T result = default(T);
            var equalityComparer = EqualityComparer<T>.Default;

            for (var location = enclosingDeclaration; location != null; location = location.Parent)
            {
                // Locals of a source file are not in scope (because they get merged into the global symbol table)
                if (location.Locals != null && !IsGlobalSourceFile(location))
                {
                    result = callback(location.Locals);
                    if (!equalityComparer.Equals(result, default(T)))
                    {
                        return result;
                    }
                }

                switch (location.Kind)
                {
                    case SyntaxKind.SourceFile:
                        if (!SourceFileExtensions.IsExternalOrCommonJsModule(location.Cast<ISourceFile>()))
                        {
                            break;
                        }

                        result = callback(GetModuleExportsOfSymbol(location, GetSymbolOfNode(location)));
                        if (!equalityComparer.Equals(result, default(T)))
                        {
                            return result;
                        }

                        break;
                    case SyntaxKind.ModuleDeclaration:
                        result = callback(GetSymbolOfNode(location).Exports);
                        if (!equalityComparer.Equals(result, default(T)))
                        {
                            return result;
                        }

                        break;
                    case SyntaxKind.ClassDeclaration:
                    case SyntaxKind.InterfaceDeclaration:
                        result = callback(GetSymbolOfNode(location).Members);
                        if (!equalityComparer.Equals(result, default(T)))
                        {
                            return result;
                        }

                        break;
                }
            }

            return callback(m_globals);
        }

        private ISymbolTable GetInternalSymbolsForFile(ISourceFile sourceFile)
        {
            ISymbolTable internalsForFile;

            var pathToFile = sourceFile.Path.AbsolutePath;
            if (m_internalsPerFile.TryGetValue(pathToFile, out internalsForFile))
            {
                return internalsForFile;
            }

            // If this is a V1 module, there are no internal symbols
            if (!m_host.IsOwnedByImplicitReferenceModule(pathToFile))
            {
                return null;
            }

            ModuleName moduleName;
            var success = m_host.TryGetOwningModule(pathToFile, out moduleName);
            Contract.Assert(success);

            // Get all internal symbols but filter out the export specifiers from the given source file
            // This is because what the current file exports is *not* in scope for the current file
            var allInternalSymbols = m_moduleTableInternals[moduleName.Name];
            internalsForFile = CloneSymbolTable(
                allInternalSymbols,
                symbol =>
                {
                    var declaration = symbol.GetFirstDeclarationOrDefault();
                    if (declaration != null)
                    {
                        return declaration.Kind == SyntaxKind.ExportSpecifier && declaration.GetSourceFile() == sourceFile;
                    }
                    return false;
                });

            m_internalsPerFile.TryAdd(pathToFile, internalsForFile);

            return internalsForFile;
        }

        private static SymbolFlags GetQualifiedLeftMeaning(SymbolFlags rightMeaning)
        {
            // If we are looking in value space, the parent meaning is value, other wise it is namespace
            return rightMeaning == SymbolFlags.Value ? SymbolFlags.Value : SymbolFlags.Namespace;
        }

        private List<ISymbol> GetAccessibleSymbolChain(ISymbol symbol, INode enclosingDeclaration, SymbolFlags meaning, bool useOnlyExternalAliasing)
        {
            if (symbol != null)
            {
                return ForEachSymbolTableInScope(enclosingDeclaration, st => GetAccessibleSymbolChainFromSymbolTable(st));
            }

            return null;

            bool CanQualifySymbol(ISymbol symbolFromSymbolTable, SymbolFlags meaningLocal)
            {
                // If the symbol is equivalent and doesn't need further qualification, this symbol is accessible
                if (!NeedsQualification(symbolFromSymbolTable, enclosingDeclaration, meaningLocal))
                {
                    return true;
                }

                // If symbol needs qualification, make sure that parent is accessible, if it is then this symbol is accessible too
                var accessibleParent = GetAccessibleSymbolChain(
                    symbolFromSymbolTable.Parent,
                    enclosingDeclaration,
                    GetQualifiedLeftMeaning(meaningLocal),
                    useOnlyExternalAliasing);

                return accessibleParent != null;
            }

            bool IsAccessible(ISymbol symbolFromSymbolTable, ISymbol resolvedAliasSymbol)
            {
                // Since the symbol can be a cloned public namespace, we need to make sure the reference equality is performed on the original symbols
                if (symbol?.GetOriginalSymbolOrSelf() == (resolvedAliasSymbol ?? symbolFromSymbolTable)?.GetOriginalSymbolOrSelf())
                {
                    // if the symbolFromSymbolTable is not external module (it could be if it was determined as ambient external module and would be in globals table)
                    // and if symbolfrom symbolTable or alias resolution matches the symbol,
                    // check the symbol can be qualified, it is only then this symbol is accessible
                    return !symbolFromSymbolTable.DeclarationList.Any(d => HasExternalModuleSymbol(d)) &&
                           CanQualifySymbol(symbolFromSymbolTable, meaning);
                }

                return false;
            }

            List<ISymbol> GetAccessibleSymbolChainFromSymbolTable(ISymbolTable symbols)
            {
                // If symbol is directly available by its name in the symbol table
                if (IsAccessible(symbols[symbol.Name], null))
                {
                    return new List<ISymbol> { symbol };
                }

                // Check if symbol is any of the alias
                // TODO: Verify equivalence - return forEachValue(symbols, symbolFromSymbolTable => ...);
                foreach (var kvp in symbols)
                {
                    string key = kvp.Key;
                    var symbolFromSymbolTable = kvp.Value;

                    if ((symbolFromSymbolTable.Flags & SymbolFlags.Alias) != SymbolFlags.None &&
                        !symbolFromSymbolTable.Name.Equals("export=") &&

                        // In the V1 case, export specifiers never introduce names to the scope. However,
                        // for V2, export specifiers in other files in the same module do. In the V2 case,
                        // export specifiers from the same file were already filtered out when constructing 'symbols', so
                        // we just need to check if the file owning the declaration is part of a V2 module
                        !IsExportSpecifierInExplicitModuleReference(enclosingDeclaration, symbolFromSymbolTable))
                    {
                        if (!useOnlyExternalAliasing ||

                            // We can use any type of alias to get the name
                            // Is this external alias, then use it to name
                            symbolFromSymbolTable.DeclarationList.Any(
                                c => { return IsExternalModuleImportEqualsDeclaration(c); }))
                        {
                            var resolvedImportedSymbol = ResolveAlias(symbolFromSymbolTable);
                            if (IsAccessible(symbolFromSymbolTable, ResolveAlias(symbolFromSymbolTable)))
                            {
                                return new List<ISymbol> { symbolFromSymbolTable };
                            }

                            // Look in the exported members, if we can find accessibleSymbolChain, symbol is accessible using this chain
                            // but only if the symbolFromSymbolTable can be qualified

                            // DScript-specific. The module exports need to consider V2 semantics, where other files in the same V2 module
                            // may contribute to exports
                            var exports = GetModuleExportsOfSymbol(enclosingDeclaration, resolvedImportedSymbol);

                            var accessibleSymbolsFromExports = exports != null
                                ? GetAccessibleSymbolChainFromSymbolTable(exports)
                                : null;
                            if (accessibleSymbolsFromExports != null && CanQualifySymbol(symbolFromSymbolTable, GetQualifiedLeftMeaning(meaning)))
                            {
                                var accessibleSymbolChain = new List<ISymbol> { symbolFromSymbolTable };
                                accessibleSymbolChain.AddRange(accessibleSymbolsFromExports);
                                return accessibleSymbolChain;
                            }
                        }
                    }
                }

                return null;
            }
        }

        private bool IsExportSpecifierInExplicitModuleReference(INode enclosingDeclaration, ISymbol symbolFromSymbolTable)
        {
            return GetDeclarationOfKind(symbolFromSymbolTable, SyntaxKind.ExportSpecifier) != null && !m_host.IsOwnedByImplicitReferenceModule(enclosingDeclaration.GetSourceFile().Path.AbsolutePath);
        }

        private bool NeedsQualification(ISymbol symbol, INode enclosingDeclaration, SymbolFlags meaning)
        {
            var qualify = false;
            ForEachSymbolTableInScope(enclosingDeclaration, symbolTable =>
            {
                // If symbol of this name is not available in the symbol table we are ok
                if (!HasProperty(symbolTable, symbol.Name))
                {
                    // Continue to the next symbol table
                    return false;
                }

                // If the symbol with this name is present it should refer to the symbol
                var symbolFromSymbolTable = symbolTable[symbol.Name];
                // DScript-specific: Reference equality may involve cloned public namespaces, so comparing based on the original symbol if needed
                if (symbolFromSymbolTable.GetOriginalSymbolOrSelf() == symbol.GetOriginalSymbolOrSelf())
                {
                    // No need to qualify
                    return true;
                }

                // Qualify if the symbol from symbol table has same meaning as expected
                symbolFromSymbolTable = (symbolFromSymbolTable.Flags & SymbolFlags.Alias) != SymbolFlags.None &&

                                        // Export specifiers (in different files) are valid for V2. But export specifiers in the same
                                        // file where already filtered out when constructing the set of symbols.
                                        !IsExportSpecifierInExplicitModuleReference(enclosingDeclaration, symbolFromSymbolTable)
                    ? ResolveAlias(symbolFromSymbolTable)
                    : symbolFromSymbolTable;
                if ((symbolFromSymbolTable.Flags & meaning) != SymbolFlags.None)
                {
                    qualify = true;
                    return true;
                }

                // Continue to the next symbol table
                return false;
            });

            return qualify;
        }

        /// <inheritdoc/>
        public ISymbolAccessiblityResult IsSymbolAccessible(ISymbol symbol, INode enclosingDeclaration, SymbolFlags meaning)
        {
            if (symbol != null && enclosingDeclaration != null && (symbol.Flags & SymbolFlags.TypeParameter) == SymbolFlags.None)
            {
                var initialSymbol = symbol;
                var meaningToLook = meaning;
                while (symbol != null)
                {
                    // Symbol is accessible if it by itself is accessible
                    var accessibleSymbolChain = GetAccessibleSymbolChain(symbol, enclosingDeclaration, meaningToLook, /*useOnlyExternalAliasing*/
                        false);
                    if (accessibleSymbolChain != null)
                    {
                        var firstSymbolInChain = accessibleSymbolChain[0];
                        ISymbolVisibilityResult hasAccessibleDeclarations = HasVisibleDeclarations(firstSymbolInChain);
                        if (hasAccessibleDeclarations == null)
                        {
                            // DScript-specific. If firstSymbolInChain is defined in the prelude, 
                            // then it is automatically accessible to anybody
                            var symbolSourceFile = firstSymbolInChain.DeclarationList.FirstOrDefault()?.GetSourceFile();
                            if (symbolSourceFile == null || !m_host.IsPartOfPreludeModule(symbolSourceFile.FileName))
                            {
                                return new SymbolAccessibilityResult()
                                       {
                                           Accessibility = SymbolAccessibility.NotAccessible,
                                           ErrorSymbolName = SymbolToString(initialSymbol, enclosingDeclaration, meaning),
                                           ErrorModuleName =
                                               symbol != initialSymbol
                                                   ? SymbolToString(symbol, enclosingDeclaration, SymbolFlags.Namespace)
                                                   : null,
                                       };
                            }

                            hasAccessibleDeclarations = new SymbolVisibilityResult()
                                   {
                                       Accessibility = SymbolAccessibility.Accessible,
                                       AliasesToMakeVisible = null,
                                   };
                        }

                        // TODO: Verify equivalence - return hasAccessibleDeclarations;
                        return new SymbolAccessibilityResult()
                        {
                            Accessibility = hasAccessibleDeclarations.Accessibility,
                            AliasesToMakeVisible = hasAccessibleDeclarations.AliasesToMakeVisible,
                            ErrorNode = hasAccessibleDeclarations.ErrorNode,
                            ErrorSymbolName = hasAccessibleDeclarations.ErrorSymbolName,
                        };
                    }

                    // If we haven't got the accessible symbol, it doesn't mean the symbol is actually inaccessible.
                    // It could be a qualified symbol and hence verify the path
                    // e.g.:
                    // module m {
                    //     export class c {
                    //     }
                    // }
                    // const x: typeof m.c
                    // In the above example when we start with checking if typeof m.c symbol is accessible,
                    // we are going to see if c can be accessed in scope directly.
                    // But it can't, hence the accessible is going to be undefined, but that doesn't mean m.c is inaccessible
                    // It is accessible if the parent m is accessible because then m.c can be accessed through qualification
                    meaningToLook = GetQualifiedLeftMeaning(meaning);
                    symbol = GetParentOfSymbol(symbol);
                }

                // This could be a symbol that is not exported in the external module
                // or it could be a symbol from different external module that is not aliased and hence cannot be named
                ISymbol symbolExternalModule = ForEachUntil(initialSymbol.DeclarationList, this, (d, @this) => { return @this.GetExternalModuleContainer(d); });
                if (symbolExternalModule != null)
                {
                    ISymbol enclosingExternalModule = GetExternalModuleContainer(enclosingDeclaration);
                    if (symbolExternalModule != enclosingExternalModule)
                    {
                        // name from different external module that is not visible
                        return new SymbolAccessibilityResult()
                        {
                            Accessibility = SymbolAccessibility.CannotBeNamed,
                            ErrorSymbolName = SymbolToString(initialSymbol, enclosingDeclaration, meaning),
                            ErrorModuleName = SymbolToString(symbolExternalModule),
                        };
                    }
                }

                // Just a local name that is not accessible
                return new SymbolAccessibilityResult()
                {
                    Accessibility = SymbolAccessibility.NotAccessible,
                    ErrorSymbolName = SymbolToString(initialSymbol, enclosingDeclaration, meaning),
                };
            }

            return new SymbolAccessibilityResult()
            {
                Accessibility = SymbolAccessibility.Accessible,
            };
        }

        private ISymbol GetExternalModuleContainer(INode declaration)
        {
            for (; declaration != null; declaration = declaration.Parent)
            {
                if (HasExternalModuleSymbol(declaration))
                {
                    return GetSymbolOfNode(declaration);
                }
            }

            return null;
        }

        private static bool HasExternalModuleSymbol(INode declaration)
        {
            return (declaration.Kind == SyntaxKind.ModuleDeclaration && declaration.Cast<IModuleDeclaration>().Name.Kind == SyntaxKind.StringLiteral) ||
                   (declaration.Kind == SyntaxKind.SourceFile && SourceFileExtensions.IsExternalOrCommonJsModule(declaration.Cast<ISourceFile>()));
        }

        private ISymbolVisibilityResult HasVisibleDeclarations(ISymbol symbol)
        {
            List<AnyImportSyntax> aliasesToMakeVisible = null;

            Func<IDeclaration, bool> getIsDeclarationVisible = (IDeclaration declaration) =>
            {
                if (!IsDeclarationVisible(declaration))
                {
                    // Mark the unexported alias as visible if its parent is visible
                    // because these kind of aliases can be used to name types in declaration file
                    var anyImportSyntax = GetAnyImportSyntax(declaration);

                    if ((anyImportSyntax != null) &&
                        (anyImportSyntax.Flags & NodeFlags.Export) == NodeFlags.None && // import clause without export
                        IsDeclarationVisible(anyImportSyntax.Parent.Cast<IDeclaration>()))
                    {
                        GetNodeLinks(declaration).IsVisible = true;
                        if (aliasesToMakeVisible != null)
                        {
                            // TODO: Verify correctness! List contains will do pointer comparison!
                            if (!aliasesToMakeVisible.Contains(anyImportSyntax, NodeComparer.Instance))
                            {
                                aliasesToMakeVisible.Add(anyImportSyntax);
                            }
                        }
                        else
                        {
                            aliasesToMakeVisible = new List<AnyImportSyntax> { anyImportSyntax };
                        }

                        return true;
                    }

                    // Declaration is not visible
                    return false;
                }

                return true;
            };

            if (symbol.DeclarationList.Any(d => { return !getIsDeclarationVisible(d); }))
            {
                return null;
            }

            return new SymbolVisibilityResult()
            {
                Accessibility = SymbolAccessibility.Accessible,
                AliasesToMakeVisible = aliasesToMakeVisible,
            };
        }

        private ISymbolVisibilityResult IsEntityNameVisible(/*EntityName | Expression*/ INode entityName, INode enclosingDeclaration)
        {
            // get symbol of the first identifier of the entityName
            SymbolFlags meaning = SymbolFlags.None;

            if (entityName.Parent.Kind == SyntaxKind.TypeQuery)
            {
                // Typeof value
                meaning = SymbolFlags.Value | SymbolFlags.ExportValue;
            }
            else if (entityName.Kind == SyntaxKind.QualifiedName ||
                     entityName.Kind == SyntaxKind.PropertyAccessExpression ||
                     entityName.Parent.Kind == SyntaxKind.ImportEqualsDeclaration)
            {
                // Left identifier from type reference or TypeAlias
                // Entity name of the import declaration
                meaning = SymbolFlags.Namespace;
            }
            else
            {
                // Type Reference or TypeAlias entity = Identifier
                meaning = SymbolFlags.Type;
            }

            IIdentifier firstIdentifier = GetFirstIdentifier(entityName);
            var symbol = ResolveName(
                enclosingDeclaration,
                firstIdentifier.Text,
                meaning,
                /*nodeNotFoundErrorMessage*/ null,
                /*nameArg*/ (string)null);

            // Verify if the symbol is accessible
            ISymbolVisibilityResult result = symbol != null ? HasVisibleDeclarations(symbol) : null;
            if (result != null)
            {
                return result;
            }

            return new SymbolVisibilityResult()
            {
                Accessibility = SymbolAccessibility.NotAccessible,
                ErrorSymbolName = GetTextOfNode(firstIdentifier),
                ErrorNode = firstIdentifier.Cast<INode>(),
            };
        }

        /// <inheritdoc/>
        public string SymbolToString(ISymbol symbol, INode enclosingDeclaration = null, SymbolFlags meaning = SymbolFlags.None)
        {
            var writer = SymbolWriterPool.GetSingleLineStringWriter();
            GetSymbolDisplayBuilder().BuildSymbolDisplay(symbol, writer, enclosingDeclaration, meaning);
            var result = writer.String();
            SymbolWriterPool.ReleaseStringWriter(writer);

            return result;
        }

        private string SignatureToString(ISignature signature, INode enclosingDeclaration = null, TypeFormatFlags flags = TypeFormatFlags.None,
            SignatureKind kind = SignatureKind.Call)
        {
            var writer = SymbolWriterPool.GetSingleLineStringWriter();
            GetSymbolDisplayBuilder().BuildSignatureDisplay(signature, writer, enclosingDeclaration, flags, kind);
            var result = writer.String();
            SymbolWriterPool.ReleaseStringWriter(writer);

            return result;
        }

        /// <inheritdoc/>
        public IType GetTypeAtLocation(INode node)
        {
            return TryGetNodeLinks(node)?.ResolvedType ?? GetTypeOfNode(node);
        }

        /// <inheritdoc/>
        public string TypeToString(IType type, INode enclosingDeclaration = null, TypeFormatFlags flags = TypeFormatFlags.None, IStringSymbolWriter writer = null)
        {
            var symbolWriter = writer ?? SymbolWriterPool.GetSingleLineStringWriter();

            GetSymbolDisplayBuilder().BuildTypeDisplay(type, symbolWriter, enclosingDeclaration, flags);
            var result = symbolWriter.String();

            // If we created the writer, we release it
            if (writer == null)
            {
                SymbolWriterPool.ReleaseStringWriter(symbolWriter);
            }

            int? maxLength = m_compilerOptions.NoErrorTruncation || ((flags & TypeFormatFlags.NoTruncation) != TypeFormatFlags.None) ? (int?)null : 100;
            if (maxLength.HasValue && result.Length >= maxLength)
            {
                result = result.Substr(0, maxLength.Value - "...".Length) + "...";
            }

            return result;
        }

        private ISymbol GetTypeAliasForTypeLiteral(IType type)
        {
            if ((type.Symbol?.Flags & SymbolFlags.TypeLiteral) != SymbolFlags.None)
            {
                var node = type.Symbol.DeclarationList[0].Parent;
                while (node.Kind == SyntaxKind.ParenthesizedType)
                {
                    node = node.Parent;
                }

                if (node.Kind == SyntaxKind.TypeAliasDeclaration)
                {
                    return GetSymbolOfNode(node);
                }
            }

            return null;
        }

        private ISymbolDisplayBuilder GetSymbolDisplayBuilder()
        {
            LazyInitializer.EnsureInitialized(ref m_displayBuilder, () => new SymbolDisplayBuilder(this));

            return m_displayBuilder;
        }

        private bool IsDeclarationVisible(IDeclaration node)
        {
            if (node != null)
            {
                return GetNodeLinks(node).GetOrSetIsVisible((checker: this, node), (links, tpl) => tpl.checker.DetermineIfDeclarationIsVisible(tpl.node));
            }

            return false;
        }

        private bool DetermineIfDeclarationIsVisible(IDeclaration node)
        {
            switch (node.Kind)
            {
                case SyntaxKind.BindingElement:
                    // TODO: How do we know that node.Parent.Parent derives from IDeclaration?
                    return IsDeclarationVisible(node.Parent.Parent.Cast<IDeclaration>());

                case SyntaxKind.VariableDeclaration:
                case SyntaxKind.ModuleDeclaration:
                case SyntaxKind.ClassDeclaration:
                case SyntaxKind.InterfaceDeclaration:
                case SyntaxKind.TypeAliasDeclaration:
                case SyntaxKind.FunctionDeclaration:
                case SyntaxKind.EnumDeclaration:
                case SyntaxKind.ImportEqualsDeclaration:
                    if (node.Kind == SyntaxKind.VariableDeclaration &&
                        IsBindingPattern(node.Name) != null &&
                        node.Name.Cast<IBindingPattern>().Elements.Length == 0)
                    {
                        // If the binding pattern is empty, this variable declaration is not visible
                        return false;
                    }

                    INode parent = GetDeclarationContainer(node);

                    // If the node is not exported or it is not ambient module element (except import declaration)
                    if ((GetCombinedNodeFlags(node) & NodeFlags.Export) == NodeFlags.None &&
                        !(node.Kind != SyntaxKind.ImportEqualsDeclaration && parent.Kind != SyntaxKind.SourceFile && IsInAmbientContext(parent)))
                    {
                        return IsGlobalSourceFile(parent);
                    }

                    // Exported members/ambient module elements (exception import declaration) are visible if parent is visible
                    return IsDeclarationVisible(parent.Cast<IDeclaration>());

                case SyntaxKind.PropertyDeclaration:
                case SyntaxKind.PropertySignature:
                case SyntaxKind.GetAccessor:
                case SyntaxKind.SetAccessor:
                case SyntaxKind.MethodDeclaration:
                case SyntaxKind.MethodSignature:
                    if ((node.Flags & (NodeFlags.Private | NodeFlags.Protected)) != NodeFlags.None)
                    {
                        // Private/protected properties/methods are not visible
                        return false;
                    }

                    // TODO: Verify equivalence and update comment (copied fall-through case explicitly)
                    // Public properties/methods are visible if its parents are visible, so const it fall into next case statement
                    return IsDeclarationVisible(node.Parent.Cast<IDeclaration>());

                case SyntaxKind.Constructor:
                case SyntaxKind.ConstructSignature:
                case SyntaxKind.CallSignature:
                case SyntaxKind.IndexSignature:
                case SyntaxKind.Parameter:
                case SyntaxKind.ModuleBlock:
                case SyntaxKind.FunctionType:
                case SyntaxKind.ConstructorType:
                case SyntaxKind.TypeLiteral:
                case SyntaxKind.TypeReference:
                case SyntaxKind.ArrayType:
                case SyntaxKind.TupleType:
                case SyntaxKind.UnionType:
                case SyntaxKind.IntersectionType:
                case SyntaxKind.ParenthesizedType:
                    return IsDeclarationVisible(node.Parent.Cast<IDeclaration>());

                // Default binding, import specifier and namespace import is visible
                // only on demand so by default it is not visible
                case SyntaxKind.ImportClause:
                case SyntaxKind.NamespaceImport:
                case SyntaxKind.ImportSpecifier:
                    return false;

                // Type parameters are always visible
                case SyntaxKind.TypeParameter:
                // Source file is always visible
                case SyntaxKind.SourceFile:
                    return true;

                // Export assignments do not create name bindings outside the module
                case SyntaxKind.ExportAssignment:
                    return false;

                // DScript-specific. Export specifiers may be part of the accessibility chain
                // in the case of V2 modules. They are always visible.
                case SyntaxKind.ExportSpecifier:
                    return true;

                default:
                    Contract.Assert(false, "isDeclarationVisible SyntaxKind unknown: " + node.Kind);
                    break;
            }

            return false;
        }

        /// <inheritdoc/>
        public List<INode> CollectLinkedAliases(IIdentifier node)
        {
            ISymbol exportSymbol = null;
            if (node.Parent != null && node.Parent.Kind == SyntaxKind.ExportAssignment)
            {
                exportSymbol = ResolveName(
                    node.Parent,
                    node.Text,
                    SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace | SymbolFlags.Alias,
                    Errors.Cannot_find_name_0, node);
            }
            else if (node.Parent?.Kind == SyntaxKind.ExportSpecifier)
            {
                var exportSpecifier = node.Parent.Cast<IExportSpecifier>();
                exportSymbol = exportSpecifier.Parent.Parent.Cast<IExportDeclaration>().ModuleSpecifier != null
                    ? GetExternalModuleMember(exportSpecifier.Parent.Parent.Cast<IExportDeclaration>(), exportSpecifier)
                    : ResolveEntityName(
                        exportSpecifier.PropertyName ?? exportSpecifier.Name,
                        SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace | SymbolFlags.Alias);
            }

            List<INode> result = new List<INode>();
            if (exportSymbol != null)
            {
                BuildVisibleNodeList(exportSymbol.DeclarationList, result);
            }

            return result;
        }

        private void BuildVisibleNodeList(ReadOnlyList<IDeclaration> declarations, List<INode> resultArg)
        {
            ForEach(declarations, (checker: this, resultArg), (declaration, tuple) =>
            {
                var @this = tuple.checker;
                var result = tuple.resultArg;
                @this.GetNodeLinks(declaration).IsVisible = true;

                var resultNode = GetAnyImportSyntax(declaration) ?? declaration;
                if (!result.Contains(resultNode, NodeComparer.Instance))
                {
                    result.Add(resultNode);
                }

                if (IsInternalModuleImportEqualsDeclaration(declaration))
                {
                    // Add the referenced top container visible
                    // TODO: Fix casts!
                    var internalModuleReference = declaration.Cast<IImportEqualsDeclaration>().ModuleReference;

                    // TODO: need to cast to < Identifier | QualifiedName >
                    IIdentifier firstIdentifier = GetFirstIdentifier(internalModuleReference);
                    var importSymbol = @this.ResolveName(
                        declaration,
                        firstIdentifier.Text,
                        SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace,
                        Errors.Cannot_find_name_0,
                        firstIdentifier);

                    @this.BuildVisibleNodeList(importSymbol.DeclarationList, result);
                }
            });
        }

        /// <summary>
        /// Push an entry on the type resolution stack.
        /// </summary>
        /// <param name="target">The symbol, type, or signature whose type is being queried</param>
        /// <param name="propertyName">The property name that should be used to query the target for its type</param>
        /// <remarks>
        /// If an entry with the given target and the given property name
        /// is already on the stack, and no entries in between already have a type, then a circularity has occurred.
        /// In this case, the result values of the existing entry and all entries pushed after it are changed to false,
        /// and the value false is returned. Otherwise, the new entry is just pushed onto the stack, and true is returned.
        /// In order to see if the same query has already been done before, the target object and the propertyName both
        /// must match the one passed in.
        /// </remarks>
        private bool PushTypeResolution(/*HINT: TypeSystemEntity*/ object target, TypeSystemPropertyName propertyName)
        {
            var resolutionCycleStartIndex = FindResolutionCycleStartIndex(target, propertyName);

            if (resolutionCycleStartIndex >= 0)
            {
                // A cycle was found
                for (var i = resolutionCycleStartIndex; i < m_resolutionTargets.Value.Count; i++)
                {
                    m_resolutionResults.Value[i] = false;
                }

                return false;
            }

            m_resolutionTargets.Value.Add(target);
            m_resolutionResults.Value.Add(/*items*/ true);
            m_resolutionPropertyNames.Value.Add(propertyName);

            return true;
        }

        private int FindResolutionCycleStartIndex(/*HINT: TypeSystemEntity*/ object target, TypeSystemPropertyName propertyName)
        {
            for (var i = m_resolutionTargets.Value.Count - 1; i >= 0; i--)
            {
                if (HasType(m_resolutionTargets.Value[i], m_resolutionPropertyNames.Value[i]) != null)
                {
                    return -1;
                }

                if (m_resolutionTargets.Value[i] == target && m_resolutionPropertyNames.Value[i] == propertyName)
                {
                    return i;
                }
            }

            return -1;
        }

        private IType HasType(/*HINT: TypeSystemEntity*/ object target, TypeSystemPropertyName propertyName)
        {
            if (propertyName == TypeSystemPropertyName.Type)
            {
                // TODO: Verify cast
                return GetSymbolLinks((ISymbol)target).Type;
            }

            if (propertyName == TypeSystemPropertyName.DeclaredType)
            {
                // TODO: Verify cast
                return GetSymbolLinks((ISymbol)target).DeclaredType;
            }

            if (propertyName == TypeSystemPropertyName.ResolvedBaseConstructorType)
            {
                // TODO: Verify casts
                Contract.Assert((((IType)target).Flags & TypeFlags.Class) != TypeFlags.None);
                return ((IInterfaceType)target).ResolvedBaseConstructorType;
            }

            if (propertyName == TypeSystemPropertyName.ResolvedReturnType)
            {
                // TODO: Verify cast
                return ((ISignature)target).ResolvedReturnType;
            }

            Contract.Assert(false, "Unhandled TypeSystemPropertyName " + propertyName.ToString());
            return null;
        }

        // Pop an entry from the type resolution stack and return its associated result value. The result value will
        // be true if no circularities were detected, or false if a circularity was found.
        private bool PopTypeResolution()
        {
            m_resolutionTargets.Value.Pop();
            m_resolutionPropertyNames.Value.Pop();
            return m_resolutionResults.Value.Pop();
        }

        private static INode GetDeclarationContainer(INode node)
        {
            node = GetRootDeclaration(node);

            // Parent chain:
            // VariableDeclaration -> VariableDeclarationList -> VariableStatement -> 'Declaration Container'
            return node.Kind == SyntaxKind.VariableDeclaration ? node.Parent.Parent.Parent : node.Parent;
        }

        private IType GetTypeOfPrototypeProperty(ISymbol prototype)
        {
            // TypeScript 1.0 spec (April 2014): 8.4
            // Every class automatically contains a static property member named 'prototype',
            // the type of which is an instantiation of the class type with type Any supplied as a type argument for each type parameter.
            // It is an error to explicitly declare a static property member with the name 'prototype'.
            IInterfaceType classType = GetDeclaredTypeOfSymbol(prototype.Parent).Cast<IInterfaceType>();
            return classType.TypeParameters != null ?
                (IType)CreateTypeReference(classType.Cast<IGenericType>(), classType.TypeParameters.Select(_ => (IType)m_anyType).ToList())
                : classType;
        }

        // Return the type of the given property in the given type, or null if no such property exists
        private IType GetTypeOfPropertyOfType(IType type, string name)
        {
            var prop = GetPropertyOfType(type, name);
            return prop != null ? GetTypeOfSymbol(prop) : null;
        }

        private static bool IsTypeAny(IType type)
        {
            return (type != null) && (type.Flags & TypeFlags.Any) != TypeFlags.None;
        }

        // Return the type of a binding element parent. We check SymbolLinks first to see if a type has been
        // assigned by contextual typing.
        private IType GetTypeForBindingElementParent(IVariableLikeDeclaration node)
        {
            var symbol = GetSymbolOfNode(node);

            IType result = null;
            if (symbol != null)
            {
                result = GetSymbolLinks(symbol).Type;
            }

            result = result ?? GetTypeForVariableLikeDeclaration(node);
            return result;
        }

        private static string GetTextOfPropertyName(/*HINT: PropertyName*/ INode name)
        {
            switch (name.Kind)
            {
                case SyntaxKind.Identifier:
                    return name.Cast<IIdentifier>().Text;

                case SyntaxKind.StringLiteral:
                case SyntaxKind.NumericLiteral:
                    return name.Cast<ILiteralExpression>().Text;

                case SyntaxKind.ComputedPropertyName:
                    if (IsStringOrNumericLiteral(name.Cast<IComputedPropertyName>().Expression.Kind))
                    {
                        return name.Cast<IComputedPropertyName>().Expression.Cast<ILiteralExpression>().Text;
                    }

                    break;
            }

            return null;
        }

        private static bool IsComputedNonLiteralName(/*HINT: PropertyName*/ INode name)
        {
            return (name.Kind == SyntaxKind.ComputedPropertyName) && !IsStringOrNumericLiteral(name.Cast<IComputedPropertyName>().Expression.Kind);
        }

        // Return the inferred type for a binding element
        private IType GetTypeForBindingElement(IBindingElement declaration)
        {
            var pattern = declaration.Parent.Cast<IBindingPattern>(); // TODO: Verify cast

            // TODO: This cast will not work! Need to update interfaces to derive from IVariableLikeDeclaration
            var parentType = GetTypeForBindingElementParent(pattern.Parent.Cast<IVariableLikeDeclaration>());

            // If parent has the unknown (error) type, then so does this binding element
            if (parentType == m_unknownType)
            {
                return m_unknownType;
            }

            // If no type was specified or inferred for parent, or if the specified or inferred type is any,
            // infer from the initializer of the binding element if one is present. Otherwise, go with the
            // null or any type of the parent.
            if (parentType == null || IsTypeAny(parentType))
            {
                if (declaration.Initializer != null)
                {
                    return CheckExpressionCached(declaration.Initializer);
                }

                return parentType;
            }

            IType type = null;
            if (pattern.Kind == SyntaxKind.ObjectBindingPattern)
            {
                // Use explicitly specified property name ({ p: xxx } form), or otherwise the implied name ({ p } form)

                // TODO: Verify equivalence - const name = declaration.PropertyName || <Identifier>declaration.Name;
                var name = declaration.PropertyName ?? new PropertyName(declaration.Name.Cast<IIdentifier>());
                if (IsComputedNonLiteralName(name))
                {
                    // computed properties with non-literal names are treated as 'any'
                    return m_anyType;
                }

                // Use type of the specified property, or otherwise, for a numeric name, the type of the numeric index signature,
                // or otherwise the type of the string index signature.
                var text = GetTextOfPropertyName(name);

                // TODO: Verify equivalence:
                // type = getTypeOfPropertyOfType(parentType, text) ||
                //        isNumericLiteralName(text) && getIndexTypeOfType(parentType, IndexKind.Number) ||
                //        getIndexTypeOfType(parentType, IndexKind.String);
                type = GetTypeOfPropertyOfType(parentType, text);
                if ((type == null) && Number.IsNumericLiteralName(text))
                {
                    type = GetIndexTypeOfType(parentType, IndexKind.Number);
                }

                if (type == null)
                {
                    type = GetIndexTypeOfType(parentType, IndexKind.String);
                }

                if (type == null)
                {
                    Error(
                        name,
                        Errors.Type_0_has_no_property_1_and_no_string_index_signature,
                        TypeToString(parentType),
                        DeclarationNameToString(name));

                    return m_unknownType;
                }
            }
            else
            {
                // This elementType will be used if the specific property corresponding to this index is not
                // present (aka the tuple element property). This call also checks that the parentType is in
                // fact an iterable or array (depending on target language).
                IType elementType = CheckIteratedTypeOrElementType(parentType, pattern, /*allowStringInput*/ false);
                if (!declaration.DotDotDotToken)
                {
                    // Use specific property type when parent is a tuple or numeric index type when parent is an array
                    var propName = IndexOf(pattern.Elements, declaration).ToString();

                    type = IsTupleLikeType(parentType) ? GetTypeOfPropertyOfType(parentType, propName) : elementType;
                    if (type == null)
                    {
                        if (IsTupleType(parentType))
                        {
                            Error(
                                declaration,
                                Errors.Tuple_type_0_with_length_1_cannot_be_assigned_to_tuple_with_length_2,
                                TypeToString(parentType),
                                parentType.Cast<ITupleType>().ElementTypes.Count,
                                pattern.Elements.Length);
                        }
                        else
                        {
                            Error(
                                declaration,
                                Errors.Type_0_has_no_property_1,
                                TypeToString(parentType),
                                propName);
                        }

                        return m_unknownType;
                    }
                }
                else
                {
                    // Rest element has an array type with the same element type as the parent type
                    type = CreateArrayType(elementType);
                }
            }

            return type;
        }

        // Return the inferred type for a variable, parameter, or property declaration
        private IType GetTypeForVariableLikeDeclaration(IVariableLikeDeclaration declaration)
        {
            // A variable declared in a for..in statement is always of type any
            if (declaration.Parent.Parent.Kind == SyntaxKind.ForInStatement)
            {
                return m_anyType;
            }

            if (declaration.Parent.Parent.Kind == SyntaxKind.ForOfStatement)
            {
                // checkRightHandSideOfForOf will return null if the for-of expression type was
                // missing properties/signatures required to get its iteratedType (like
                // [Symbol.iterator] or next). This may be because we accessed properties from anyType,
                // or it may have led to an error inside getElementTypeOfIterable.
                return CheckRightHandSideOfForOf(declaration.Parent.Parent.Cast<IForOfStatement>().Expression) ?? m_anyType;
            }

            if (IsBindingPattern(declaration.Parent) != null)
            {
                return GetTypeForBindingElement(declaration.Cast<IBindingElement>()); // TODO: Verify cast
            }

            // Use type from type annotation if one is present
            if (declaration.Type != null)
            {
                return GetTypeFromTypeNode(declaration.Type);
            }

            if (declaration.Kind == SyntaxKind.Parameter)
            {
                var func = declaration.Parent.Cast<IFunctionLikeDeclaration>();

                // For a parameter of a set accessor, use the type of the get accessor if one is present
                if (func.Kind == SyntaxKind.SetAccessor && !HasDynamicName(func))
                {
                    var getter = GetDeclarationOfKind(declaration.Parent.Symbol, SyntaxKind.GetAccessor).Cast<IAccessorDeclaration>();
                    return GetReturnTypeOfSignature(GetSignatureFromDeclaration(getter));
                }

                // Use contextual parameter type if one is available
                var type = GetContextuallyTypedParameterType(declaration.Cast<IParameterDeclaration>());
                if (type != null)
                {
                    return type;
                }
            }

            // Use the type of the initializer expression if one is present
            if (declaration.Initializer != null)
            {
                return CheckExpressionCached(declaration.Initializer);
            }

            // If it is a short-hand property assignment, use the type of the identifier
            if (declaration.Kind == SyntaxKind.ShorthandPropertyAssignment)
            {
                return CheckIdentifier(declaration.Name.Cast<IIdentifier>());
            }

            // If the declaration specifies a binding pattern, use the type implied by the binding pattern
            if (IsBindingPattern(declaration.Name) != null)
            {
                return GetTypeFromBindingPattern(declaration.Name.Cast<IBindingPattern>(), /*includePatternInType*/ false);
            }

            // No type specified and nothing can be inferred
            return null;
        }

        // Return the type implied by a binding pattern element. This is the type of the initializer of the element if
        // one is present. Otherwise, if the element is itself a binding pattern, it is the type implied by the binding
        // pattern. Otherwise, it is the type any.
        private IType GetTypeFromBindingElement(IBindingElement element, bool includePatternInType)
        {
            if (element.Initializer != null)
            {
                return GetWidenedType(CheckExpressionCached(element.Initializer));
            }

            if (IsBindingPattern(element.Name) != null)
            {
                return GetTypeFromBindingPattern(element.Name.Cast<IBindingPattern>(), includePatternInType);
            }

            return m_anyType;
        }

        // Return the type implied by an object binding pattern
        private IType GetTypeFromObjectBindingPattern(IBindingPattern pattern, bool includePatternInType)
        {
            ISymbolTable members = new SymbolTable();

            var hasComputedProperties = false;

            ForEach(pattern.Elements, e =>
            {
                // TODO: Verify equivalence - const name = e.PropertyName || <Identifier>e.Name;
                var name = e.PropertyName ?? PropertyName.Identifier(e.Name.Cast<IIdentifier>());
                if (IsComputedNonLiteralName(name))
                {
                    // do not include computed properties in the implied type
                    hasComputedProperties = true;
                    return;
                }

                var text = GetTextOfPropertyName(name);
                SymbolFlags flags = SymbolFlags.Property | SymbolFlags.Transient | (e.Initializer != null ? SymbolFlags.Optional : SymbolFlags.None);

                var symbolData = new SymbolData
                {
                    Type = GetTypeFromBindingElement(e, includePatternInType),
                    BindingElement = e,
                };
                var symbol = CreateTransientSymbol(
                    flags,
                    text,
                    ref symbolData);

                members[symbol.Name] = symbol;
            });

            var result = CreateAnonymousType(null, members, s_emptySignatureEnumerable, s_emptySignatureEnumerable, null, null);
            if (includePatternInType)
            {
                result.Pattern = new DestructuringPattern(pattern);
            }

            if (hasComputedProperties)
            {
                result.Flags |= TypeFlags.ObjectLiteralPatternWithComputedProperties;
            }

            return result;
        }

        // Return the type implied by an array binding pattern
        private IType GetTypeFromArrayBindingPattern(IBindingPattern pattern, bool includePatternInType)
        {
            var elements = pattern.Elements;
            if (elements.Length == 0 || elements[elements.Length - 1].DotDotDotToken)
            {
                return m_languageVersion >= ScriptTarget.Es6 ? CreateIterableType(m_anyType) : m_anyArrayType;
            }

            // If the pattern has at least one element, and no rest element, then it should imply a tuple type.
            var elementTypes = Map(
                elements,
                e => e.Kind == SyntaxKind.OmittedExpression ? m_anyType : GetTypeFromBindingElement(e, includePatternInType));

            if (includePatternInType)
            {
                var result = CreateNewTupleType(elementTypes);
                result.Pattern = new DestructuringPattern(pattern);
                return result;
            }

            return CreateTupleType(elementTypes);
        }

        // Return the type implied by a binding pattern. This is the type implied purely by the binding pattern itself
        // and without regard to its context (i.e., without regard any type annotation or initializer associated with the
        // declaration in which the binding pattern is contained). For example, the implied type of [x, y] is [any, any]
        // and the implied type of { x, y: z = 1 } is { x: any; y: number; }. The type implied by a binding pattern is
        // used as the contextual type of an initializer associated with the binding pattern. Also, for a destructuring
        // parameter with no type annotation or initializer, the type implied by the binding pattern becomes the type of
        // the parameter.
        private IType GetTypeFromBindingPattern(IBindingPattern pattern, bool includePatternInType)
        {
            return pattern.Kind == SyntaxKind.ObjectBindingPattern
                ? GetTypeFromObjectBindingPattern(pattern, includePatternInType)
                : GetTypeFromArrayBindingPattern(pattern, includePatternInType);
        }

        // Return the type associated with a variable, parameter, or property declaration. In the simple case this is the type
        // specified in a type annotation or inferred from an initializer. However, in the case of a destructuring declaration it
        // is a bit more involved. For example:
        //
        //   var [x, s = ""] = [1, "one"];
        //
        // Here, the array literal [1, "one"] is contextually typed by the type [any, string], which is the implied type of the
        // binding pattern [x, s = ""]. Because the contextual type is a tuple type, the resulting type of [1, "one"] is the
        // tuple type [number, string]. Thus, the type inferred for 'x' is number and the type inferred for 's' is string.
        private IType GetWidenedTypeForVariableLikeDeclaration(IVariableLikeDeclaration declaration, bool reportErrors = false)
        {
            var type = GetTypeForVariableLikeDeclaration(declaration);
            if (type != null)
            {
                if (reportErrors)
                {
                    ReportErrorsFromWidening(declaration, type);
                }

                // During a normal type check we'll never get to here with a property assignment (the check of the containing
                // object literal uses a different path). We exclude widening only so that language services and type verification
                // tools see the actual type.
                if (declaration.Kind == SyntaxKind.PropertyAssignment)
                {
                    return type;
                }

                if ((type.Flags & TypeFlags.PredicateType) != TypeFlags.None &&
                    (declaration.Kind == SyntaxKind.PropertyDeclaration || declaration.Kind == SyntaxKind.PropertySignature))
                {
                    return type;
                }

                return GetWidenedType(type);
            }

            // Rest parameters default to type any[], other parameters default to type any
            type = declaration.DotDotDotToken ? m_anyArrayType : m_anyType;

            // Report implicit any errors unless this is a private property within an ambient declaration
            if (reportErrors && m_compilerOptions.NoImplicitAny.HasValue && m_compilerOptions.NoImplicitAny.Value)
            {
                var root = GetRootDeclaration(declaration);
                if (!IsPrivateWithinAmbient(root) && !(root.Kind == SyntaxKind.Parameter && IsPrivateWithinAmbient(root.Parent)))
                {
                    ReportImplicitAnyError(declaration, type);
                }
            }

            return type;
        }

        private IType GetTypeOfVariableOrParameterOrProperty(ISymbol symbolArg)
        {
            return GetSymbolLinks(symbolArg).GetOrSetType(
                (checker: this, symbolArg),
                (links, tuple) =>
                {
                    var @this = tuple.checker;
                    var symbol = tuple.symbolArg;

                    // Handle prototype property
                    if ((symbol.Flags & SymbolFlags.Prototype) != SymbolFlags.None)
                    {
                        return @this.GetTypeOfPrototypeProperty(symbol);
                    }

                    // Handle catch clause variables
                    var declaration = symbol.ValueDeclaration;
                    if (declaration.Parent.Kind == SyntaxKind.CatchClause)
                    {
                        return @this.m_anyType.Cast<IType>();
                    }

                    // Handle export default expressions
                    if (declaration.Kind == SyntaxKind.ExportAssignment)
                    {
                        return @this.CheckExpression(declaration.Cast<IExportAssignment>().Expression);
                    }

                    // Handle module.exports = expr
                    if (declaration.Kind == SyntaxKind.BinaryExpression)
                    {
                        return @this.CheckExpression(declaration.Cast<IBinaryExpression>().Right);
                    }

                    if (declaration.Kind == SyntaxKind.PropertyAccessExpression)
                    {
                        // Declarations only exist for property access expressions for certain
                        // special assignment kinds
                        if (declaration.Parent.Kind == SyntaxKind.BinaryExpression)
                        {
                            // Handle exports.p = expr or this.p = expr or className.prototype.method = expr
                            return @this.CheckExpressionCached(declaration.Parent.Cast<IBinaryExpression>().Right);
                        }
                    }

                    // Handle variable, parameter or property
                    if (!@this.PushTypeResolution(symbol, TypeSystemPropertyName.Type))
                    {
                        return @this.m_unknownType;
                    }

                    var type = @this.GetWidenedTypeForVariableLikeDeclaration(declaration.Cast<IVariableLikeDeclaration>(), /*reportErrors*/ true);

                    if (!@this.PopTypeResolution())
                    {
                        if (symbol.ValueDeclaration.Cast<IVariableLikeDeclaration>().Type != null)
                        {
                            // Variable has type annotation that circularly references the variable itself
                            type = @this.m_unknownType;
                            @this.Error(
                                symbol.ValueDeclaration,
                                Errors.Zero_is_referenced_directly_or_indirectly_in_its_own_type_annotation,
                                @this.SymbolToString(symbol));
                        }
                        else
                        {
                            // Variable has initializer that circularly references the variable itself
                            type = @this.m_anyType;
                            if (@this.m_compilerOptions.NoImplicitAny.HasValue && @this.m_compilerOptions.NoImplicitAny.Value)
                            {
                                @this.Error(
                                    symbol.ValueDeclaration,
                                    Errors.Zero_implicitly_has_type_any_because_it_does_not_have_a_type_annotation_and_is_referenced_directly_or_indirectly_in_its_own_initializer,
                                    @this.SymbolToString(symbol));
                            }
                        }
                    }

                    return type;
                });
        }

        private IType GetAnnotatedAccessorType(IAccessorDeclaration accessor)
        {
            if (accessor != null)
            {
                if (accessor.Kind == SyntaxKind.GetAccessor)
                {
                    return (accessor.Type != null) ? GetTypeFromTypeNode(accessor.Type) : null;
                }
                else
                {
                    ITypeNode setterTypeAnnotation = GetSetAccessorTypeAnnotationNode(accessor);
                    return (setterTypeAnnotation != null) ? GetTypeFromTypeNode(setterTypeAnnotation) : null;
                }
            }

            return null;
        }

        private IType GetTypeOfAccessors(ISymbol symbolArg)
        {
            return GetSymbolLinks(symbolArg).GetOrSetType(
                (checker:this, symbolArg),
                (links, tuple) =>
                {
                    var @this = tuple.checker;
                    var symbol = tuple.symbolArg;

                    if (!@this.PushTypeResolution(symbol, TypeSystemPropertyName.Type))
                    {
                        return @this.m_unknownType;
                    }

                    var getter = GetDeclarationOfKind(symbol, SyntaxKind.GetAccessor)?.Cast<IAccessorDeclaration>();
                    var setter = GetDeclarationOfKind(symbol, SyntaxKind.SetAccessor)?.Cast<IAccessorDeclaration>();

                    IType type = null;

                    // First try to see if the user specified a return type on the get-accessor.
                    var getterReturnType = @this.GetAnnotatedAccessorType(getter);
                    if (getterReturnType != null)
                    {
                        type = getterReturnType;
                    }
                    else
                    {
                        // If the user didn't specify a return type, try to use the set-accessor's parameter type.
                        var setterParameterType = @this.GetAnnotatedAccessorType(setter);
                        if (setterParameterType != null)
                        {
                            type = setterParameterType;
                        }
                        else
                        {
                            // If there are no specified types, try to infer it from the body of the get accessor if it exists.
                            if (getter?.Body != null)
                            {
                                type = @this.GetReturnTypeFromBody(getter);
                            }

                            // Otherwise, fall back to 'any'.
                            else
                            {
                                if (@this.m_compilerOptions.NoImplicitAny.HasValue && @this.m_compilerOptions.NoImplicitAny.Value)
                                {
                                    @this.Error(
                                        setter,
                                        Errors.Property_0_implicitly_has_type_any_because_its_set_accessor_lacks_a_type_annotation,
                                        @this.SymbolToString(symbol));
                                }

                                type = @this.m_anyType;
                            }
                        }
                    }

                    if (!@this.PopTypeResolution())
                    {
                        type = @this.m_anyType;
                        if (@this.m_compilerOptions.NoImplicitAny.HasValue && @this.m_compilerOptions.NoImplicitAny.Value)
                        {
                            // TODO: TS implementation re-defines getter here. Unnecessary? var getter = GetDeclarationOfKind(symbol, SyntaxKind.GetAccessor).Cast<IAccessorDeclaration>();
                            @this.Error(
                                getter,
                                Errors.Zero_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions,
                                @this.SymbolToString(symbol));
                        }
                    }

                    return type;
                });
        }

        private IType GetTypeOfFuncClassEnumModule(ISymbol symbolArg)
        {
            return GetSymbolLinks(symbolArg).GetOrSetType(
                (checker:this, symbolArg),
                (links, tuple) =>
                {
                    var @this = tuple.checker;
                    var symbol = tuple.symbolArg;
                    return @this.CreateObjectType<AnonymousType>(TypeFlags.Anonymous, symbol);
                });
        }

        private IType GetTypeOfEnumMember(ISymbol symbolArg)
        {
            return GetSymbolLinks(symbolArg).GetOrSetType(
                 (checker: this, symbolArg),
                (links, tuple) =>
                {
                    var @this = tuple.checker;
                    var symbol = tuple.symbolArg;
                    return @this.GetDeclaredTypeOfEnum(@this.GetParentOfSymbol(symbol));
                });
        }

        private IType GetTypeOfAlias(ISymbol symbolArg)
        {
            return GetSymbolLinks(symbolArg).GetOrSetType(
                 (checker: this, symbolArg),
                (links, tuple) =>
                {
                    var @this = tuple.checker;
                    var symbol = tuple.symbolArg;
                    var targetSymbol = @this.ResolveAlias(symbol);

                    // It only makes sense to get the type of a value symbol. If the result of resolving
                    // the alias is not a value, then it has no type. To get the type associated with a
                    // type symbol, call GetDeclaredTypeOfSymbol.
                    // This check is important because without it, a call to GetTypeOfSymbol could end
                    // up recursively calling getTypeOfAlias, causing a stack overflow.
                    return (targetSymbol.Flags & SymbolFlags.Value) != SymbolFlags.None
                        ? @this.GetTypeOfSymbol(targetSymbol)
                        : @this.m_unknownType.Cast<IType>();
                });
        }

        private IType GetTypeOfInstantiatedSymbol(ISymbol symbolArg)
        {
            return GetSymbolLinks(symbolArg).GetOrSetType(
                 (checker: this, symbolArg),
                (links, tuple) =>
                {
                    var @this = tuple.checker;
                    var symbol = tuple.symbolArg;
                    return @this.InstantiateType(@this.GetTypeOfSymbol(links.Target), links.Mapper);
                });
        }

        private IType GetTypeOfSymbol(ISymbol symbol)
        {
            if ((symbol.Flags & SymbolFlags.Instantiated) != SymbolFlags.None)
            {
                return GetTypeOfInstantiatedSymbol(symbol);
            }

            if ((symbol.Flags & (SymbolFlags.Variable | SymbolFlags.Property)) != SymbolFlags.None)
            {
                return GetTypeOfVariableOrParameterOrProperty(symbol);
            }

            if ((symbol.Flags & (SymbolFlags.Function | SymbolFlags.Method | SymbolFlags.Class | SymbolFlags.Enum | SymbolFlags.ValueModule)) !=
                SymbolFlags.None)
            {
                return GetTypeOfFuncClassEnumModule(symbol);
            }

            if ((symbol.Flags & SymbolFlags.EnumMember) != SymbolFlags.None)
            {
                return GetTypeOfEnumMember(symbol);
            }

            if ((symbol.Flags & SymbolFlags.Accessor) != SymbolFlags.None)
            {
                return GetTypeOfAccessors(symbol);
            }

            if ((symbol.Flags & SymbolFlags.Alias) != SymbolFlags.None)
            {
                return GetTypeOfAlias(symbol);
            }

            return m_unknownType;
        }

        private static IType GetTargetType(/*HINT: IObjectType*/ IType type)
        {
            return (type.Flags & TypeFlags.Reference) != TypeFlags.None ? type.Cast<ITypeReference>().Target : type;
        }

        private bool HasBaseType(IInterfaceType type, IInterfaceType checkBaseArg)
        {
            return CheckBaseType(type, checkBaseArg, this);
        }

        private static bool CheckBaseType(IType t, IInterfaceType checkBase, Checker @this)
        {
            var target = GetTargetType(t).Cast<IInterfaceType>();
            return (target == checkBase) ||
                Any(@this.GetBaseTypes(target), bt => CheckBaseType(bt, checkBase, @this));
        }

        // Appends the type parameters given by a list of declarations to a set of type parameters and returns the resulting set.
        // The allocates a new array if the input type parameter set is null, but otherwise it modifies the set
        // in-place and returns the same array.
        private List<ITypeParameter> AppendTypeParameters(List<ITypeParameter> typeParameters, [NotNull] NodeArray<ITypeParameterDeclaration> declarations)
        {
            foreach (var declaration in declarations)
            {
                ITypeParameter tp = GetDeclaredTypeOfTypeParameter(GetSymbolOfNode(declaration));

                if (typeParameters == null)
                {
                    typeParameters = new List<ITypeParameter>() { tp };
                }
                else if (!typeParameters.Contains(tp))
                {
                    typeParameters.Add(tp);
                }
            }

            return typeParameters;
        }

        // Appends the outer type parameters of a node to a set of type parameters and returns the resulting set. The function
        // allocates a new array if the input type parameter set is undefined, but otherwise it modifies the set in-place and
        // returns the same array.
        private List<ITypeParameter> AppendOuterTypeParameters(List<ITypeParameter> typeParameters, INode node)
        {
            node = node.Parent;

            while (node != null)
            {
                NodeArray<ITypeParameterDeclaration> declarations = null;

                if (node.Kind == SyntaxKind.ClassDeclaration || node.Kind == SyntaxKind.ClassExpression)
                {
                    declarations = node.Cast<IClassLikeDeclaration>().TypeParameters;
                }
                else if (node.Kind == SyntaxKind.FunctionDeclaration || node.Kind == SyntaxKind.FunctionExpression ||
                         node.Kind == SyntaxKind.MethodDeclaration || node.Kind == SyntaxKind.ArrowFunction)
                {
                    declarations = node.Cast<IFunctionLikeDeclaration>().TypeParameters;
                }

                if (declarations != null)
                {
                    return AppendTypeParameters(AppendOuterTypeParameters(typeParameters, node), declarations);
                }

                node = node.Parent;
            }

            return typeParameters;
        }

        // The outer type parameters are those defined by enclosing generic classes, methods, or functions.
        private List<ITypeParameter> GetOuterTypeParametersOfClassOrInterface(ISymbol symbol)
        {
            var declaration = (symbol.Flags & SymbolFlags.Class) != SymbolFlags.None
                ? symbol.ValueDeclaration
                : GetDeclarationOfKind(symbol, SyntaxKind.InterfaceDeclaration);
            return AppendOuterTypeParameters(null, declaration);
        }

        // The local type parameters are the combined set of type parameters from all declarations of the class,
        // interface, or type alias.
        private List<ITypeParameter> GetLocalTypeParametersOfClassOrInterfaceOrTypeAlias(ISymbol symbol)
        {
            List<ITypeParameter> result = null;

            foreach (var node in symbol.DeclarationList)
            {
                NodeArray<ITypeParameterDeclaration> declarations = null;

                if (node.Kind == SyntaxKind.InterfaceDeclaration)
                {
                    declarations = node.Cast<IInterfaceDeclaration>().TypeParameters;
                }
                else if (node.Kind == SyntaxKind.ClassDeclaration || node.Kind == SyntaxKind.ClassExpression)
                {
                    declarations = node.Cast<IClassLikeDeclaration>().TypeParameters;
                }
                else if (node.Kind == SyntaxKind.TypeAliasDeclaration)
                {
                    declarations = node.Cast<ITypeAliasDeclaration>().TypeParameters;
                }

                if (declarations != null)
                {
                    result = AppendTypeParameters(result, declarations);
                }
            }

            return result;
        }

        // The full set of type parameters for a generic class or interface type consists of its outer type parameters plus
        // its locally declared type parameters.
        private List<ITypeParameter> GetTypeParametersOfClassOrInterface(ISymbol symbol)
        {
            return GetOuterTypeParametersOfClassOrInterface(symbol).Concatenate(GetLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol));
        }

        private bool IsConstructorType(IType type)
        {
            return (type.Flags & TypeFlags.ObjectType) != TypeFlags.None && GetSignaturesOfType(type, SignatureKind.Construct).Count > 0;
        }

        private static IExpressionWithTypeArguments GetBaseTypeNodeOfClass(IInterfaceType type)
        {
            return GetClassExtendsHeritageClauseElement(type.Symbol.ValueDeclaration.Cast<IClassLikeDeclaration>());
        }

        private IReadOnlyList<ISignature> GetConstructorsForTypeArguments(/*HINT: IObjectType*/ IType type, [CanBeNull]NodeArray<ITypeNode> typeArgumentNodes)
        {
            var typeArgCount = typeArgumentNodes?.Count ?? 0;

            return GetSignaturesOfType(type, SignatureKind.Construct).Filter(sig => (sig.TypeParameters?.Count ?? 0) == typeArgCount);
        }

        private IReadOnlyList<ISignature> GetInstantiatedConstructorsForTypeArguments(/*HINT: IObjectType*/ IType type, [CanBeNull]NodeArray<ITypeNode> typeArgumentNodes)
        {
            var signatures = GetConstructorsForTypeArguments(type, typeArgumentNodes);
            if (typeArgumentNodes != null)
            {
                var typeArguments = Map(typeArgumentNodes, GetTypeFromTypeNode);
                signatures = signatures.Map(sig => GetSignatureInstantiation(sig, typeArguments));
            }

            return signatures;
        }

        // The base constructor of a class can resolve to
        // undefinedType if the class has no extends clause,
        // m_unknownType if an error occurred during resolution of the extends expression,
        // nullType if the extends expression is the null value, or
        // an object type with at least one construct signature.
        private /*HINT: how to return IObjectType?*/ IType GetBaseConstructorTypeOfClass(IInterfaceType typeArg)
        {
            return typeArg.GetOrSetResolvedBaseConstructorType(
                (checker: this, typeArg),
                (t, tuple) =>
                {
                    var @this = tuple.checker;
                    var type = tuple.typeArg;
                    var baseTypeNode = GetBaseTypeNodeOfClass(t);
                    if (baseTypeNode == null)
                    {
                        return @this.m_undefinedType.Cast<IType>();
                    }

                    if (!@this.PushTypeResolution(t, TypeSystemPropertyName.ResolvedBaseConstructorType))
                    {
                        // TODO: this is slight change in behavior.
                        // Original version returned uknownType here without storing it in a cache.
                        // None of the tests ever showed the difference between old and new implementation.
                        return @this.m_unknownType;
                    }

                    IType baseConstructorType = @this.CheckExpression(baseTypeNode.Expression);
                    if ((baseConstructorType.Flags & TypeFlags.ObjectType) != TypeFlags.None)
                    {
                        // Resolving the members of a class requires us to resolve the base class of that class.
                        // We force resolution here such that we catch circularities now.
                        @this.ResolveStructuredTypeMembers(baseConstructorType);
                    }

                    if (!@this.PopTypeResolution())
                    {
                        Contract.Assert(type.Symbol != null);
                        @this.Error(
                            type.Symbol.ValueDeclaration,
                            Errors.Zero_is_referenced_directly_or_indirectly_in_its_own_base_expression,
                            @this.SymbolToString(type.Symbol));

                        return @this.m_unknownType.Cast<IType>();
                    }

                    if (baseConstructorType != @this.m_unknownType && baseConstructorType != @this.m_nullType && !@this.IsConstructorType(baseConstructorType))
                    {
                        @this.Error(
                            baseTypeNode.Expression,
                            Errors.Type_0_is_not_a_constructor_function_type,
                            @this.TypeToString(baseConstructorType));

                        return @this.m_unknownType.Cast<IType>();
                    }

                    return baseConstructorType;
                });
        }

        /// <inheritdoc/>
        public IReadOnlyList<IType> GetBaseTypes(IInterfaceType typeArg)
        {
            // CodeContracts disallows to put preconditions into derived classes.
            // TODO: this should be changed to preconditions for interface members!
            Contract.Assert(typeArg != null);
            Contract.Assert(typeArg.Symbol != null);

            return typeArg.GetOrSetResolvedBaseTypes(
                (checker: this, typeArg),
                (interfaceType, tuple) =>
                {
                    var @this = tuple.checker;
                    var type = tuple.typeArg;
                    var isClass = type.Symbol.Flags & SymbolFlags.Class;
                    var isInterface = type.Symbol.Flags & SymbolFlags.Interface;
                    if (isClass == SymbolFlags.None && isInterface == SymbolFlags.None)
                    {
                        Contract.Assert(false, "type must be class or interface");
                    }

                    if (isClass != SymbolFlags.None)
                    {
                        return @this.ResolveBaseTypesOfClass(interfaceType);
                    }

                    if (isInterface != SymbolFlags.None)
                    {
                        return @this.ResolveBaseTypesOfInterface(interfaceType);
                    }

                    throw new InvalidOperationException("Unreachable code");
                });
        }

        private IReadOnlyList<IType> ResolveBaseTypesOfClass(IInterfaceType type)
        {
            var baseConstructorType = GetBaseConstructorTypeOfClass(type);
            if ((baseConstructorType.Flags & TypeFlags.ObjectType) == TypeFlags.None)
            {
                return s_emptyTypeList;
            }

            var baseTypeNode = GetBaseTypeNodeOfClass(type);
            IType baseType = null;
            var originalBaseType = baseConstructorType?.Symbol != null ? GetDeclaredTypeOfSymbol(baseConstructorType.Symbol) : null;

            if (baseConstructorType.Symbol != null && (baseConstructorType.Symbol.Flags & SymbolFlags.Class) != SymbolFlags.None &&
                AreAllOuterTypeParametersApplied(originalBaseType))
            {
                // When base constructor type is a class with no captured type arguments we know that the constructors all have the same type parameters as the
                // class and all return the instance type of the class. There is no need for further checks and we can apply the
                // type arguments in the same manner as a type reference to get the same error reporting experience.
                baseType = GetTypeFromClassOrInterfaceReference(baseTypeNode, baseConstructorType.Symbol);
            }
            else
            {
                // The class derives from a "class-like" constructor function, check that we have at least one construct signature
                // with a matching number of type parameters and use the return type of the first instantiated signature. Elsewhere
                // we check that all instantiated signatures return the same type.
                var constructors = GetInstantiatedConstructorsForTypeArguments(baseConstructorType, baseTypeNode.TypeArguments);
                if (constructors.Count == 0)
                {
                    Error(
                        baseTypeNode.Expression,
                        Errors.No_base_constructor_has_the_specified_number_of_type_arguments);

                    return s_emptyTypeList;
                }

                baseType = GetReturnTypeOfSignature(constructors[0]);
            }

            if (baseType == m_unknownType)
            {
                return s_emptyTypeList;
            }

            if ((GetTargetType(baseType).Flags & (TypeFlags.Class | TypeFlags.Interface)) == TypeFlags.None)
            {
                Error(
                    baseTypeNode.Expression,
                    Errors.Base_constructor_return_type_0_is_not_a_class_or_interface_type,
                    TypeToString(baseType));

                return s_emptyTypeList;
            }

            if (type == baseType || HasBaseType(baseType.Cast<IInterfaceType>(), type))
            {
                Error(
                    type.Symbol.ValueDeclaration,
                    Errors.Type_0_recursively_references_itself_as_a_base_type,
                    TypeToString(type, /*enclosingDeclaration*/ null, TypeFormatFlags.WriteArrayAsGenericType));

                return s_emptyTypeList;
            }

            var baseTypes = new List<IType> { baseType };
            return baseTypes;
        }

        private static bool AreAllOuterTypeParametersApplied(IType type)
        {
            // An unapplied type parameter has its symbol still the same as the matching argument symbol.
            // Since parameters are applied outer-to-inner, only the last outer parameter needs to be checked.
            var outerTypeParameters = type.As<IInterfaceType>()?.OuterTypeParameters;
            if (outerTypeParameters != null)
            {
                var last = outerTypeParameters.Count - 1;
                var typeArguments = type.Cast<ITypeReference>().TypeArguments; // TODO: Verify cast! (it will only work for IGenericType)

                return outerTypeParameters[last].Symbol != typeArguments[last].Symbol;
            }

            return true;
        }

        [NotNull]
        private IReadOnlyList<IType> ResolveBaseTypesOfInterface(IInterfaceType type)
        {
            Contract.Requires(type != null);
            Contract.Requires(type.Symbol != null);

            List<IType> baseTypes = null;
            foreach (var declaration in type.Symbol.DeclarationList)
            {
                var baseTypeNodes = (declaration.Kind == SyntaxKind.InterfaceDeclaration) ?
                                                GetInterfaceBaseTypeNodes(declaration.Cast<IInterfaceDeclaration>()) :
                                                null;

                if (baseTypeNodes != null)
                {
                    foreach (var node in baseTypeNodes)
                    {
                        IType baseType = GetTypeFromTypeNode(node);
                        if (baseType != m_unknownType)
                        {
                            if ((GetTargetType(baseType).Flags & (TypeFlags.Class | TypeFlags.Interface)) != TypeFlags.None)
                            {
                                if (type != baseType && !HasBaseType(baseType.Cast<IInterfaceType>(), type))
                                {
                                    LazyInitializer.EnsureInitialized(ref baseTypes, () => new List<IType>());
                                    baseTypes.Add(baseType);
                                }
                                else
                                {
                                    Error(
                                        declaration,
                                        Errors.Type_0_recursively_references_itself_as_a_base_type,
                                        TypeToString(type, /*enclosingDeclaration*/ null, TypeFormatFlags.WriteArrayAsGenericType));
                                }
                            }
                            else
                            {
                                Error(node, Errors.An_interface_may_only_extend_a_class_or_another_interface);
                            }
                        }
                    }
                }
            }

            return baseTypes ?? s_emptyTypeList;
        }

        // Returns true if the interface given by the symbol is free of "this" references. Specifically, the result is
        // true if the interface itself contains no references to "this" in its body, if all base types are interfaces,
        // and if none of the base interfaces have a "this" type.
        private bool IsIndependentInterface(ISymbol symbol)
        {
            foreach (var declaration in symbol.DeclarationList)
            {
                if (declaration.Kind == SyntaxKind.InterfaceDeclaration)
                {
                    if ((declaration.Flags & NodeFlags.ContainsThis) != NodeFlags.None)
                    {
                        return false;
                    }

                    var baseTypeNodes = GetInterfaceBaseTypeNodes(declaration.Cast<IInterfaceDeclaration>());
                    if (baseTypeNodes != null)
                    {
                        foreach (var node in baseTypeNodes)
                        {
                            if (IsSupportedExpressionWithTypeArguments(node))
                            {
                                var baseSymbol = ResolveEntityName(node.Expression, SymbolFlags.Type, /*ignoreErrors*/ true);

                                // TODO: this is circuit breaker to avoid stack overflow for one of the cases!
                                if (baseSymbol == symbol)
                                {
                                    continue;
                                }

                                if ((baseSymbol == null) ||
                                    (baseSymbol.Flags & SymbolFlags.Interface) == SymbolFlags.None ||
                                    (GetDeclaredTypeOfClassOrInterface(baseSymbol).ThisType != null))
                                {
                                    return false;
                                }
                            }
                        }
                    }
                }
            }

            return true;
        }

        private IInterfaceType GetDeclaredTypeOfClassOrInterface(ISymbol symbolArg)
        {
            return GetSymbolLinks(symbolArg).GetOrSetDeclaredType((checker: this, symbolArg), (links, tuple) =>
            {
                var @this = tuple.checker;
                var symbol = tuple.symbolArg;
                var kind = (symbol.Flags & SymbolFlags.Class) != SymbolFlags.None ? TypeFlags.Class : TypeFlags.Interface;

                IInterfaceType resultType = null;

                List<ITypeParameter> outerTypeParameters = @this.GetOuterTypeParametersOfClassOrInterface(symbol);
                List<ITypeParameter> localTypeParameters = @this.GetLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol);

                // A class or interface is generic if it has type parameters or a "this" type. We always give classes a "this" type
                // because it is not feasible to analyze all members to determine if the "this" type escapes the class (in particular,
                // property types inferred from initializers and method return types inferred from return statements are very hard
                // to exhaustively analyze). We give interfaces a "this" type if we can't definitely determine that they are free of
                // "this" references.
                if (outerTypeParameters != null ||
                    localTypeParameters != null ||
                    kind == TypeFlags.Class ||
                    !@this.IsIndependentInterface(symbol))
                {
                    resultType = @this.CreateGenericType(kind, symbol, outerTypeParameters, localTypeParameters);
                }
                else
                {
                    resultType = @this.CreateObjectType<InterfaceType>(kind, symbol);
                }

                // HINT: this code has slightly different structure compared to TypeScript implementation.
                // The reason is a necessity to create different types for the type local variable
                return resultType.Cast<IType>();
            }).Cast<IInterfaceType>();
        }

        private IType GetDeclaredTypeOfTypeAlias(ISymbol symbolArg)
        {
            return GetSymbolLinks(symbolArg).GetOrSetDeclaredType(
                (checker: this, symbolArg),
                (links, tuple) =>
                {
                    var @this = tuple.checker;
                    var symbol = tuple.symbolArg;

                    // Note that we use the links object as the target here because the symbol object is used as the unique
                    // identity for resolution of the 'type' property in SymbolLinks.
                    if (!@this.PushTypeResolution(symbol, TypeSystemPropertyName.DeclaredType))
                    {
                        return @this.m_unknownType;
                    }

                    var declaration = GetDeclarationOfKind(symbol, SyntaxKind.TypeAliasDeclaration).Cast<ITypeAliasDeclaration>();
                    IType type = @this.GetTypeFromTypeNode(declaration.Type);

                    if (@this.PopTypeResolution())
                    {
                        var typeParameters = links.GetOrSetTypeParameters(
                            (@this, symbol),
                            (lnks, tpl) => tpl.@this.GetLocalTypeParametersOfClassOrInterfaceOrTypeAlias(tpl.symbol));

                        if (typeParameters != null)
                        {
                            // Initialize the instantiation cache for generic type aliases. The declared type corresponds to
                            // an instantiation of the type alias with the type parameters supplied as type arguments.
                            links.GetOrSetInstantiations(
                                (typeParameters, type),
                                (lnks, tpl) =>
                                {
                                    var typeParams = tpl.typeParameters;
                                    var capturedType = tpl.type;
                                    return new Map<IType>()
                                    {
                                        [GetTypeListId(typeParams)] = capturedType,
                                    };
                                });
                        }
                    }
                    else
                    {
                        type = @this.m_unknownType;
                        @this.Error(
                            declaration.Name,
                            Errors.Type_alias_0_circularly_references_itself,
                            @this.SymbolToString(symbol));
                    }

                    return type;
                });
        }

        private IType GetDeclaredTypeOfEnum(ISymbol symbolArg)
        {
            return GetSymbolLinks(symbolArg).GetOrSetDeclaredType((checker: this, symbolArg), (links, tuple) =>
            {
                var @this = tuple.checker;
                var symbol = tuple.symbolArg;
                return @this.CreateType<ConcreteType>(TypeFlags.Enum, symbol);
            });
        }

        private ITypeParameter GetDeclaredTypeOfTypeParameter(ISymbol symbolArg)
        {
            return GetSymbolLinks(symbolArg).GetOrSetDeclaredType((checker: this, symbolArg), (links, tuple) =>
            {
                var @this = tuple.checker;
                var symbol = tuple.symbolArg;
                var type = @this.CreateType<TypeParameter>(TypeFlags.TypeParameter, symbol);

                if (GetDeclarationOfKind(symbol, SyntaxKind.TypeParameter).As<ITypeParameterDeclaration>()?.Constraint == null)
                {
                    type.Constraint = @this.m_noConstraintType;
                }

                return type;
            }).Cast<ITypeParameter>();
        }

        private IType GetDeclaredTypeOfAlias(ISymbol symbolArg)
        {
            return GetSymbolLinks(symbolArg).GetOrSetDeclaredType((checker: this, symbolArg), (links, tuple) =>
            {
                var @this = tuple.checker;
                var symbol = tuple.symbolArg;
                return @this.GetDeclaredTypeOfSymbol(@this.ResolveAlias(symbol));
            });
        }

        /// <inheritdoc/>
        public IType GetTypeOfSymbolAtLocation(ISymbol symbol, INode node)
        {
            return GetNarrowedTypeOfSymbol(symbol, node);
        }

        /// <inheritdoc/>
        public IType GetDeclaredTypeOfSymbol(ISymbol symbol)
        {
            Contract.Assert((symbol.Flags & SymbolFlags.Instantiated) == SymbolFlags.None);

            if ((symbol.Flags & (SymbolFlags.Class | SymbolFlags.Interface)) != SymbolFlags.None)
            {
                return GetDeclaredTypeOfClassOrInterface(symbol);
            }

            if ((symbol.Flags & SymbolFlags.TypeAlias) != SymbolFlags.None)
            {
                return GetDeclaredTypeOfTypeAlias(symbol);
            }

            if ((symbol.Flags & SymbolFlags.Enum) != SymbolFlags.None)
            {
                return GetDeclaredTypeOfEnum(symbol);
            }

            if ((symbol.Flags & SymbolFlags.TypeParameter) != SymbolFlags.None)
            {
                return GetDeclaredTypeOfTypeParameter(symbol);
            }

            if ((symbol.Flags & SymbolFlags.Alias) != SymbolFlags.None)
            {
                return GetDeclaredTypeOfAlias(symbol);
            }

            return m_unknownType;
        }

        // A type reference is considered independent if each type argument is considered independent.
        private bool IsIndependentTypeReference(ITypeReferenceNode node)
        {
            if (node.TypeArguments != null)
            {
                foreach (var typeNode in node.TypeArguments)
                {
                    if (!IsIndependentType(typeNode))
                    {
                        return false;
                    }
                }
            }

            return true;
        }

        // A type is considered independent if it the any, string, int, bool, symbol, or void keyword, a string
        // literal type, an array with an element type that is considered independent, or a type reference that is
        // considered independent.
        private bool IsIndependentType(ITypeNode node)
        {
            switch (node.Kind)
            {
                case SyntaxKind.AnyKeyword:
                case SyntaxKind.StringKeyword:
                case SyntaxKind.NumberKeyword:
                case SyntaxKind.BooleanKeyword:
                case SyntaxKind.SymbolKeyword:
                case SyntaxKind.VoidKeyword:
                case SyntaxKind.StringLiteralType:
                    return true;

                case SyntaxKind.ArrayType:
                    return IsIndependentType(node.Cast<IArrayTypeNode>().ElementType);

                case SyntaxKind.TypeReference:
                    return IsIndependentTypeReference(node.Cast<ITypeReferenceNode>());
            }

            return false;
        }

        // A variable-like declaration is considered independent (free of this references) if it has a type annotation
        // that specifies an independent type, or if it has no type annotation and no initializer (and thus of type any).
        private bool IsIndependentVariableLikeDeclaration(IVariableLikeDeclaration node)
        {
            // TODO: Verify order of logical operations matches intent
            return (node.Type != null && IsIndependentType(node.Type)) || (node.Type == null && node.Initializer == null);
        }

        // A function-like declaration is considered independent (free of this references) if it has a return type
        // annotation that is considered independent and if each parameter is considered independent.
        private bool IsIndependentFunctionLikeDeclaration(IFunctionLikeDeclaration node)
        {
            if (node.Kind != SyntaxKind.Constructor && (node.Type == null || !IsIndependentType(node.Type)))
            {
                return false;
            }

            foreach (var parameter in node.Parameters)
            {
                // HINT: This cast only works because the runtime class that implements IParameterDeclaration also implements IVariableLikeDeclaration
                if (!IsIndependentVariableLikeDeclaration(parameter.Cast<IVariableLikeDeclaration>()))
                {
                    return false;
                }
            }

            return true;
        }

        // Returns true if the class or interface member given by the symbol is free of "this" references. The
        // function may return false for symbols that are actually free of "this" references because it is not
        // feasible to perform a complete analysis in all cases. In particular, property members with types
        // inferred from their initializers and  members with inferred return types are conservatively
        // assumed not to be free of "this" references.
        private bool IsIndependentMember(ISymbol symbol)
        {
            if (symbol.DeclarationList.Count == 1)
            {
                var declaration = symbol.DeclarationList[0];
                if (declaration != null)
                {
                    switch (declaration.Kind)
                    {
                        case SyntaxKind.PropertyDeclaration:
                        case SyntaxKind.PropertySignature:
                            return IsIndependentVariableLikeDeclaration(declaration.Cast<IVariableLikeDeclaration>()); // TODO: Verify cast!
                        case SyntaxKind.MethodDeclaration:
                        case SyntaxKind.MethodSignature:
                        case SyntaxKind.Constructor:
                            return IsIndependentFunctionLikeDeclaration(declaration.Cast<IFunctionLikeDeclaration>());
                    }
                }
            }

            return false;
        }

        // The mappingThisOnly flag indicates that the only type parameter being mapped is "this". When the flag is true,
        // we check symbols to see if we can quickly conclude they are free of "this" references, thus needing no instantiation.
        private ISymbolTable CreateInstantiatedSymbolTable(IReadOnlyList<ISymbol> symbols, ITypeMapper mapper, bool mappingThisOnly)
        {
            ISymbolTable result = new SymbolTable();

            foreach (var symbol in symbols.AsStructEnumerable())
            {
                result[symbol.Name] = mappingThisOnly && IsIndependentMember(symbol)
                    ? symbol
                    : InstantiateSymbol(symbol, mapper);
            }

            return result;
        }

        private static void AddInheritedMembers(ISymbolTable symbols, IReadOnlyList<ISymbol> baseSymbols)
        {
            foreach (var s in baseSymbols.AsStructEnumerable())
            {
                if (!HasProperty(symbols, s.Name))
                {
                    symbols[s.Name] = s;
                }
            }
        }

        private IInterfaceTypeWithDeclaredMembers ResolveDeclaredMembers(IInterfaceType type)
        {
            if (type.Cast<IInterfaceTypeWithDeclaredMembers>().DeclaredProperties == null)
            {
                var symbol = type.Symbol;

                Contract.Assert(symbol != null);
                return type.ResolveDeclaredMembers(
                    new InterfaceDeclaredMembersData()
                    {
                        DeclaredProperties = GetNamedMembers(symbol.Members),
                        DeclaredCallSignatures = GetSignaturesOfSymbol(symbol.Members["__call"]),
                        DeclaredConstructSignatures = GetSignaturesOfSymbol(symbol.Members["__new"]),
                        DeclaredStringIndexType = GetIndexTypeOfSymbol(symbol, IndexKind.String),
                        DeclaredNumberIndexType = GetIndexTypeOfSymbol(symbol, IndexKind.Number),
                    });
            }

            return type.Cast<IInterfaceTypeWithDeclaredMembers>();
        }

        private /*HINT: IObjectType*/ IType GetTypeWithThisArgument(/*HINT: IObjectType*/ IType type, IType thisArgument = null)
        {
            if ((type.Flags & TypeFlags.Reference) != TypeFlags.None)
            {
                var typeReference = type.Cast<ITypeReference>();
                return CreateTypeReference(
                    typeReference.Target,
                    typeReference.TypeArguments.Concatenate(new[] { thisArgument ?? typeReference.Target.ThisType }));
            }

            return type;
        }

        private IResolvedType ResolveObjectTypeMembers(
            IObjectType type, IInterfaceTypeWithDeclaredMembers source, IReadOnlyList<ITypeParameter> typeParameters, IReadOnlyList<IType> typeArguments)
        {
            ITypeMapper mapper = s_identityMapper;
            var members = source.Symbol.Members;
            var callSignatures = source.DeclaredCallSignatures;
            var constructSignatures = source.DeclaredConstructSignatures;
            var stringIndexType = source.DeclaredStringIndexType;
            var numberIndexType = source.DeclaredNumberIndexType;

            if (!typeParameters.RangeEquals(typeArguments, 0, typeParameters.Count, EqualityComparer<IType>.Default))
            {
                mapper = CreateTypeMapper(typeParameters, typeArguments);
                members = CreateInstantiatedSymbolTable(source.DeclaredProperties, mapper, /*mappingThisOnly*/ typeParameters.Count == 1);
                callSignatures = InstantiateList(source.DeclaredCallSignatures, this, mapper, (s, @this, tm) => @this.InstantiateSignature(s, tm));
                constructSignatures = InstantiateList(source.DeclaredConstructSignatures, this, mapper, (s, @this, tm) => @this.InstantiateSignature(s, tm));
                stringIndexType = InstantiateType(source.DeclaredStringIndexType, mapper);
                numberIndexType = InstantiateType(source.DeclaredNumberIndexType, mapper);
            }

            var baseTypes = GetBaseTypes(source);
            if (baseTypes.Count != 0)
            {
                if (members == source.Symbol.Members)
                {
                    members = SymbolTable.Create(source.DeclaredProperties);
                }

                var thisArgument = typeArguments.LastOrUndefined();

                foreach (var baseType in baseTypes.AsStructEnumerable())
                {
                    var instantiatedBaseType = thisArgument != null ? GetTypeWithThisArgument(InstantiateType(baseType, mapper), thisArgument) : baseType;
                    AddInheritedMembers(members, GetPropertiesOfObjectType(instantiatedBaseType));
                    callSignatures = callSignatures.Concatenate(GetSignaturesOfType(instantiatedBaseType, SignatureKind.Call));
                    constructSignatures = constructSignatures.Concatenate(GetSignaturesOfType(instantiatedBaseType, SignatureKind.Construct));
                    stringIndexType = stringIndexType ?? GetIndexTypeOfType(instantiatedBaseType, IndexKind.String);
                    numberIndexType = numberIndexType ?? GetIndexTypeOfType(instantiatedBaseType, IndexKind.Number);
                }
            }

            return SetObjectTypeMembers(type, members, callSignatures, constructSignatures, stringIndexType, numberIndexType);
        }

        private IResolvedType ResolveClassOrInterfaceMembers(IInterfaceType type)
        {
            return ResolveObjectTypeMembers(type, ResolveDeclaredMembers(type), EmptyArray<ITypeParameter>(), EmptyArray<IType>());
        }

        private IResolvedType ResolveTypeReferenceMembers(ITypeReference type)
        {
            var source = ResolveDeclaredMembers(type.Target);
            var typeParameters = source.TypeParameters.Concatenate(source.ThisType);
            var typeArguments = (type.TypeArguments != null) && (type.TypeArguments.Count == typeParameters.Count)
                ? type.TypeArguments
                : type.TypeArguments.Concatenate(type);

            return ResolveObjectTypeMembers(type, source, typeParameters, typeArguments);
        }

        private static Signature CreateSignature(
            ISignatureDeclaration declaration,
            IReadOnlyList<ITypeParameter> typeParameters,
            IReadOnlyList<ISymbol> parameters,
            IType resolvedReturnType,
            int minArgumentCount,
            bool hasRestParameter,
            bool hasStringLiterals,
            List<ISignature> signatures = null)
        {
            var sig = Signature.Create(signatures);
            sig.Declaration = declaration;
            sig.TypeParameters = typeParameters;
            sig.Parameters = parameters;
            sig.ResolvedReturnType = resolvedReturnType;
            sig.MinArgumentCount = minArgumentCount;
            sig.HasRestParameter = hasRestParameter;
            sig.HasStringLiterals = hasStringLiterals;

            return sig;
        }

        private static Signature CloneSignature(ISignature sig, List<ISignature> signatures = null)
        {
            return CreateSignature(
                sig.Declaration,
                sig.TypeParameters,
                sig.Parameters,
                sig.ResolvedReturnType,
                sig.MinArgumentCount,
                sig.HasRestParameter,
                sig.HasStringLiterals,
                signatures);
        }

        private IReadOnlyList<ISignature> GetDefaultConstructSignatures(IInterfaceType classType)
        {
            var baseConstructorType = GetBaseConstructorTypeOfClass(classType);
            var baseSignatures = GetSignaturesOfType(baseConstructorType, SignatureKind.Construct);
            if (baseSignatures.Count == 0)
            {
                return new List<ISignature>
                {
                    CreateSignature(
                        null,
                        classType.LocalTypeParameters,
                        CollectionUtilities.EmptyArray<ISymbol>(),
                        classType,
                        0,
                        /*hasRestParameter*/ false,
                        /*hasStringLiterals*/ false),
                };
            }

            var baseTypeNode = GetBaseTypeNodeOfClass(classType);
            var typeArguments = baseTypeNode.TypeArguments?.Select(t => GetTypeFromTypeNode(t)).ToList();
            var typeArgCount = typeArguments?.Count ?? 0;

            List<ISignature> result = new List<ISignature>(baseSignatures.Count);
            foreach (var baseSig in baseSignatures.AsStructEnumerable())
            {
                var typeParamCount = baseSig.TypeParameters?.Count ?? 0;
                if (typeParamCount == typeArgCount)
                {
                    var sig = typeParamCount != 0
                        ? GetSignatureInstantiation(baseSig, typeArguments)
                        : CloneSignature(baseSig);

                    sig.TypeParameters = classType.LocalTypeParameters;
                    sig.ResolvedReturnType = classType;
                    result.Add(sig);
                }
            }

            return result;
        }

        private ISymbolTable CreateTupleTypeMemberSymbols(IReadOnlyList<IType> memberTypes)
        {
            ISymbolTable members = new SymbolTable();

            for (var i = 0; i < memberTypes.Count; i++)
            {
                var symbolData = new SymbolData
                {
                    Type = memberTypes[i],
                };
                var symbol = CreateTransientSymbol(
                    SymbolFlags.Property | SymbolFlags.Transient,
                    i.ToString(),
                    ref symbolData);
                members[i.ToString()] = symbol;
            }

            return members;
        }

        private static PooledObjectWrapper<List<IType>> ListOf(IType value1, IType value2)
        {
            var result = ObjectPools.TypeResolutionPool.GetInstance();
            result.Instance.Add(value1);
            result.Instance.Add(value2);
            return result;
        }

        private IResolvedType ResolveTupleTypeMembers(ITupleType type)
        {
            IType arrayElementType = GetUnionType(type.ElementTypes, /*noSubtypeReduction*/ true);

            // Make the tuple type itself the 'this' type by including an extra type argument
            var arrayType = ResolveStructuredTypeMembers(
                CreateTypeFromGenericGlobalType(m_globalArrayType, new List<IType>() { arrayElementType, type }));

            var members = CreateTupleTypeMemberSymbols(type.ElementTypes);
            AddInheritedMembers(members, arrayType.Properties);
            return SetObjectTypeMembers(
                type,
                members,
                arrayType.CallSignatures,
                arrayType.ConstructSignatures,
                arrayType.StringIndexType,
                arrayType.NumberIndexType);
        }

        private ISignature FindMatchingSignature(IReadOnlyList<ISignature> signatureList, ISignature signature, bool partialMatch,
            bool ignoreReturnTypes)
        {
            foreach (var s in signatureList.AsStructEnumerable())
            {
                if (CompareSignaturesIdentical(s, signature, partialMatch, ignoreReturnTypes, CompareTypesIdentical) != Ternary.False)
                {
                    return s;
                }
            }

            return null;
        }

        private List<ISignature> FindMatchingSignatures(List<IReadOnlyList<ISignature>> signatureLists, ISignature signature, int listIndex)
        {
            if (signature.TypeParameters != null)
            {
                // We require an exact match for generic signatures, so we only return signatures from the first
                // signature list and only if they have exact matches in the other signature lists.
                if (listIndex > 0)
                {
                    return null;
                }

                for (var i = 1; i < signatureLists.Count; i++)
                {
                    if (FindMatchingSignature(signatureLists[i], signature, /*partialMatch*/ false, /*ignoreReturnTypes*/ false) == null)
                    {
                        return null;
                    }
                }

                return new List<ISignature> { signature };
            }

            List<ISignature> result = null;
            for (var i = 0; i < signatureLists.Count; i++)
            {
                // Allow matching non-generic signatures to have excess parameters and different return types
                var match = i == listIndex
                    ? signature
                    : FindMatchingSignature(signatureLists[i], signature, /*partialMatch*/ true, /*ignoreReturnTypes*/ true);
                if (match == null)
                {
                    return null;
                }

                if (result?.Contains(match) != true)
                {
                    result = result ?? new List<ISignature>();
                    result.Add(match);
                }
            }

            return result;
        }

        // The signatures of a union type are those signatures that are present in each of the constituent types.
        // Generic signatures must match exactly, but non-generic signatures are allowed to have extra optional
        // parameters and may differ in return types. When signatures differ in return types, the resulting return
        // type is the union of the constituent return types.
        private IReadOnlyList<ISignature> GetUnionSignatures(List<IType> types, SignatureKind kind)
        {
            var signatureLists = types.Map(t => GetSignaturesOfType(t, kind));

            List<ISignature> result = null;
            for (var i = 0; i < signatureLists.Count; i++)
            {
                foreach (var signature in signatureLists[i].AsStructEnumerable())
                {
                    // Only process signatures with parameter lists that aren't already in the result list
                    if (result == null ||
                        FindMatchingSignature(result, signature, /*partialMatch*/ false, /*ignoreReturnTypes*/ true) == null)
                    {
                        var unionSignatures = FindMatchingSignatures(signatureLists, signature, i);
                        if (unionSignatures != null)
                        {
                            var s = signature;

                            // Union the result types when more than one signature matches
                            if (unionSignatures.Count > 1)
                            {
                                var clonedSignature = CloneSignature(signature, unionSignatures);

                                // Clear resolved return type we possibly got from cloneSignature
                                clonedSignature.ResolvedReturnType = null;

                                s = clonedSignature;
                            }

                            result = result ?? new List<ISignature>();
                            result.Add(s);
                        }
                    }
                }
            }

            return (IReadOnlyList<ISignature>)result ?? EmptyArray<ISignature>();
        }

        private IType GetUnionIndexType(IReadOnlyList<IType> types, IndexKind kind)
        {
            List<IType> indexTypes = null;
            foreach (var type in types.AsStructEnumerable())
            {
                var indexType = GetIndexTypeOfType(type, kind);
                if (indexType == null)
                {
                    return null;
                }

                indexTypes = indexTypes ?? new List<IType>();
                indexTypes.Add(indexType);
            }

            return GetUnionType(indexTypes);
        }

        private IResolvedType ResolveUnionTypeMembers(IUnionType type)
        {
            // The members and properties collections are empty for union types. To get all properties of a union
            // type use GetPropertiesOfType (only the language service uses this).
            var callSignatures = GetUnionSignatures(type.Types, SignatureKind.Call);
            var constructSignatures = GetUnionSignatures(type.Types, SignatureKind.Construct);
            var stringIndexType = GetUnionIndexType(type.Types, IndexKind.String);
            var numberIndexType = GetUnionIndexType(type.Types, IndexKind.Number);

            return SetObjectTypeMembers(
                type.Cast<IObjectType>(),
                s_emptySymbols,
                callSignatures,
                constructSignatures,
                stringIndexType,
                numberIndexType);
        }

        private IType IntersectTypes(IType type1, IType type2)
        {
            return type1 == null ? type2 : type2 == null ? type1 : GetIntersectionType(new List<IType>() { type1, type2 });
        }

        private IResolvedType ResolveIntersectionTypeMembers(IIntersectionType type)
        {
            // The members and properties collections are empty for intersection types. To get all properties of an
            // intersection type use GetPropertiesOfType (only the language service uses this).
            IEnumerable<ISignature> callSignatures = s_emptySignatureEnumerable;
            IEnumerable<ISignature> constructSignatures = s_emptySignatureEnumerable;
            IType stringIndexType = null;
            IType intIndexType = null;

            foreach (var t in type.Types)
            {
                callSignatures = callSignatures.Concatenate(GetSignaturesOfType(t, SignatureKind.Call));
                constructSignatures = constructSignatures.Concatenate(GetSignaturesOfType(t, SignatureKind.Construct));
                stringIndexType = IntersectTypes(stringIndexType, GetIndexTypeOfType(t, IndexKind.String));
                intIndexType = IntersectTypes(intIndexType, GetIndexTypeOfType(t, IndexKind.Number));
            }

            return SetObjectTypeMembers(
                type.Cast<IObjectType>(),
                s_emptySymbols,
                callSignatures,
                constructSignatures,
                stringIndexType,
                intIndexType);
        }

        private IResolvedType ResolveAnonymousTypeMembers([NotNull]IAnonymousType type)
        {
            var symbol = type.Symbol;
            if (type.Target != null)
            {
                var members = CreateInstantiatedSymbolTable(
                    GetPropertiesOfObjectType(type.Target),
                    type.Mapper,
                    /*mappingThisOnly*/ false);

                var callSignatures = InstantiateList(GetSignaturesOfType(type.Target, SignatureKind.Call), this, type.Mapper, (s, @this, m) => @this.InstantiateSignature(s, m));
                var constructSignatures = InstantiateList(GetSignaturesOfType(type.Target, SignatureKind.Construct), this, type.Mapper, (s, @this, m) => @this.InstantiateSignature(s, m));
                var stringIndexType = InstantiateType(GetIndexTypeOfType(type.Target, IndexKind.String), type.Mapper);
                var numberIndexType = InstantiateType(GetIndexTypeOfType(type.Target, IndexKind.Number), type.Mapper);
                SetObjectTypeMembers(type, members, callSignatures, constructSignatures, stringIndexType, numberIndexType);
            }
            else if ((symbol.Flags & SymbolFlags.TypeLiteral) != SymbolFlags.None)
            {
                var members = symbol.Members;

                var callSignatures = GetSignaturesOfSymbol(members["__call"]);
                var constructSignatures = GetSignaturesOfSymbol(members["__new"]);
                var stringIndexType = GetIndexTypeOfSymbol(symbol, IndexKind.String);
                var numberIndexType = GetIndexTypeOfSymbol(symbol, IndexKind.Number);
                SetObjectTypeMembers(type, members, callSignatures, constructSignatures, stringIndexType, numberIndexType);
            }
            else
            {
                // Combinations of function, class, enum and module
                var members = s_emptySymbols;
                IReadOnlyList<ISignature> constructSignatures = s_emptySignatureList;

                if ((symbol.Flags & SymbolFlags.HasExports) != SymbolFlags.None)
                {
                    members = GetExportsOfSymbol(symbol);
                }

                if ((symbol.Flags & SymbolFlags.Class) != SymbolFlags.None)
                {
                    var classType = GetDeclaredTypeOfClassOrInterface(symbol);
                    constructSignatures = GetSignaturesOfSymbol(symbol.Members["__constructor"]);
                    if (constructSignatures.Count == 0)
                    {
                        constructSignatures = GetDefaultConstructSignatures(classType);
                    }

                    var baseConstructorType = GetBaseConstructorTypeOfClass(classType);
                    if ((baseConstructorType.Flags & TypeFlags.ObjectType) != TypeFlags.None)
                    {
                        members = Create(GetNamedMembers(members));
                        AddInheritedMembers(members, GetPropertiesOfObjectType(baseConstructorType));
                    }
                }

                var numberIndexType = (symbol.Flags & SymbolFlags.Enum) != SymbolFlags.None ? m_stringType : null;

                IReadOnlyList<ISignature> signatures = s_emptySignatureList;

                if ((symbol.Flags & (SymbolFlags.Function | SymbolFlags.Method)) != SymbolFlags.None)
                {
                    // The order of resolution was changed intentionally to avoid double mutation.
                    // TODO: tracking work item - #961302
                    signatures = GetSignaturesOfSymbol(symbol);
                }

                var result = SetObjectTypeMembers(type, members, signatures, constructSignatures, null, numberIndexType);

                // We resolve the members before computing the signatures because a signature may use
                // typeof with a qualified name expression that circularly references the type we are
                // in the process of resolving (see issue #6072). The temporarily empty signature list
                // will never be observed because a qualified name can't reference signatures.
                if ((symbol.Flags & (SymbolFlags.Function | SymbolFlags.Method)) != SymbolFlags.None)
                {
                    // This was commented out intentionally to avoid race condition.
                    // See #961302 and comment above.
                    // type.Resolve(callSignatures: GetSignaturesOfSymbol(symbol));
                }

                return result;
            }

            return type.Cast<IResolvedType>();
        }

        private IResolvedType ResolveStructuredTypeMembers(/*HINT: IObjectType*/ IType type)
        {
            if (type.As<IResolvedType>()?.Members == null)
            {
                if ((type.Flags & TypeFlags.Reference) != TypeFlags.None)
                {
                    return ResolveTypeReferenceMembers(type.Cast<ITypeReference>());
                }

                if ((type.Flags & (TypeFlags.Class | TypeFlags.Interface)) != TypeFlags.None)
                {
                    return ResolveClassOrInterfaceMembers(type.Cast<IInterfaceType>());
                }

                if ((type.Flags & TypeFlags.Anonymous) != TypeFlags.None)
                {
                    return ResolveAnonymousTypeMembers(type.Cast<IAnonymousType>());
                }

                if ((type.Flags & TypeFlags.Tuple) != TypeFlags.None)
                {
                    return ResolveTupleTypeMembers(type.Cast<ITupleType>());
                }

                if ((type.Flags & TypeFlags.Union) != TypeFlags.None)
                {
                    return ResolveUnionTypeMembers(type.Cast<IUnionType>());
                }

                if ((type.Flags & TypeFlags.Intersection) != TypeFlags.None)
                {
                    return ResolveIntersectionTypeMembers(type.Cast<IIntersectionType>());
                }
            }

            return type.Cast<IResolvedType>();
        }

        /// <summary>
        /// Return properties of an object type or an empty array for other types
        /// </summary>
        [NotNull]
        private IReadOnlyList<ISymbol> GetPropertiesOfObjectType([NotNull]IType type)
        {
            if ((type.Flags & TypeFlags.ObjectType) != TypeFlags.None)
            {
                return ResolveStructuredTypeMembers(type).Properties;
            }

            return CollectionUtilities.EmptyArray<ISymbol>();
        }

        /// <summary>
        /// If the given type is an object type and that type has a property by the given name,
        /// return the symbol for that property. Otherwise return null.
        /// </summary>
        [CanBeNull]
        private ISymbol GetPropertyOfObjectType(IType type, string name)
        {
            if ((type.Flags & TypeFlags.ObjectType) != TypeFlags.None)
            {
                var resolved = ResolveStructuredTypeMembers(type);
                if (HasProperty(resolved.Members, name))
                {
                    var symbol = resolved.Members[name];
                    if (SymbolIsValue(symbol))
                    {
                        return symbol;
                    }
                }
            }

            return null;
        }

        private IReadOnlyList<ISymbol> GetPropertiesOfUnionOrIntersectionType(IUnionOrIntersectionType type)
        {
            foreach (var current in type.Types)
            {
                foreach (var prop in GetPropertiesOfType(current).AsStructEnumerable())
                {
                    GetPropertyOfUnionOrIntersectionType(type, prop.Name);
                }

                // The properties of a union type are those that are present in all constituent types, so
                // we only need to check the properties of the first type
                if ((type.Flags & TypeFlags.Union) != TypeFlags.None)
                {
                    break;
                }
            }

            return type.ResolvedProperties != null ? SymbolsToArray(type.ResolvedProperties) : CollectionUtilities.EmptyArray<ISymbol>();
        }

        /// <inheritdoc/>
        public IReadOnlyList<ISymbol> GetPropertiesOfType(IType type)
        {
            type = GetApparentType(type);
            return (type.Flags & TypeFlags.UnionOrIntersection) != TypeFlags.None
                ? GetPropertiesOfUnionOrIntersectionType(type.Cast<IUnionOrIntersectionType>())
                : GetPropertiesOfObjectType(type);
        }

        /// <summary>
        /// The apparent type of a type parameter is the base constraint instantiated with the type parameter
        /// as the type argument for the 'this' type.
        /// </summary>
        private IType GetApparentTypeOfTypeParameter(ITypeParameter type)
        {
            return type.GetOrSetResolvedApparentType(
                this,
                (capturedType, @this) =>
                {
                    IType constraintType = @this.GetConstraintOfTypeParameter(capturedType);
                    while (constraintType != null && (constraintType.Flags & TypeFlags.TypeParameter) != TypeFlags.None)
                    {
                        constraintType = @this.GetConstraintOfTypeParameter(constraintType.Cast<ITypeParameter>());
                    }

                    return @this.GetTypeWithThisArgument(constraintType ?? @this.m_emptyObjectType, capturedType);
                });
        }

        /// <summary>
        /// For a type parameter, return the base constraint of the type parameter. For the string, number,
        /// boolean, and symbol primitive types, return the corresponding object types. Otherwise return the
        /// type itself. Note that the apparent type of a union type is the union type itself.
        /// </summary>
        private IType GetApparentType(IType type)
        {
            if ((type.Flags & TypeFlags.TypeParameter) != TypeFlags.None)
            {
                type = GetApparentTypeOfTypeParameter(type.Cast<ITypeParameter>());
            }

            if ((type.Flags & TypeFlags.StringLike) != TypeFlags.None)
            {
                type = m_globalStringType;
            }
            else if ((type.Flags & TypeFlags.NumberLike) != TypeFlags.None)
            {
                type = m_globalNumberType;
            }
            else if ((type.Flags & TypeFlags.Boolean) != TypeFlags.None)
            {
                type = m_globalBooleanType;
            }
            else if ((type.Flags & TypeFlags.EsSymbol) != TypeFlags.None)
            {
                type = m_globalEsSymbolType;
            }

            return type;
        }

        private ISymbol CreateUnionOrIntersectionProperty(IUnionOrIntersectionType containingType, string name)
        {
            var types = containingType.Types;
            List<ISymbol> props = null;

            // Flags we want to propagate to the result if they exist in all source symbols
            var commonFlags = (containingType.Flags & TypeFlags.Intersection) != TypeFlags.None
                ? SymbolFlags.Optional
                : SymbolFlags.None;

            foreach (var current in types)
            {
                var type = GetApparentType(current);
                if (type != m_unknownType)
                {
                    var prop = GetPropertyOfType(type, name);
                    if (prop != null &&
                        (GetDeclarationFlagsFromSymbol(prop) & (NodeFlags.Private | NodeFlags.Protected)) == NodeFlags.None)
                    {
                        commonFlags &= prop.Flags;
                        if (props == null)
                        {
                            props = new List<ISymbol> { prop };
                        }
                        else if (!props.Contains(prop))
                        {
                            props.Add(prop);
                        }
                    }
                    else if ((containingType.Flags & TypeFlags.Union) != TypeFlags.None)
                    {
                        // A union type requires the property to be present in all constituent types
                        return null;
                    }
                }
            }

            if (props == null)
            {
                return null;
            }

            if (props.Count == 1)
            {
                return props[0];
            }

            List<IType> propTypes = new List<IType>();
            List<IDeclaration> declarations = new List<IDeclaration>();
            foreach (var prop in props)
            {
                declarations.AddRange(prop.DeclarationList);

                propTypes.Add(GetTypeOfSymbol(prop));
            }

            var symbolData = new SymbolData
            {
                ContainingType = containingType,
                Declarations = declarations,
                Type = (containingType.Flags & TypeFlags.Union) != TypeFlags.None ? GetUnionType(propTypes) : GetIntersectionType(propTypes),
            };
            var result = CreateTransientSymbol(
                            SymbolFlags.Property |
                            SymbolFlags.Transient |
                            SymbolFlags.SyntheticProperty |
                            commonFlags,
                            name,
                            ref symbolData);

            return result;
        }

        private ISymbol GetPropertyOfUnionOrIntersectionType(IUnionOrIntersectionType type, string name)
        {
            lock (type)
            {
                if (type.ResolvedProperties == null)
                {
                    type.ResolvedProperties = new SymbolTable();
                }

                if (HasProperty(type.ResolvedProperties, name))
                {
                    return type.ResolvedProperties[name];
                }
            }

            var property = CreateUnionOrIntersectionProperty(type, name);
            if (property != null)
            {
                lock (type)
                {
                    type.ResolvedProperties[name] = property;
                }
            }

            return property;
        }

        /// <summary>
        /// Return the symbol for the property with the given name in the given type. Creates synthetic union properties when
        /// necessary, maps primitive types and type parameters are to their apparent types, and augments with properties from
        /// Object and Function as appropriate.
        /// </summary>
        public ISymbol GetPropertyOfType(IType type, string name)
        {
            Contract.Assert(name != null);

            type = GetApparentType(type);
            if ((type.Flags & TypeFlags.ObjectType) != TypeFlags.None)
            {
                var resolved = ResolveStructuredTypeMembers(type);

                ISymbol symbol;
                if (TryGetProperty(resolved.Members, name, out symbol))
                {
                    if (SymbolIsValue(symbol))
                    {
                        return symbol;
                    }
                }

                if (resolved == m_anyFunctionType ||
                    resolved.CallSignatures.Count != 0 ||
                    resolved.ConstructSignatures.Count != 0)
                {
                    symbol = GetPropertyOfObjectType(m_globalFunctionType, name);
                    if (symbol != null)
                    {
                        return symbol;
                    }
                }

                return GetPropertyOfObjectType(m_globalObjectType, name);
            }

            if ((type.Flags & TypeFlags.UnionOrIntersection) != TypeFlags.None)
            {
                return GetPropertyOfUnionOrIntersectionType(type.Cast<IUnionOrIntersectionType>(), name);
            }

            return null;
        }

        private IReadOnlyList<ISignature> GetSignaturesOfStructuredType(IType type, SignatureKind kind)
        {
            if ((type.Flags & TypeFlags.StructuredType) != TypeFlags.None)
            {
                var resolved = ResolveStructuredTypeMembers(type);
                return kind == SignatureKind.Call ? resolved.CallSignatures : resolved.ConstructSignatures;
            }

            return s_emptySignatureList;
        }

        /// <summary>
        /// Return the signatures of the given kind in the given type. Creates synthetic union signatures when necessary and
        /// maps primitive types and type parameters are to their apparent types.
        /// </summary>
        public IReadOnlyList<ISignature> GetSignaturesOfType(IType type, SignatureKind kind)
        {
            return GetSignaturesOfStructuredType(GetApparentType(type), kind);
        }

        private IType GetIndexTypeOfStructuredType(IType type, IndexKind kind)
        {
            if ((type.Flags & TypeFlags.StructuredType) != TypeFlags.None)
            {
                var resolved = ResolveStructuredTypeMembers(type);
                return kind == IndexKind.String ? resolved.StringIndexType : resolved.NumberIndexType;
            }

            return null;
        }

        /// <summary>
        /// Return the index type of the given kind in the given type. Creates synthetic union index types when necessary and
        /// maps primitive types and type parameters are to their apparent types.
        /// </summary>
        public IType GetIndexTypeOfType(IType type, IndexKind kind)
        {
            return GetIndexTypeOfStructuredType(GetApparentType(type), kind);
        }

        /// <summary>
        /// Return list of type parameters with duplicates removed (duplicate identifier errors are generated in the actual
        /// type checking functions).
        /// </summary>
        private List<ITypeParameter> GetTypeParametersFromDeclaration([NotNull] NodeArray<ITypeParameterDeclaration> typeParameterDeclarations)
        {
            List<ITypeParameter> result = new List<ITypeParameter>();
            foreach (var node in typeParameterDeclarations)
            {
                var tp = GetDeclaredTypeOfTypeParameter(node.Symbol);
                if (!result.Contains(tp))
                {
                    result.Add(tp);
                }
            }

            return result;
        }

        [NotNull]
        private static IReadOnlyList<ISymbol> SymbolsToArray(ISymbolTable symbols)
        {
            List<ISymbol> result = null;
            foreach (var kvp in symbols)
            {
                var id = kvp.Key;
                if (!IsReservedMemberName(id))
                {
                    result = result ?? new List<ISymbol>();
                    result.Add(symbols[id]);
                }
            }

            return (IReadOnlyList<ISymbol>)result ?? CollectionUtilities.EmptyArray<ISymbol>();
        }

        /// <inheritdoc/>
        public bool IsOptionalParameter(IParameterDeclaration node)
        {
            if (HasQuestionToken(node))
            {
                return true;
            }

            if (node.Initializer != null)
            {
                var signatureDeclaration = node.Parent.Cast<ISignatureDeclaration>();
                var signature = GetSignatureFromDeclaration(signatureDeclaration);
                var parameterIndex = IndexOf(signatureDeclaration.Parameters, node);

                Contract.Assert(parameterIndex >= 0);

                return parameterIndex >= signature.MinArgumentCount;
            }

            return false;
        }

        private /*HINT: IIdentifierTypePredicate | IThisTypePredicate*/ ITypePredicate CreateTypePredicateFromTypePredicateNode(ITypePredicateNode node)
        {
            if (node.ParameterName.Kind == SyntaxKind.Identifier)
            {
                var parameterName = node.ParameterName.As<IIdentifier>();

                return new IdentifierTypePredicate()
                {
                    Kind = TypePredicateKind.Identifier,
                    ParameterName = parameterName?.Text,
                    ParameterIndex =
                        parameterName != null
                        ? (int?)GetTypePredicateParameterIndex(node.Parent.Cast<ISignatureDeclaration>().Parameters, parameterName)
                        : null,
                    Type = GetTypeFromTypeNode(node.Type),
                };
            }

            return new ThisTypePredicate()
            {
                Kind = TypePredicateKind.This,
                Type = GetTypeFromTypeNode(node.Type),
            };
        }

        /// <inheritdoc/>
        public ISignature GetSignatureFromDeclaration(ISignatureDeclaration declarationArg)
        {
            return GetNodeLinks(declarationArg).GetOrSetResolvedSignature((checker: this, declarationArg), (links, tuple) =>
            {
                var @this = tuple.checker;
                var declaration = tuple.declarationArg;
                var classType = declaration.Kind == SyntaxKind.Constructor
                                    ? @this.GetDeclaredTypeOfClassOrInterface(@this.GetMergedSymbol(declaration.Parent.Cast<IClassDeclaration>().Symbol))
                                    : null;

                List<ISymbol> parameters = null;
                var hasStringLiterals = false;
                var minArgumentCount = -1;
                for (int i = 0, n = declaration.Parameters.Count; i < n; i++)
                {
                    var param = declaration.Parameters[i];
                    var paramSymbol = param.Symbol;

                    // Include parameter symbol instead of property symbol in the signature
                    if (paramSymbol != null &&
                        (paramSymbol.Flags & SymbolFlags.Property) != SymbolFlags.None &&
                        IsBindingPattern(param.Name) == null)
                    {
                        var resolvedSymbol = @this.ResolveName(
                            param,
                            paramSymbol.Name,
                            SymbolFlags.Value,
                            null,
                            (string)null);
                        paramSymbol = resolvedSymbol;
                    }

                    parameters = parameters ?? new List<ISymbol>();
                    parameters.Add(paramSymbol);

                    if (param.Type?.Kind == SyntaxKind.StringLiteralType)
                    {
                        hasStringLiterals = true;
                    }

                    if (param.Initializer != null || param.QuestionToken || param.DotDotDotToken)
                    {
                        if (minArgumentCount < 0)
                        {
                            minArgumentCount = i;
                        }
                    }
                    else
                    {
                        // If we see any required parameters, it means the prior ones were not in fact optional.
                        minArgumentCount = -1;
                    }
                }

                if (minArgumentCount < 0)
                {
                    minArgumentCount = declaration.Parameters.Length;
                }

                IType returnType = null;
                if (classType != null)
                {
                    returnType = classType;
                }
                else if (declaration.Type != null)
                {
                    returnType = @this.GetTypeFromTypeNode(declaration.Type);
                }
                else
                {
                    // TypeScript 1.0 spec (April 2014):
                    // If only one accessor includes a type annotation, the other behaves as if it had the same type annotation.
                    if (declaration.Kind == SyntaxKind.GetAccessor && !HasDynamicName(declaration))
                    {
                        var setter = GetDeclarationOfKind(declaration.Symbol, SyntaxKind.SetAccessor)?.Cast<IAccessorDeclaration>();
                        returnType = @this.GetAnnotatedAccessorType(setter);
                    }

                    if (returnType == null && NodeIsMissing(declaration.Cast<IFunctionLikeDeclaration>().Body))
                    {
                        returnType = @this.m_anyType;
                    }
                }

                // TODO: Simplify
                var typeParameters = classType != null
                    ? classType.LocalTypeParameters
                    : declaration.TypeParameters != null
                        ? @this.GetTypeParametersFromDeclaration(declaration.TypeParameters)
                        : null;

                return CreateSignature(
                    declaration,
                    typeParameters,
                    (IReadOnlyList<ISymbol>)parameters ?? CollectionUtilities.EmptyArray<ISymbol>(),
                    returnType,
                    minArgumentCount,
                    HasRestParameter(declaration),
                    hasStringLiterals);
            });
        }

        private List<ISignature> GetSignaturesOfSymbol(ISymbol symbol)
        {
            if (symbol == null)
            {
                return s_emptySignatureList;
            }

            List<ISignature> result = new List<ISignature>();
            for (int i = 0, len = symbol.DeclarationList.Count; i < len; i++)
            {
                var node = symbol.DeclarationList[i];
                switch (node.Kind)
                {
                    case SyntaxKind.FunctionType:
                    case SyntaxKind.ConstructorType:
                    case SyntaxKind.FunctionDeclaration:
                    case SyntaxKind.MethodDeclaration:
                    case SyntaxKind.MethodSignature:
                    case SyntaxKind.Constructor:
                    case SyntaxKind.CallSignature:
                    case SyntaxKind.ConstructSignature:
                    case SyntaxKind.IndexSignature:
                    case SyntaxKind.GetAccessor:
                    case SyntaxKind.SetAccessor:
                    case SyntaxKind.FunctionExpression:
                    case SyntaxKind.ArrowFunction:
                        // Don't include signature if node is the implementation of an overloaded function. A node is considered
                        // an implementation node if it has a body and the previous node is of the same kind and immediately
                        // precedes the implementation node (i.e., has the same parent and ends where the implementation starts).
                        if (i > 0 && node.Cast<IFunctionLikeDeclaration>().Body != null)
                        {
                            var previous = symbol.DeclarationList[i - 1];
                            if (node.Parent.ResolveUnionType() == previous.Parent.ResolveUnionType() &&
                                node.Kind == previous.Kind &&
                                node.Pos == previous.End)
                            {
                                break;
                            }
                        }

                        result.Add(GetSignatureFromDeclaration(node.Cast<ISignatureDeclaration>()));
                        break;
                }
            }

            return result;
        }

        private IType ResolveModuleByLiteral(IStringLiteral name)
        {
            // Don't need to report error about unresolved module, because
            // when module resolution will fail for DScript file specific error would be emitted.
            var moduleSym = ResolveExternalModuleName(name, name);
            if (moduleSym != null)
            {
                var resolvedModuleSymbol = ResolveExternalModuleSymbol(moduleSym);
                if (resolvedModuleSymbol != null)
                {
                    return GetTypeOfSymbol(resolvedModuleSymbol);
                }
            }

            return m_anyType;
        }

        private IType ResolveExternalModuleTypeByLiteral(IStringLiteral name)
        {
            var moduleSym = ResolveExternalModuleName(name, name);
            if (moduleSym != null)
            {
                var resolvedModuleSymbol = ResolveExternalModuleSymbol(moduleSym);
                if (resolvedModuleSymbol != null)
                {
                    return GetTypeOfSymbol(resolvedModuleSymbol);
                }
            }

            return m_anyType;
        }

        /// <inheritdoc/>
        public IType GetReturnTypeOfSignature([NotNull] ISignature signatureArg)
        {
            return signatureArg.GetOrSetResolvedReturnType(
                (checker: this, signatureArg),
                (s, tuple) =>
                {
                    var @this = tuple.checker;
                    var signature = tuple.Item2;
                    if (!@this.PushTypeResolution(signature, TypeSystemPropertyName.ResolvedReturnType))
                    {
                        return @this.m_unknownType;
                    }

                    IType type = null;
                    if (signature.Target != null)
                    {
                        type = @this.InstantiateType(@this.GetReturnTypeOfSignature(signature.Target), signature.Mapper);
                    }
                    else if (signature.UnionSignatures != null)
                    {
                        type = @this.GetUnionType(signature.UnionSignatures.Map(sig => @this.GetReturnTypeOfSignature(sig)));
                    }
                    else
                    {
                        type = @this.GetReturnTypeFromBody(signature.Declaration);
                    }

                    if (!@this.PopTypeResolution())
                    {
                        type = @this.m_anyType;
                        if (@this.m_compilerOptions.NoImplicitAny.HasValue && @this.m_compilerOptions.NoImplicitAny.Value)
                        {
                            var declaration = signature.Declaration.Cast<IDeclaration>();
                            if (declaration.Name != null)
                            {
                                @this.Error(
                                    declaration.Name,
                                    Errors.Zero_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions,
                                    DeclarationNameToString(declaration.Name));
                            }
                            else
                            {
                                @this.Error(
                                    declaration,
                                    Errors.Function_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions);
                            }
                        }
                    }

                    return type;
                });
        }

        private IType GetRestTypeOfSignature(ISignature signature)
        {
            if (signature.HasRestParameter)
            {
                var type = GetTypeOfSymbol(signature.Parameters.LastOrUndefined());
                if ((type.Flags & TypeFlags.Reference) != TypeFlags.None &&
                    type.Cast<ITypeReference>().Target == m_globalArrayType)
                {
                    return type.Cast<ITypeReference>().TypeArguments[0];
                }
            }

            return m_anyType;
        }

        private Signature GetSignatureInstantiation(ISignature signature, IReadOnlyList<IType> typeArguments)
        {
            return InstantiateSignature(
                    signature,
                    CreateTypeMapper(signature.TypeParameters, typeArguments),
                    /*eraseTypeParameters*/ true);
        }

        private ISignature GetErasedSignature(ISignature signatureArg)
        {
            if (signatureArg.TypeParameters == null)
            {
                return signatureArg;
            }

            return signatureArg.GetOrSetErasedSignature(
                (checker: this, signatureArg),
                (s, tuple) =>
                {
                    var @this = tuple.checker;
                    var signature = tuple.signatureArg;
                    if (signature.Target != null)
                    {
                        return @this.InstantiateSignature(
                            @this.GetErasedSignature(signature.Target),
                            signature.Mapper);
                    }

                    return @this.InstantiateSignature(
                        signature,
                        @this.CreateTypeEraser(signature.TypeParameters),
                        /*eraseTypeParameters*/ true);
                });
        }

        private IObjectType GetOrCreateTypeFromSignature(ISignature signatureArg)
        {
            // There are two ways to declare a construct signature, one is by declaring a class constructor
            // using the constructor keyword, and the other is declaring a bare construct signature in an
            // object type literal or interface (using the new keyword). Each way of declaring a constructor
            // will result in a different declaration kind.
            return signatureArg.GetOrSetIsolatedSignatureType(
                (checker: this, signatureArg),
                (s, tuple) =>
                {
                    var @this = tuple.checker;
                    var signature = tuple.signatureArg;
                    var isConstructor = signature.Declaration.Kind == SyntaxKind.Constructor ||
                                    signature.Declaration.Kind == SyntaxKind.ConstructSignature;

                    var type = @this.CreateObjectType<ResolvedType>(TypeFlags.Anonymous | TypeFlags.FromSignature);
                    var resolvedMembers = new ResolvedTypeData()
                    {
                        Members = s_emptySymbols,
                        Properties = EmptyArray<ISymbol>(),

                        // TODO: consider adding a special collection with one element.
                        CallSignatures = !isConstructor ? new List<ISignature> { signature } : s_emptySignatureList,
                        ConstructSignatures = isConstructor ? new List<ISignature> { signature } : s_emptySignatureList,
                        IsolatedSignatureType = type,
                    };

                    return type.Resolve(resolvedMembers);
                });
        }

        private static ISymbol GetIndexSymbol(ISymbol symbol)
        {
            return symbol.Members["__index"];
        }

        private static ISignatureDeclaration GetIndexDeclarationOfSymbol(ISymbol symbol, IndexKind kind)
        {
            var syntaxKind = kind == IndexKind.Number ? SyntaxKind.NumberKeyword : SyntaxKind.StringKeyword;
            var indexSymbol = GetIndexSymbol(symbol);
            if (indexSymbol != null)
            {
                foreach (var decl in indexSymbol.DeclarationList)
                {
                    var node = decl.As<ISignatureDeclaration>();
                    if (node?.Parameters.Length == 1)
                    {
                        var parameter = node.Parameters[0];
                        if (parameter?.Type?.Kind == syntaxKind)
                        {
                            return node;
                        }
                    }
                }
            }

            return null;
        }

        private IType GetIndexTypeOfSymbol(ISymbol symbol, IndexKind kind)
        {
            var declaration = GetIndexDeclarationOfSymbol(symbol, kind);
            if (declaration == null)
            {
                return null;
            }

            return declaration.Type != null ? GetTypeFromTypeNode(declaration.Type) : m_anyType;
        }

        [CanBeNull]
        private static ITypeNode GetConstraintDeclaration([NotNull]ITypeParameter type)
        {
            return GetDeclarationOfKind(type.Symbol, SyntaxKind.TypeParameter).As<ITypeParameterDeclaration>()?.Constraint;
        }

        private bool HasConstraintReferenceTo([NotNull]IType type, ITypeParameter target)
        {
            var @checked = new HashSet<IType>();
            while ((type != null) && (type.Flags & TypeFlags.TypeParameter) != TypeFlags.None && !@checked.Contains(type))
            {
                if (type == target)
                {
                    return true;
                }

                @checked.Add(type);
                var constraintDeclaration = GetConstraintDeclaration(type.Cast<ITypeParameter>());
                type = constraintDeclaration != null ? GetTypeFromTypeNode(constraintDeclaration) : null;
            }

            return false;
        }

        [CanBeNull]
        private IType GetConstraintOfTypeParameter([NotNull]ITypeParameter typeParameter)
        {
            var typeConstraint = typeParameter.GetOrSetConstraint(
                this,
                (capturedTypeParameter, @this) =>
                {
                    if (capturedTypeParameter.Target != null)
                    {
                        var targetConstraint = @this.GetConstraintOfTypeParameter(capturedTypeParameter.Target);
                        return targetConstraint != null ?
                                                    @this.InstantiateType(targetConstraint, capturedTypeParameter.Mapper) :
                                                    m_noConstraintType;
                    }

                    var constraintDeclaration = GetConstraintDeclaration(capturedTypeParameter);
                    var constraint = @this.GetTypeFromTypeNode(constraintDeclaration);
                    if (@this.HasConstraintReferenceTo(constraint, capturedTypeParameter))
                    {
                        @this.Error(
                            constraintDeclaration,
                            Errors.Type_parameter_0_has_a_circular_constraint,
                            TypeToString(capturedTypeParameter));

                        constraint = m_unknownType;
                    }

                    return constraint;
                });

            return typeConstraint == m_noConstraintType ? null : typeParameter.Constraint;
        }

        private ISymbol GetParentSymbolOfTypeParameter([NotNull]ITypeParameter typeParameter)
        {
            return GetSymbolOfNode(GetDeclarationOfKind(typeParameter.Symbol, SyntaxKind.TypeParameter).Parent);
        }

        private static string GetTypeListId<T>(IReadOnlyList<T> types) where T : IType
        {
            if (types != null)
            {
                switch (types.Count)
                {
                    case 1:
                        return types[0].Id.ToString();

                    case 2:
                        return string.Concat(types[0].Id.ToString(), ",", types[1].Id.ToString());

                    default:
                        var result = new StringBuilder();
                        for (var i = 0; i < types.Count; i++)
                        {
                            if (i > 0)
                            {
                                result.Append(",");
                            }

                            result.Append(types[i].Id);
                        }

                        return result.ToString();
                }
            }

            return string.Empty;
        }

        // This function is used to propagate certain flags when creating new object type references and union types.
        // It is only necessary to do so if a constituent type might be the undefined type, the null type, the type
        // of an object literal or the anyFunctionType. This is because there are operations in the type checker
        // that care about the presence of such types at arbitrary depth in a containing type.
        private static TypeFlags GetPropagatingFlagsOfTypes(IReadOnlyList<IType> types)
        {
            TypeFlags result = TypeFlags.None;
            foreach (var type in types.AsStructEnumerable())
            {
                result |= type.Flags;
            }

            return result & TypeFlags.PropagatingFlags;
        }

        private ITypeReference CreateTypeReference(IGenericType targetArg, IReadOnlyList<IType> typeArgumentsArg)
        {
            var id = GetTypeListId(typeArgumentsArg);

            return targetArg.Instantiations.GetOrAddAtomic(
                id,
                 (checker: this, targetArg: targetArg, typeArgumentsArg: typeArgumentsArg),
                (key, tuple) =>
                {
                    var @this = tuple.checker;
                    var target = tuple.targetArg;
                    var typeArguments = tuple.typeArgumentsArg;
                    var flags = TypeFlags.Reference | (typeArguments != null ? GetPropagatingFlagsOfTypes(typeArguments) : TypeFlags.None);

                    var type = @this.CreateObjectType<TypeReference>(flags, target.Symbol);
                    type.Target = target;
                    type.TypeArguments = typeArguments;
                    return type;
                });
        }

        // Get type from reference to class or interface
        private IType GetTypeFromClassOrInterfaceReference(/*HINT: TypeReferenceNodeOrExpressionWithTypeArguments*/ ITypeNode node, ISymbol symbol)
        {
            var type = GetDeclaredTypeOfSymbol(symbol).Cast<IInterfaceType>();
            var typeParameters = type.LocalTypeParameters;
            var typeArguments = node.Kind == SyntaxKind.ExpressionWithTypeArguments ?
                                    node.Cast<IExpressionWithTypeArguments>().TypeArguments :
                                    node.Cast<ITypeReferenceNode>().TypeArguments;
            if (typeParameters != null)
            {
                if (typeArguments == null || typeArguments.Length != typeParameters.Count)
                {
                    Error(
                        node,
                        Errors.Generic_type_0_requires_1_type_argument_s,
                        TypeToString(type, /*enclosingDeclaration*/ null, TypeFormatFlags.WriteArrayAsGenericType),
                        typeParameters.Count);

                    return m_unknownType;
                }

                // In a type reference, the outer type parameters of the referenced class or interface are automatically
                // supplied as type arguments and the type reference only specifies arguments for the local type parameters
                // of the class or interface.
                return CreateTypeReference(
                        type.Cast<IGenericType>(),
                        type.OuterTypeParameters.Concatenate(typeArguments.Select(t => GetTypeFromTypeNode(t)).ToList())); // TODO: Verify correctness
            }

            if (typeArguments != null)
            {
                Error(
                    node,
                    Errors.Type_0_is_not_generic,
                    TypeToString(type));

                return m_unknownType;
            }

            return type;
        }

        // Get type from reference to type alias. When a type alias is generic, the declared type of the type alias may include
        // references to the type parameters of the alias. We replace those with the actual type arguments by instantiating the
        // declared type. Instantiations are cached using the type identities of the type arguments as the key.
        private IType GetTypeFromTypeAliasReference(/*HINT: TypeReferenceNodeOrExpressionWithTypeArguments*/ ITypeNode node, ISymbol symbol)
        {
            var type = GetDeclaredTypeOfSymbol(symbol);
            var links = GetSymbolLinks(symbol);
            var typeParameters = links.TypeParameters;
            var typeArguments = node.Kind == SyntaxKind.ExpressionWithTypeArguments ?
                                    node.Cast<IExpressionWithTypeArguments>().TypeArguments :
                                    node.Cast<ITypeReferenceNode>().TypeArguments;

            if (typeParameters != null)
            {
                if (typeArguments == null || typeArguments.Length != typeParameters.Count)
                {
                    Error(
                        node,
                        Errors.Generic_type_0_requires_1_type_argument_s,
                        SymbolToString(symbol),
                        typeParameters.Count);

                    return m_unknownType;
                }

                var typeArgumentTypes = typeArguments.Select(t => GetTypeFromTypeNode(t)).ToList();
                var id = GetTypeListId(typeArgumentTypes);

                return links.Instantiations.GetOrAddAtomic(id, _ => InstantiateType(type, CreateTypeMapper(typeParameters, typeArgumentTypes)));
            }

            if (typeArguments != null)
            {
                Error(
                    node,
                    Errors.Type_0_is_not_generic,
                    SymbolToString(symbol));

                return m_unknownType;
            }

            return type;
        }

        // Get type from reference to named type that cannot be generic (enum or type parameter)
        private IType GetTypeFromNonGenericTypeReference(/*HINT: TypeReferenceNodeOrExpressionWithTypeArguments*/ ITypeNode node, ISymbol symbol)
        {
            var typeArguments = node.Kind == SyntaxKind.ExpressionWithTypeArguments ?
                                    node.Cast<IExpressionWithTypeArguments>().TypeArguments :
                                    node.Cast<ITypeReferenceNode>().TypeArguments;

            if (typeArguments != null)
            {
                Error(
                    node,
                    Errors.Type_0_is_not_generic,
                    SymbolToString(symbol));

                return m_unknownType;
            }

            return GetDeclaredTypeOfSymbol(symbol);
        }

        private IType GetTypeFromTypeReference(/*HINT: TypeReferenceNodeOrExpressionWithTypeArguments*/ ITypeNode nodeArg)
        {
            return GetOrSetResolvedType(nodeArg, (checker: this, nodeArg), (links, tuple) =>
            {
                var @this = tuple.checker;
                var node = tuple.nodeArg;

                // We only support expressions that are simple qualified names. For other expressions this produces null.
                ISymbol symbol = null;
                if (node.Kind == SyntaxKind.TypeReference)
                {
                    var typeName = node.Cast<ITypeReferenceNode>().TypeName;
                    symbol = (typeName != null ? @this.ResolveEntityName(typeName, SymbolFlags.Type) : null) ?? @this.m_unknownSymbol;
                }
                else
                {
                    var expression = IsSupportedExpressionWithTypeArguments(node.Cast<IExpressionWithTypeArguments>()) ?
                                        node.Cast<IExpressionWithTypeArguments>().Expression :
                                        null;
                    symbol = (expression != null ? @this.ResolveEntityName(expression, SymbolFlags.Type) : null) ?? @this.m_unknownSymbol;
                }

                IType type = null;
                if (symbol == @this.m_unknownSymbol)
                {
                    type = @this.m_unknownType;
                }
                else if ((symbol.Flags & (SymbolFlags.Class | SymbolFlags.Interface)) != SymbolFlags.None)
                {
                    type = @this.GetTypeFromClassOrInterfaceReference(node, symbol);
                }
                else if ((symbol.Flags & SymbolFlags.TypeAlias) != SymbolFlags.None)
                {
                    type = @this.GetTypeFromTypeAliasReference(node, symbol);
                }
                else
                {
                    type = @this.GetTypeFromNonGenericTypeReference(node, symbol);
                }

                // Cache both the resolved symbol and the resolved type. The resolved symbol is needed in when we check the
                // type reference in checkTypeReferenceOrExpressionWithTypeArguments.
                return Tuple.Create(type, symbol);
            });
        }

        /// <nodoc />
        public IType GetTypeFromTypeQueryNode(ITypeQueryNode node)
        {
            return GetNodeLinks(node).GetOrSetResolvedType(
                (node, checker: this),
                (links, tpl) =>
                {
                    var capturedNode = tpl.node;
                    var @this = tpl.checker;

                    // TypeScript 1.0 spec (April 2014): 3.6.3
                    // The expression is processed as an identifier expression (section 4.3)
                    // or property access expression(section 4.10),
                    // the widened type(section 3.9) of which becomes the result.
                    return @this.GetWidenedType(@this.CheckExpression(capturedNode.ExprName));
                });
        }

        private IObjectType GetTypeOfGlobalSymbol(ISymbol symbol, int arity)
        {
            Func<ISymbol, IDeclaration> getTypeDeclaration = (ISymbol s) =>
            {
                var declarations = s.DeclarationList;
                foreach (var declaration in declarations)
                {
                    switch (declaration.Kind)
                    {
                        case SyntaxKind.ClassDeclaration:
                        case SyntaxKind.InterfaceDeclaration:
                        case SyntaxKind.EnumDeclaration:
                            return declaration;
                    }
                }

                return null;
            };

            if (symbol == null)
            {
                return arity != 0 ? (IObjectType)m_emptyGenericType : m_emptyObjectType;
            }

            var type = GetDeclaredTypeOfSymbol(symbol);
            if ((type.Flags & TypeFlags.ObjectType) == TypeFlags.None)
            {
                Error(getTypeDeclaration(symbol), Errors.Global_type_0_must_be_a_class_or_interface_type, symbol.Name);
                return arity != 0 ? (IObjectType)m_emptyGenericType : m_emptyObjectType;
            }

            if ((type.As<IInterfaceType>()?.TypeParameters?.Count ?? 0) != arity)
            {
                Error(getTypeDeclaration(symbol), Errors.Global_type_0_must_have_1_type_parameter_s, symbol.Name, arity);
                return arity != 0 ? (IObjectType)m_emptyGenericType : m_emptyObjectType;
            }

            return (IObjectType)type;
        }

        private ISymbol GetGlobalValueSymbol(string name)
        {
            return GetGlobalSymbol(name, SymbolFlags.Value, Errors.Cannot_find_global_value_0);
        }

        private ISymbol GetGlobalTypeSymbol(string name)
        {
            return GetGlobalSymbol(name, SymbolFlags.Type, Errors.Cannot_find_global_type_0);
        }

        private ISymbol GetGlobalSymbol(string name, SymbolFlags meaning, IDiagnosticMessage diagnostic)
        {
            return ResolveName(null, name, meaning, diagnostic, name);
        }

        private IObjectType GetGlobalType(string name, int arity = 0)
        {
            return GetTypeOfGlobalSymbol(GetGlobalTypeSymbol(name), arity);
        }

        /// <summary>
        /// Returns a type that is inside a namespace at the global scope, e.g.
        /// getExportedTypeFromNamespace('JSX', 'Element') returns the JSX.Element type
        /// </summary>
        private IType GetExportedTypeFromNamespace(string @namespace, string name)
        {
            var namespaceSymbol = GetGlobalSymbol(@namespace, SymbolFlags.Namespace, /*diagnosticMessage*/ null);
            var typeSymbol = namespaceSymbol != null ?
                                GetSymbol(namespaceSymbol.Exports, name, SymbolFlags.Type) :
                                null;

            return typeSymbol != null ?
                    GetDeclaredTypeOfSymbol(typeSymbol) :
                    null;
        }

        private ISymbol GetGlobalEsSymbolConstructorSymbol()
        {
            return m_globalEsSymbolConstructorSymbol ?? (m_globalEsSymbolConstructorSymbol = GetGlobalValueSymbol("Symbol"));
        }

        /// <summary>
        /// Creates a TypeReference for a generic `TypedPropertyDescriptor &lt; T &gt;`.
        /// </summary>
        private IType CreateTypedPropertyDescriptorType(IType propertyType)
        {
            var globalTypedPropertyDescriptorType = m_getGlobalTypedPropertyDescriptorType();

            return globalTypedPropertyDescriptorType != m_emptyGenericType ?
                CreateTypeReference(globalTypedPropertyDescriptorType.Cast<IGenericType>(), new List<IType> { propertyType }).Cast<IType>() :
                m_emptyObjectType.Cast<IType>();
        }

        /// <summary>
        /// Instantiates a global type that is generic with some element type, and returns that instantiation.
        /// </summary>
        private IObjectType CreateTypeFromGenericGlobalType(IGenericType genericGlobalType, IReadOnlyList<IType> typeArguments)
        {
            return genericGlobalType != m_emptyGenericType ?
                (IObjectType)CreateTypeReference(genericGlobalType, typeArguments) :
                m_emptyObjectType;
        }

        private IType CreateIterableType(IType elementType)
        {
            return CreateTypeFromGenericGlobalType(m_globalIterableType, new List<IType> { elementType });
        }

        private IType CreateIterableIteratorType(IType elementType)
        {
            return CreateTypeFromGenericGlobalType(m_globalIterableIteratorType, new List<IType> { elementType });
        }

        private IType CreateArrayType(IType elementType)
        {
            return CreateTypeFromGenericGlobalType(m_globalArrayType, new List<IType> { elementType });
        }

        private IType GetTypeFromArrayTypeNode(IArrayTypeNode node)
        {
            return GetNodeLinks(node).GetOrSetResolvedType(
                (node, checker: this),
                (links, tpl) =>
                {
                    var localNode = tpl.node;
                    var @this = tpl.checker;
                    return @this.CreateArrayType(@this.GetTypeFromTypeNode(localNode.ElementType));
                });
        }

        private ITupleType CreateTupleType(IReadOnlyList<IType> elementTypes)
        {
            var id = GetTypeListId(elementTypes);
            return m_tupleTypes.GetOrAddAtomic(id, key => CreateNewTupleType(elementTypes));
        }

        private ITupleType CreateNewTupleType(IReadOnlyList<IType> elementTypes)
        {
            var type = CreateObjectType<TupleType>(TypeFlags.Tuple | GetPropagatingFlagsOfTypes(elementTypes));
            type.ElementTypes = elementTypes;

            return type;
        }

        private IType GetTypeFromTupleTypeNode(ITupleTypeNode nodeArg)
        {
            return GetNodeLinks(nodeArg).GetOrSetResolvedType(
                (checker: this, nodeArg),
                (links, tuple) =>
                {
                    var @this = tuple.checker;
                    var node = tuple.nodeArg;
                    return @this.CreateTupleType(node.ElementTypes.Select(n => @this.GetTypeFromTypeNode(n)).ToList());
                });
        }

        private void AddTypeToSet(List<IType> typeSet, IType type, TypeFlags typeSetKind)
        {
            if ((type.Flags & typeSetKind) != TypeFlags.None)
            {
                AddTypesToSet(typeSet, type.As<IUnionOrIntersectionType>()?.Types, typeSetKind);
            }
            else if (!typeSet.Contains(type))
            {
                typeSet.Add(type);
            }
        }

        // Add the given types to the given type set. Order is preserved, duplicates are removed,
        // and nested types of the given kind are flattened into the set.
        private void AddTypesToSet(List<IType> typeSet, IReadOnlyList<IType> types, TypeFlags typeSetKind)
        {
            foreach (var type in types.AsStructEnumerable())
            {
                AddTypeToSet(typeSet, type, typeSetKind);
            }
        }

        private bool IsSubtypeOfAny(IType candidate, List<IType> types)
        {
            for (int i = 0, len = types.Count; i < len; i++)
            {
                if (candidate != types[i] && IsTypeSubtypeOf(candidate, types[i]))
                {
                    return true;
                }
            }

            return false;
        }

        private void RemoveSubtypes(List<IType> types)
        {
            var i = types.Count;
            while (i > 0)
            {
                i--;
                if (IsSubtypeOfAny(types[i], types))
                {
                    types.Splice(i, 1);
                }
            }
        }

        private static bool ContainsTypeAny(List<IType> types)
        {
            foreach (var type in types)
            {
                if (IsTypeAny(type))
                {
                    return true;
                }
            }

            return false;
        }

        private static void RemoveAllButLast(List<IType> types, IType typeToRemove)
        {
            var i = types.Count;
            while (i > 0 && types.Count > 1)
            {
                i--;
                if (types[i] == typeToRemove)
                {
                    types.Splice(i, 1);
                }
            }
        }

        // We reduce the constituent type set to only include types that aren't subtypes of other types, unless
        // the noSubtypeReduction flag is specified, in which case we perform a simple deduplication based on
        // object identity. Subtype reduction is possible only when union types are known not to circularly
        // reference themselves (as is the case with union types created by expression constructs such as array
        // literals and the || and ?: operators). Named types can circularly reference themselves and therefore
        // cannot be deduplicated during their declaration. For example, "type Item = string | (() => Item" is
        // a named type that circularly references itself.
        private IType GetUnionType([CanBeNull]IReadOnlyList<IType> types, bool noSubtypeReduction = false)
        {
            if (types == null || types.Count == 0)
            {
                return m_emptyUnionType;
            }

            var typeSet = new List<IType>(types.Count);
            AddTypesToSet(typeSet, types, TypeFlags.Union);
            if (ContainsTypeAny(typeSet))
            {
                return m_anyType;
            }

            if (noSubtypeReduction)
            {
                RemoveAllButLast(typeSet, m_undefinedType);
                RemoveAllButLast(typeSet, m_nullType);
            }
            else
            {
                RemoveSubtypes(typeSet);
            }

            if (typeSet.Count == 1)
            {
                return typeSet[0];
            }

            string id = GetTypeListId(typeSet);

            return m_unionTypes.GetOrAddAtomic(id, (checker: this, typeSet), (key, tuple) =>
            {
                var @this = tuple.checker;
                var localTypeSet = tuple.typeSet;
                var type = @this.CreateType<UnionType>(TypeFlags.Union | GetPropagatingFlagsOfTypes(localTypeSet));
                type.Types = localTypeSet;
                return type;
            });
        }

        private IType GetTypeFromUnionTypeNode(IUnionTypeNode nodeArg)
        {
            return GetNodeLinks(nodeArg).GetOrSetResolvedType(
                (checker: this, nodeArg),
                (links, tuple) =>
                {
                    var @this = tuple.checker;
                    var node = tuple.nodeArg;
                    return @this.GetUnionType(
                        node.Types.Select(n => @this.GetTypeFromTypeNode(n)).ToList(),
                        noSubtypeReduction: true);
                });
        }

        // We do not perform structural deduplication on intersection types. Intersection types are created only by the &
        // type operator and we can't reduce those because we want to support recursive intersection types. For example,
        // a type alias of the form "type List<T> = T & { next: List<T> }" cannot be reduced during its declaration.
        // Also, unlike union types, the order of the constituent types is preserved in order that overload resolution
        // for intersections of types with signatures can be deterministic.
        private IType GetIntersectionType(IReadOnlyList<IType> types)
        {
            if (types.Count == 0)
            {
                return m_emptyObjectType;
            }

            var typeSet = new List<IType>();
            AddTypesToSet(typeSet, types, TypeFlags.Intersection);
            if (ContainsTypeAny(typeSet))
            {
                return m_anyType;
            }

            if (typeSet.Count == 1)
            {
                return typeSet[0];
            }

            string id = GetTypeListId(typeSet);

            return m_intersectionTypes.GetOrAddAtomic(id, (checker: this, typeSet), (key, tuple) =>
            {
                var @this = tuple.checker;
                var capturedTypeSet = tuple.typeSet;
                var type = @this.CreateType<IntersectionType>(TypeFlags.Intersection | GetPropagatingFlagsOfTypes(capturedTypeSet));
                type.Types = capturedTypeSet;
                return type;
            });
        }

        private IType GetTypeFromIntersectionTypeNode(IIntersectionTypeNode nodeArg)
        {
            return GetNodeLinks(nodeArg).GetOrSetResolvedType(
                 (checker: this, nodeArg),
                (links, tuple) =>
                {
                    var @this = tuple.checker;
                    var node = tuple.nodeArg;
                    return @this.GetIntersectionType(node.Types.Select(t => @this.GetTypeFromTypeNode(t)).ToList());
                });
        }

        private IType GetTypeFromTypeLiteralOrFunctionOrConstructorTypeNode(INode nodeArg)
        {
            return GetNodeLinks(nodeArg).GetOrSetResolvedType(
                 (checker: this, nodeArg),
                (links, tuple) =>
                {
                    var @this = tuple.checker;
                    var node = tuple.nodeArg;

                    // Deferred resolution of members is handled by resolveObjectTypeMembers

                    // TODO: Verify equivalence!!
                    //       TS implementation does: links.resolvedType = CreateObjectType(TypeFlags.Anonymous, node.Symbol);
                    //       but uses it as <ResolvedType> in resolveObjectTypeMembers.
                    //       So should we create a ResolvedType object here?
                    return @this.CreateObjectType<ResolvedType>(TypeFlags.Anonymous, node.Symbol);
                });
        }

        private IStringLiteralType GetStringLiteralTypeForText(string text)
        {
            return m_stringLiteralTypes.GetOrAddAtomic(
                text,
                this,
                (key, @this) =>
                {
                    var type = @this.m_stringLiteralTypes[key] = @this.CreateType<StringLiteralType>(TypeFlags.StringLiteral);
                    type.Text = key;

                    return type;
                });
        }

        private IType GetTypeFromStringLiteralTypeNode(IStringLiteralTypeNode nodeArg)
        {
            return GetNodeLinks(nodeArg).GetOrSetResolvedType(
                 (checker: this, nodeArg),
                (links, tuple) =>
                {
                    var @this = tuple.checker;
                    var node = tuple.nodeArg;
                    return @this.GetStringLiteralTypeForText(node.Text).Cast<IType>();
                });
        }

        private IType GetThisType(ITypeNode node)
        {
            var container = GetThisContainer(node, /*includeArrowFunctions*/ false);
            var parent = container?.Parent;

            if (parent != null && (IsClassLike(parent) != null || parent.Kind == SyntaxKind.InterfaceDeclaration))
            {
                if ((container.Flags & NodeFlags.Static) == NodeFlags.None &&
                    (container.Kind != SyntaxKind.Constructor || IsNodeDescendentOf(node, container.Cast<IConstructorDeclaration>().Body)))
                {
                    return GetDeclaredTypeOfClassOrInterface(GetSymbolOfNode(parent)).ThisType;
                }
            }

            Error(
                node,
                Errors.A_this_type_is_available_only_in_a_non_static_member_of_a_class_or_interface);

            return m_unknownType;
        }

        private IType GetTypeFromThisTypeNode(ITypeNode nodeArg)
        {
            return GetNodeLinks(nodeArg).GetOrSetResolvedType(
                (checker: this, nodeArg),
                (links, tuple) =>
                {
                    var @this = tuple.checker;
                    var node = tuple.nodeArg;
                    return @this.GetThisType(node);
                });
        }

        private IType GetPredicateType(ITypePredicateNode node)
        {
            return CreatePredicateType(GetSymbolOfNode(node), CreateTypePredicateFromTypePredicateNode(node));
        }

        private IPredicateType CreatePredicateType(ISymbol symbol, /*HINT: ThisTypePredicate | IdentifierTypePredicate*/ ITypePredicate predicate)
        {
            var type = CreateType<PredicateType>(TypeFlags.Boolean | TypeFlags.PredicateType, symbol);
            type.Predicate = predicate;

            return type;
        }

        private IType GetTypeFromPredicateTypeNode(ITypePredicateNode nodeArg)
        {
            return GetNodeLinks(nodeArg).GetOrSetResolvedType(
                (checker: this, nodeArg),
                (links, tuple) =>
                {
                    var @this = tuple.checker;
                    var node = tuple.nodeArg;
                    return @this.GetPredicateType(node);
                });
        }

        [CanBeNull]
        private IType GetTypeFromTypeNode([NotNull]ITypeNode node)
        {
            switch (node.Kind)
            {
                case SyntaxKind.AnyKeyword:
                    return m_anyType;

                case SyntaxKind.StringKeyword:
                    return m_stringType;

                case SyntaxKind.NumberKeyword:
                    return m_numberType;

                case SyntaxKind.BooleanKeyword:
                    return m_booleanType;

                case SyntaxKind.SymbolKeyword:
                    return m_esSymbolType;

                case SyntaxKind.VoidKeyword:
                    return m_voidType;

                case SyntaxKind.ThisType:
                    return GetTypeFromThisTypeNode(node);

                case SyntaxKind.StringLiteralType:
                    return GetTypeFromStringLiteralTypeNode(node.Cast<IStringLiteralTypeNode>());

                case SyntaxKind.TypeReference:
                    return GetTypeFromTypeReference(node.Cast<ITypeReferenceNode>());

                case SyntaxKind.TypePredicate:
                    return GetTypeFromPredicateTypeNode(node.Cast<ITypePredicateNode>());

                case SyntaxKind.ExpressionWithTypeArguments:
                    return GetTypeFromTypeReference(node.Cast<IExpressionWithTypeArguments>());

                case SyntaxKind.TypeQuery:
                    return GetTypeFromTypeQueryNode(node.Cast<ITypeQueryNode>());

                case SyntaxKind.ArrayType:
                    return GetTypeFromArrayTypeNode(node.Cast<IArrayTypeNode>());

                case SyntaxKind.TupleType:
                    return GetTypeFromTupleTypeNode(node.Cast<ITupleTypeNode>());

                case SyntaxKind.UnionType:
                    return GetTypeFromUnionTypeNode(node.Cast<IUnionTypeNode>());

                case SyntaxKind.IntersectionType:
                    return GetTypeFromIntersectionTypeNode(node.Cast<IIntersectionTypeNode>());

                case SyntaxKind.ParenthesizedType:
                    return GetTypeFromTypeNode(node.Cast<IParenthesizedTypeNode>().Type);

                case SyntaxKind.FunctionType:
                case SyntaxKind.ConstructorType:
                case SyntaxKind.TypeLiteral:
                    return GetTypeFromTypeLiteralOrFunctionOrConstructorTypeNode(node);

                // This  assumes that an identifier or qualified name is a type expression
                // Callers should first ensure this by calling IsTypeNode
                case SyntaxKind.Identifier:
                case SyntaxKind.QualifiedName:
                    var symbol = GetSymbolAtLocation(node);
                    return symbol != null ? GetDeclaredTypeOfSymbol(symbol) : null;

                default:
                    return m_unknownType;
            }
        }

        private static IReadOnlyList<T> InstantiateList<T>(IReadOnlyList<T> items, ITypeMapper mapper, Func<T /*item*/, ITypeMapper /*mapper*/, T> instantiator)
        {
            if (items?.Count > 0)
            {
                List<T> result = new List<T>(items.Count);
                foreach (var v in items.AsStructEnumerable())
                {
                    result.Add(instantiator(v, mapper));
                }

                return result;
            }

            return EmptyArray<T>();
        }

        private static IReadOnlyList<TItem> InstantiateList<TItem, TState>(IReadOnlyList<TItem> items, TState state, ITypeMapper mapper, Func<TItem /*item*/, TState, ITypeMapper /*mapper*/, TItem> instantiator)
        {
            if (items?.Count > 0)
            {
                List<TItem> result = new List<TItem>(items.Count);
                foreach (var v in items.AsStructEnumerable())
                {
                    result.Add(instantiator(v, state, mapper));
                }

                return result;
            }

            return EmptyArray<TItem>();
        }

        private static ITypeMapper CreateUnaryTypeMapper(IType source, IType target)
        {
            return TypeMapper.Create(t => t == source ? target : t);
        }

        private static ITypeMapper CreateBinaryTypeMapper(IType source1, IType target1, IType source2, IType target2)
        {
            return TypeMapper.Create(t => t == source1 ? target1 : t == source2 ? target2 : t);
        }

        private static ITypeMapper CreateTypeMapper(IReadOnlyList<IType> sources, IReadOnlyList<IType> targets)
        {
            switch (sources.Count)
            {
                case 1:
                    return CreateUnaryTypeMapper(sources[0], targets[0]);
                case 2:
                    return CreateBinaryTypeMapper(sources[0], targets[0], sources[1], targets[1]);
            }

            return TypeMapper.Create(t =>
            {
                for (var i = 0; i < sources.Count; i++)
                {
                    if (t == sources[i])
                    {
                        return targets[i];
                    }
                }

                return t;
            });
        }

        private ITypeMapper CreateUnaryTypeEraser(IType source)
        {
            return TypeMapper.Create(t => t == source ? m_anyType.Cast<IType>() : t);
        }

        private ITypeMapper CreateBinaryTypeEraser(IType source1, IType source2)
        {
            return TypeMapper.Create(t => t == source1 || t == source2 ? m_anyType.Cast<IType>() : t);
        }

        private ITypeMapper CreateTypeEraser(IReadOnlyList<IType> sources)
        {
            switch (sources.Count)
            {
                case 1:
                    return CreateUnaryTypeEraser(sources[0]);
                case 2:
                    return CreateBinaryTypeEraser(sources[0], sources[1]);
            }

            return TypeMapper.Create(t =>
            {
                foreach (var source in sources.AsStructEnumerable())
                {
                    if (t == source)
                    {
                        return m_anyType;
                    }
                }

                return t;
            });
        }

        private ITypeMapper GetInferenceMapper(IInferenceContext contextArg)
        {
            return contextArg.GetOrSetMapper(
                 (checker: this, contextArg),
                (c, tuple) =>
                {
                    var @this = tuple.checker;
                    var context = tuple.contextArg;
                    ITypeMapper mapper = TypeMapper.Create(t =>
                    {
                        var typeParameters = c.TypeParameters;
                        for (var i = 0; i < typeParameters.Count; i++)
                        {
                            if (t == typeParameters[i])
                            {
                                c.Inferences[i].IsFixed = true;
                                return @this.GetInferredType(c, i);
                            }
                        }

                        return t;
                    });

                    mapper.Context = context;
                    return mapper;
                });
        }

        private static IType IdentityMapperFn(IType type)
        {
            return type;
        }

        private ITypeMapper CombineTypeMappers(ITypeMapper mapper1, ITypeMapper mapper2)
        {
            return TypeMapper.Create(t => InstantiateType(mapper1.Mapper(t), mapper2));
        }

        [NotNull]
        private ITypeParameter CloneTypeParameter([NotNull]ITypeParameter typeParameter)
        {
            var result = CreateType<TypeParameter>(TypeFlags.TypeParameter, typeParameter.Symbol);
            result.Target = typeParameter;
            return result;
        }

        private /*HINT: ThisTypePredicate | IdentifierTypePredicate*/ ITypePredicate CloneTypePredicate(ITypePredicate predicate, ITypeMapper mapper)
        {
            IIdentifierTypePredicate identifierTypePredicate = IsIdentifierTypePredicate(predicate);
            if (identifierTypePredicate != null)
            {
                return new IdentifierTypePredicate()
                {
                    Kind = TypePredicateKind.Identifier,
                    ParameterName = identifierTypePredicate.ParameterName,
                    ParameterIndex = identifierTypePredicate.ParameterIndex,
                    Type = InstantiateType(identifierTypePredicate.Type, mapper),
                };
            }
            else
            {
                return new ThisTypePredicate()
                {
                    Kind = TypePredicateKind.This,
                    Type = InstantiateType(predicate.Type, mapper),
                };
            }
        }

        private Signature InstantiateSignature(ISignature signature, ITypeMapper mapper, bool eraseTypeParameters = false)
        {
            List<ITypeParameter> freshTypeParameters = null;

            if (signature.TypeParameters != null && !eraseTypeParameters)
            {
                // First create a fresh set of type parameters, then include a mapping from the old to the
                // new type parameters in the mapper function. Finally store this mapper in the new type
                // parameters such that we can use it when instantiating constraints.
                freshTypeParameters = signature.TypeParameters.Select(CloneTypeParameter).ToList();
                mapper = CombineTypeMappers(
                            CreateTypeMapper(signature.TypeParameters, freshTypeParameters),
                            mapper);

                foreach (var tp in freshTypeParameters)
                {
                    tp.Mapper = mapper;
                }
            }

            var result = CreateSignature(
                            signature.Declaration,
                            freshTypeParameters,
                            InstantiateList(signature.Parameters, mapper, InstantiateSymbol),
                            InstantiateType(signature.ResolvedReturnType, mapper),
                            signature.MinArgumentCount,
                            signature.HasRestParameter,
                            signature.HasStringLiterals);

            result.Target = signature;
            result.Mapper = mapper;

            return result;
        }

        private ISymbol InstantiateSymbol(ISymbol symbol, ITypeMapper mapper)
        {
            if ((symbol.Flags & SymbolFlags.Instantiated) != SymbolFlags.None)
            {
                var links = GetSymbolLinks(symbol);

                // If symbol being instantiated is itself a instantiation, fetch the original target and combine the
                // type mappers. This ensures that original type identities are properly preserved and that aliases
                // always reference a non-aliases.
                symbol = links.Target;
                mapper = CombineTypeMappers(links.Mapper, mapper);
            }

            // Keep the flags from the symbol we're instantiating.  Mark that is instantiated, and
            // also transient so that we can just store data on it directly.
            var symbolData = new SymbolData
            {
                ReadOnlyDeclarations = symbol.DeclarationList.ToList(),
                Parent = symbol.Parent,
                Target = symbol,
                Mapper = mapper,
                ValueDeclaration = symbol.ValueDeclaration,
            };
            var result = CreateTransientSymbol(
                            SymbolFlags.Instantiated | SymbolFlags.Transient | symbol.Flags,
                            symbol.Name,
                            ref symbolData);

            return result;
        }

        private IObjectType InstantiateAnonymousType(IAnonymousType typeArg, ITypeMapper mapperArg)
        {
            return (IObjectType)mapperArg.Instantiations.GetOrAddAtomic(
                typeArg.Id,
                 (checker: this, typeArg, mapperArg),
                (id, tuple) =>
                {
                    var @this = tuple.checker;
                    var type = tuple.typeArg;
                    var mapper = tuple.mapperArg;

                    // Mark the anonymous type as instantiated such that our infinite instantiation detection logic can recognize it
                    var result = @this.CreateObjectType<AnonymousType>(TypeFlags.Anonymous | TypeFlags.Instantiated, type.Symbol);

                    result.Target = type;
                    result.Mapper = mapper;

                    return result;
                });
        }

        private IType InstantiateType(IType type, ITypeMapper mapper)
        {
            if (type != null && mapper != s_identityMapper)
            {
                if ((type.Flags & TypeFlags.TypeParameter) != TypeFlags.None)
                {
                    return mapper.Mapper(type.Cast<ITypeParameter>());
                }

                if ((type.Flags & TypeFlags.Anonymous) != TypeFlags.None)
                {
                    return type.Symbol != null &&
                           ((type.Symbol.Flags &
                             (SymbolFlags.Function | SymbolFlags.Method | SymbolFlags.Class | SymbolFlags.TypeLiteral | SymbolFlags.ObjectLiteral)) !=
                            SymbolFlags.None)
                        ? InstantiateAnonymousType(type.Cast<IAnonymousType>(), mapper)
                        : type;
                }

                if ((type.Flags & TypeFlags.Reference) != TypeFlags.None)
                {
                    return CreateTypeReference(
                            type.Cast<ITypeReference>().Target,
                            InstantiateList(type.Cast<ITypeReference>().TypeArguments, mapper, InstantiateType));
                }

                if ((type.Flags & TypeFlags.Tuple) != TypeFlags.None)
                {
                    return CreateTupleType(
                            InstantiateList(type.Cast<ITupleType>().ElementTypes, mapper, InstantiateType));
                }

                if ((type.Flags & TypeFlags.Union) != TypeFlags.None)
                {
                    return GetUnionType(
                            InstantiateList(type.Cast<IUnionType>().Types, mapper, InstantiateType),
                            /*noSubtypeReduction*/ true);
                }

                if ((type.Flags & TypeFlags.Intersection) != TypeFlags.None)
                {
                    return GetIntersectionType(
                            InstantiateList(type.Cast<IIntersectionType>().Types, mapper, InstantiateType));
                }

                if ((type.Flags & TypeFlags.PredicateType) != TypeFlags.None)
                {
                    var predicate = type.As<IPredicateType>()?.Predicate;

                    return CreatePredicateType(
                            type.Symbol,
                            CloneTypePredicate(predicate, mapper));
                }
            }

            return type;
        }

        /// <summary>
        /// Returns true if the given expression contains (at any level of nesting) a function or arrow expression
        /// that is subject to contextual typing.
        /// </summary>
        private static bool IsContextSensitive(/*HINT: Expression | MethodDeclaration | ObjectLiteralElement*/ INode node)
        {
            Contract.Requires(node.Kind != SyntaxKind.MethodDeclaration || IsObjectLiteralMethod(node) != null);

            switch (node.Kind)
            {
                case SyntaxKind.FunctionExpression:
                case SyntaxKind.ArrowFunction:
                    return IsContextSensitiveFunctionLikeDeclaration(node.Cast<IFunctionLikeDeclaration>());

                case SyntaxKind.ObjectLiteralExpression:
                    return Any(node.Cast<IObjectLiteralExpression>().Properties, n => { return IsContextSensitive(n); });

                case SyntaxKind.ArrayLiteralExpression:
                    return Any(node.Cast<IArrayLiteralExpression>().Elements, n => { return IsContextSensitive(n); });

                case SyntaxKind.ConditionalExpression:
                    return IsContextSensitive(node.Cast<IConditionalExpression>().WhenTrue) ||
                           IsContextSensitive(node.Cast<IConditionalExpression>().WhenFalse);

                case SyntaxKind.BinaryExpression:
                    return (node.Cast<IBinaryExpression>().OperatorToken.Kind == SyntaxKind.BarBarToken) &&
                           (IsContextSensitive(node.Cast<IBinaryExpression>().Left) || IsContextSensitive(node.Cast<IBinaryExpression>().Right));

                case SyntaxKind.PropertyAssignment:
                    return IsContextSensitive(node.Cast<IPropertyAssignment>().Initializer);

                case SyntaxKind.MethodDeclaration:
                case SyntaxKind.MethodSignature:
                    return IsContextSensitiveFunctionLikeDeclaration(node.Cast<IFunctionLikeDeclaration>());

                case SyntaxKind.ParenthesizedExpression:
                    return IsContextSensitive(node.Cast<IParenthesizedExpression>().Expression);
            }

            return false;
        }

        private static bool IsContextSensitiveFunctionLikeDeclaration(IFunctionLikeDeclaration node)
        {
            // TODO: rewrite in C# way
            return (node.TypeParameters == null) &&
                   (node.Parameters.Length != 0) &&
                   !Any(node.Parameters, p => p.Type != null);
        }

        private IType GetTypeWithoutSignatures(IType type)
        {
            if ((type.Flags & TypeFlags.ObjectType) != TypeFlags.None)
            {
                var resolved = ResolveStructuredTypeMembers(type);
                if (resolved.ConstructSignatures.Count != 0)
                {
                    var result = CreateObjectType<ResolvedType>(TypeFlags.Anonymous, type.Symbol);

                    var resolvedTypeData = new ResolvedTypeData()
                    {
                        Members = resolved.Members,
                        Properties = resolved.Properties,
                    };

                    type = result.Resolve(resolvedTypeData);
                }
            }

            return type;
        }

        // TYPE CHECKING

        /// <inheritdoc/>
        public bool IsTypeIdenticalTo(IType source, IType target)
        {
            return CheckTypeRelatedTo(source, target, m_identityRelation, /*errorNode*/ null);
        }

        private Ternary CompareTypesIdentical(IType source, IType target)
        {
            return CheckTypeRelatedTo(source, target, m_identityRelation, /*errorNode*/ null) ? Ternary.True : Ternary.False;
        }

        private bool IsTypeSubtypeOf(IType source, IType target)
        {
            return CheckTypeSubtypeOf(source, target, /*errorNode*/ null);
        }

        /// <inheritdoc/>
        public bool IsTypeAssignableTo(IType source, IType target)
        {
            return CheckTypeAssignableTo(source, target, /*errorNode*/ null);
        }

        // Ported from commit 9e5f2604
        private bool IsTypeComparableTo(IType source, IType target)
        {
            return CheckTypeComparableTo(source, target, /*errorNode*/ null);
        }

        private bool CheckTypeSubtypeOf(IType source, IType target, INode errorNode, IDiagnosticMessage headMessage = null, DiagnosticMessageChain containingMessageChain = null)
        {
            return CheckTypeRelatedTo(source, target, m_subtypeRelation, errorNode, headMessage, containingMessageChain);
        }

        // Ported from commit 9e5f2604
        private bool CheckTypeComparableTo(IType source, IType target, INode errorNode, IDiagnosticMessage headMessage = null, DiagnosticMessageChain containingMessageChain = null)
        {
            return CheckTypeRelatedTo(source, target, m_comparableRelation, errorNode, headMessage, containingMessageChain);
        }

        private bool CheckTypeAssignableTo(IType source, IType target, INode errorNode, IDiagnosticMessage headMessage = null, DiagnosticMessageChain containingMessageChain = null)
        {
            return CheckTypeRelatedTo(source, target, m_assignableRelation, errorNode, headMessage, containingMessageChain);
        }

        /// <summary>
        /// See signatureRelatedTo, compareSignaturesIdentical
        /// </summary>
        private bool IsSignatureAssignableTo(ISignature source, ISignature target, bool ignoreReturnTypes)
        {
            // TODO: De-duplicate code between related functions.
            if (source == target)
            {
                return true;
            }

            if (!target.HasRestParameter && source.MinArgumentCount > target.Parameters.Count)
            {
                return false;
            }

            // Spec 1.0 Section 3.8.3 & 3.8.4:
            // M and N (the signatures) are instantiated using type Any as the type argument for all type parameters declared by M and N
            source = GetErasedSignature(source);
            target = GetErasedSignature(target);

            var sourceMax = GetNumNonRestParameters(source);
            var targetMax = GetNumNonRestParameters(target);
            var checkCount = GetNumParametersToCheckForSignatureRelatability(source, sourceMax, target, targetMax);

            for (var i = 0; i < checkCount; i++)
            {
                var s = i < sourceMax ? GetTypeOfSymbol(source.Parameters[i]) : GetRestTypeOfSignature(source);
                var t = i < targetMax ? GetTypeOfSymbol(target.Parameters[i]) : GetRestTypeOfSignature(target);

                var related = IsTypeAssignableTo(t, s) || IsTypeAssignableTo(s, t);
                if (!related)
                {
                    return false;
                }
            }

            if (!ignoreReturnTypes)
            {
                var targetReturnType = GetReturnTypeOfSignature(target);
                if (targetReturnType == m_voidType)
                {
                    return true;
                }

                var sourceReturnType = GetReturnTypeOfSignature(source);

                // The following block preserves behavior forbidding boolean returning functions from being assignable to type guard returning functions
                if ((targetReturnType.Flags & TypeFlags.PredicateType) != TypeFlags.None &&
                    (targetReturnType.Cast<IPredicateType>().Predicate.Kind == TypePredicateKind.Identifier))
                {
                    if ((sourceReturnType.Flags & TypeFlags.PredicateType) == TypeFlags.None)
                    {
                        return false;
                    }
                }

                return IsTypeAssignableTo(sourceReturnType, targetReturnType);
            }

            return true;
        }

        private bool IsImplementationCompatibleWithOverload(ISignature implementation, ISignature overload)
        {
            var erasedSource = GetErasedSignature(implementation);
            var erasedTarget = GetErasedSignature(overload);

            // First see if the return types are compatible in either direction.
            var sourceReturnType = GetReturnTypeOfSignature(erasedSource);
            var targetReturnType = GetReturnTypeOfSignature(erasedTarget);

            if (targetReturnType == m_voidType ||
                CheckTypeRelatedTo(targetReturnType, sourceReturnType, m_assignableRelation, /*errorNode*/ null) ||
                CheckTypeRelatedTo(sourceReturnType, targetReturnType, m_assignableRelation, /*errorNode*/ null))
            {
                return IsSignatureAssignableTo(erasedSource, erasedTarget, /*ignoreReturnTypes*/ true);
            }

            return false;
        }

        private static int GetNumNonRestParameters(ISignature signature)
        {
            var numParams = signature.Parameters.Count;
            return signature.HasRestParameter ? numParams - 1 : numParams;
        }

        private static int GetNumParametersToCheckForSignatureRelatability(ISignature source, int sourceNonRestParamCount, ISignature target, int targetNonRestParamCount)
        {
            if (source.HasRestParameter == target.HasRestParameter)
            {
                if (source.HasRestParameter)
                {
                    // If both have rest parameters, get the max and add 1 to
                    // compensate for the rest parameter.
                    return Math.Max(sourceNonRestParamCount, targetNonRestParamCount) + 1;
                }
                else
                {
                    return Math.Min(sourceNonRestParamCount, targetNonRestParamCount);
                }
            }
            else
            {
                // Return the count for whichever signature doesn't have rest parameters.
                return source.HasRestParameter ? targetNonRestParamCount : sourceNonRestParamCount;
            }
        }

        private static readonly ObjectPool<CheckTypeRelatedToClosure> s_closurePool =
            new ObjectPool<CheckTypeRelatedToClosure>(() => new CheckTypeRelatedToClosure(), c => { c.Clear(); return c; });

        /// <summary>
        /// Checks if 'source' is related to 'target' (e.g.: is a assignable to).
        /// </summary>
        /// <param name="source">The left-hand-side of the relation.</param>
        /// <param name="target">The right-hand-side of the relation.</param>
        /// <param name="relation">
        /// The relation considered. One of 'identityRelation', 'assignableRelation', or 'subTypeRelation'.
        /// Used as both to determine which checks are performed and as a cache of previously computed results.
        /// </param>
        /// <param name="errorNode">The suggested node upon which all errors will be reported, if defined. This may or may not be the actual node used.</param>
        /// <param name="headMessage">If the error chain should be prepended by a head message, then headMessage will be used.</param>
        /// <param name="containingMessageChain">A chain of errors to prepend any new errors found.</param>
        private bool CheckTypeRelatedTo(
            IType source,
            IType target,
            ConcurrentMap<RelationComparisonResult> relation,
            INode errorNode,
            IDiagnosticMessage headMessage = null,
            DiagnosticMessageChain containingMessageChain = null)
        {
            // In TypeScript implementation there are dozens of functions defined within this function.
            // Creating function delegates for each of them is cumbersome, so to simplify the port
            // we use a class to encapsulate them.
            using (var closureWrapper = s_closurePool.GetInstance())
            {
                var closure = closureWrapper.Instance;
                closure.Init(this, relation, headMessage);

                Contract.Assert(relation != m_identityRelation || errorNode == null, "no error reporting in identity checking");

                var result = closure.IsRelatedTo(source, target, errorNode != null, headMessage);
                if (closure.Overflow)
                {
                    Error(
                        errorNode,
                        Errors.Excessive_stack_depth_comparing_types_0_and_1,
                        TypeToString(source),
                        TypeToString(target));
                }
                else if (closure.ErrorInfo != null)
                {
                    // If we already computed this relation, but in a context where we didn't want to report errors (e.g. overload resolution),
                    // then we'll only have a top-level error (e.g. 'Class X does not implement interface Y') without any details. If this happened,
                    // request a recompuation to get a complete error message. This will be skipped if we've already done this computation in a context
                    // where errors were being reported.
                    if (closure.ErrorInfo.Next == null)
                    {
                        closure.ErrorInfo = null;
                        closure.ElaborateErrors = true;

                        closure.IsRelatedTo(source, target, errorNode != null, headMessage);
                    }

                    if (containingMessageChain != null)
                    {
                        closure.ErrorInfo = ConcatenateDiagnosticMessageChains(containingMessageChain, closure.ErrorInfo);
                    }

                    m_diagnostics.Add(Diagnostic.CreateDiagnosticForNodeFromMessageChain(errorNode, closure.ErrorInfo));
                }

                return result != Ternary.False;
            }
        }

        /// <summary>
        /// Custom closure type used to check type relationship.
        /// </summary>
        /// <remarks>
        /// This object is poooled for performance reasons.
        /// To be able to use it with the pool, Init and clear methods were introduced.
        /// </remarks>
        private sealed class CheckTypeRelatedToClosure
        {
            public DiagnosticMessageChain ErrorInfo;
            public bool Overflow = false;
            public bool ElaborateErrors = false;

            // HINT: In TS implementation these fields are lists, but their values are assigned at
            //       arbitrary indices. So it makes more sense to represent them as a Dictionary
            private readonly Dictionary<int, IType> m_sourceStack = new Dictionary<int, IType>();
            private readonly Dictionary<int, IType> m_targetStack = new Dictionary<int, IType>();
            private readonly Dictionary<int, Map<RelationComparisonResult>> m_maybeStack = new Dictionary<int, Map<RelationComparisonResult>>();

            private int m_expandingFlags;
            private int m_depth = 0;

            private Checker m_checker;
            private ConcurrentMap<RelationComparisonResult> m_relation;

            // private Map<RelationComparisonResult> m_relation;
            private IDiagnosticMessage m_headMessage;

            /// <summary>
            /// Clears the state of the closure.
            /// </summary>
            public void Clear()
            {
                ErrorInfo = null;
                Overflow = false;
                ElaborateErrors = false;
                m_sourceStack.Clear();
                m_targetStack.Clear();
                m_maybeStack.Clear();
                m_expandingFlags = 0;
                m_depth = 0;
                m_relation = null;
                m_headMessage = null;
                m_checker = null;
            }

            /// <summary>
            /// Initilize a closure with required parameters.
            /// </summary>
            public void Init(Checker checker, ConcurrentMap<RelationComparisonResult> relation, IDiagnosticMessage headMessage)
            {
                m_checker = checker;
                m_relation = relation;
                m_headMessage = headMessage;
            }

            public void ReportError(IDiagnosticMessage message, params string[] args)
            {
                ErrorInfo = ChainDiagnosticMessages(ErrorInfo, message, args);
            }

            public void ReportRelationError(IDiagnosticMessage message, IType source, IType target)
            {
                var sourceType = m_checker.TypeToString(source);
                var targetType = m_checker.TypeToString(target);
                if (sourceType == targetType)
                {
                    sourceType = m_checker.TypeToString(source, /*enclosingDeclaration*/ null, TypeFormatFlags.UseFullyQualifiedType);
                    targetType = m_checker.TypeToString(target, /*enclosingDeclaration*/ null, TypeFormatFlags.UseFullyQualifiedType);
                }

                ReportError(
                    message ?? Errors.Type_0_is_not_assignable_to_type_1,
                    sourceType,
                    targetType);
            }

            // Compare two types and return
            // Ternary.True if they are related with no assumptions,
            // Ternary.Maybe if they are related with assumptions of other relationships, or
            // Ternary.False if they are not related.
            public Ternary IsRelatedTo(IType source, IType target, bool reportErrors = false, IDiagnosticMessage headMessage = null)
            {
                Ternary result;

                // both types are the same - covers 'they are the same primitive type or both are Any' or the same type parameter cases
                if (source == target)
                {
                    return Ternary.True;
                }

                if (m_relation == m_checker.m_identityRelation)
                {
                    return IsIdenticalTo(source, target);
                }

                if (IsTypeAny(target))
                {
                    return Ternary.True;
                }

                if (source == m_checker.m_undefinedType)
                {
                    return Ternary.True;
                }

                if (source == m_checker.m_nullType && target != m_checker.m_undefinedType)
                {
                    return Ternary.True;
                }

                if ((source.Flags & TypeFlags.Enum) != TypeFlags.None &&
                    target == m_checker.m_numberType)
                {
                    return Ternary.True;
                }

                if ((source.Flags & TypeFlags.Enum) != TypeFlags.None &&
                    (target.Flags & TypeFlags.Enum) != TypeFlags.None)
                {
                    result = EnumRelatedTo(source, target);
                    if (result != /*0*/Ternary.False)
                    {
                        return result;
                    }
                }

                if ((source.Flags & TypeFlags.StringLiteral) != TypeFlags.None &&
                    target == m_checker.m_stringType)
                {
                    return Ternary.True;
                }

                if (m_relation == m_checker.m_assignableRelation || m_relation == m_checker.m_comparableRelation)
                {
                    if (IsTypeAny(source))
                    {
                        return Ternary.True;
                    }

                    if (source == m_checker.m_numberType &&
                        (target.Flags & TypeFlags.Enum) != TypeFlags.None)
                    {
                        return Ternary.True;
                    }
                }

                if ((source.Flags & TypeFlags.Boolean) != TypeFlags.None &&
                    (target.Flags & TypeFlags.Boolean) != TypeFlags.None)
                {
                    if ((source.Flags & TypeFlags.PredicateType) != TypeFlags.None &&
                        (target.Flags & TypeFlags.PredicateType) != TypeFlags.None)
                    {
                        var sourcePredicate = source.Cast<IPredicateType>();
                        var targetPredicate = target.Cast<IPredicateType>();

                        if (sourcePredicate.Predicate.Kind != targetPredicate.Predicate.Kind)
                        {
                            if (reportErrors)
                            {
                                ReportError(Errors.A_this_based_type_guard_is_not_compatible_with_a_parameter_based_type_guard);
                                ReportError(
                                    Errors.Type_predicate_0_is_not_assignable_to_1,
                                    m_checker.TypeToString(source),
                                    m_checker.TypeToString(target));
                            }

                            return Ternary.False;
                        }

                        if (sourcePredicate.Predicate.Kind == TypePredicateKind.Identifier)
                        {
                            var sourceIdentifierPredicate = (IIdentifierTypePredicate)sourcePredicate.Predicate;
                            var targetIdentifierPredicate = (IIdentifierTypePredicate)targetPredicate.Predicate;

                            if (sourceIdentifierPredicate.ParameterIndex != targetIdentifierPredicate.ParameterIndex)
                            {
                                if (reportErrors)
                                {
                                    ReportError(
                                        Errors.Parameter_0_is_not_in_the_same_position_as_parameter_1,
                                        sourceIdentifierPredicate.ParameterName,
                                        targetIdentifierPredicate.ParameterName);

                                    ReportError(
                                        Errors.Type_predicate_0_is_not_assignable_to_1,
                                        m_checker.TypeToString(source),
                                        m_checker.TypeToString(target));
                                }

                                return Ternary.False;
                            }
                        }

                        var related = IsRelatedTo(
                                        sourcePredicate.Predicate.Type,
                                        targetPredicate.Predicate.Type,
                                        reportErrors,
                                        headMessage);
                        if (related == Ternary.False && reportErrors)
                        {
                            ReportError(
                                Errors.Type_predicate_0_is_not_assignable_to_1,
                                m_checker.TypeToString(source),
                                m_checker.TypeToString(target));
                        }

                        return related;
                    }

                    return Ternary.True;
                }

                if ((source.Flags & TypeFlags.FreshObjectLiteral) != TypeFlags.None)
                {
                    if (HasExcessProperties(source.Cast<IFreshObjectLiteralType>(), target, reportErrors))
                    {
                        if (reportErrors)
                        {
                            ReportRelationError(
                                m_headMessage,
                                source,
                                target);
                        }

                        return Ternary.False;
                    }

                    // Above we check for excess properties with respect to the entire target type. When union
                    // and intersection types are further deconstructed on the target side, we don't want to
                    // make the check again (as it might fail for a partial target type). Therefore we obtain
                    // the regular source type and proceed with that.
                    if ((target.Flags & TypeFlags.UnionOrIntersection) != TypeFlags.None)
                    {
                        source = m_checker.GetRegularTypeOfObjectLiteral(source);
                    }
                }

                var saveErrorInfo = ErrorInfo;

                // Note that the "each" checks must precede the "some" checks to produce the correct results
                if ((source.Flags & TypeFlags.Union) != TypeFlags.None)
                {
                    if (m_relation == m_checker.m_comparableRelation)
                    {
                        result = SomeTypeRelatedToType(source.Cast<IUnionType>(), target, reportErrors);
                        if (result != /*0*/Ternary.False)
                        {
                            return result;
                        }
                    }
                    else
                    {
                        result = EachTypeRelatedToType(source.Cast<IUnionType>(), target, reportErrors);
                        if (result != /*0*/Ternary.False)
                        {
                            return result;
                        }
                    }
                }
                else if ((target.Flags & TypeFlags.Intersection) != TypeFlags.None)
                {
                    result = TypeRelatedToEachType(source, target.Cast<IIntersectionType>(), reportErrors);
                    if (result != /*0*/Ternary.False)
                    {
                        return result;
                    }
                }
                else
                {
                    // It is necessary to try "some" checks on both sides because there may be nested "each" checks
                    // on either side that need to be prioritized. For example, A | B = (A | B) & (C | D) or
                    // A & B = (A & B) | (C & D).
                    if ((source.Flags & TypeFlags.Intersection) != TypeFlags.None)
                    {
                        // If target is a union type the following check will report errors so we suppress them here
                        result = SomeTypeRelatedToType(
                                    source.Cast<IIntersectionType>(),
                                    target,
                                    reportErrors && (target.Flags & TypeFlags.Union) == TypeFlags.None);
                        if (result != /*0*/Ternary.False)
                        {
                            return result;
                        }
                    }

                    if ((target.Flags & TypeFlags.Union) != TypeFlags.None)
                    {
                        result = TypeRelatedToSomeType(source, target.Cast<IUnionType>(), reportErrors);
                        if (result != /*0*/Ternary.False)
                        {
                            return result;
                        }
                    }
                }

                if ((source.Flags & TypeFlags.TypeParameter) != TypeFlags.None)
                {
                    var constraint = m_checker.GetConstraintOfTypeParameter(source.Cast<ITypeParameter>());
                    if (constraint == null ||
                        (constraint.Flags & TypeFlags.Any) != TypeFlags.None)
                    {
                        constraint = m_checker.m_emptyObjectType;
                    }

                    // Report constraint errors only if the constraint is not the empty object type
                    var reportConstraintErrors = reportErrors && constraint != m_checker.m_emptyObjectType;

                    result = IsRelatedTo(constraint, target, reportConstraintErrors);
                    if (result != /*0*/Ternary.False)
                    {
                        ErrorInfo = saveErrorInfo;
                        return result;
                    }
                }
                else
                {
                    if ((source.Flags & TypeFlags.Reference) != TypeFlags.None &&
                        (target.Flags & TypeFlags.Reference) != TypeFlags.None &&
                        source.Cast<ITypeReference>().Target == target.Cast<ITypeReference>().Target)
                    {
                        // We have type references to same target type, see if relationship holds for all type arguments
                        result = TypeArgumentsRelatedTo(source.Cast<ITypeReference>(), target.Cast<ITypeReference>(), reportErrors);
                        if (result != /*0*/Ternary.False)
                        {
                            return result;
                        }
                    }

                    // Even if relationship doesn't hold for unions, intersections, or generic type references,
                    // it may hold in a structural comparison.
                    var apparentType = m_checker.GetApparentType(source);

                    // In a check of the form X = A & B, we will have previously checked if A relates to X or B relates
                    // to X. Failing both of those we want to check if the aggregation of A and B's members structurally
                    // relates to X. Thus, we include intersection types on the source side here.
                    if ((apparentType.Flags & (TypeFlags.ObjectType | TypeFlags.Intersection)) != TypeFlags.None &&
                        (target.Flags & TypeFlags.ObjectType) != TypeFlags.None)
                    {
                        // Report structural errors only if we haven't reported any errors yet
                        var reportStructuralErrors = reportErrors && (ErrorInfo == saveErrorInfo);

                        result = ObjectTypeRelatedTo(apparentType, source, target, reportStructuralErrors);
                        if (result != /*0*/Ternary.False)
                        {
                            ErrorInfo = saveErrorInfo;
                            return result;
                        }
                    }
                }

                if (reportErrors)
                {
                    ReportRelationError(headMessage, source, target);
                }

                return Ternary.False;
            }

            public Ternary IsIdenticalTo(IType source, IType target)
            {
                Ternary result;

                if ((source.Flags & TypeFlags.ObjectType) != TypeFlags.None &&
                    (target.Flags & TypeFlags.ObjectType) != TypeFlags.None)
                {
                    if ((source.Flags & TypeFlags.Reference) != TypeFlags.None &&
                        (target.Flags & TypeFlags.Reference) != TypeFlags.None &&
                        (source.Cast<ITypeReference>().Target == target.Cast<ITypeReference>().Target))
                    {
                        // We have type references to same target type, see if all type arguments are identical
                        result = TypeArgumentsRelatedTo(
                                    source.Cast<ITypeReference>(),
                                    target.Cast<ITypeReference>(),
                                    /*reportErrors*/ false);

                        if (result != /*0*/Ternary.False)
                        {
                            return result;
                        }
                    }

                    return ObjectTypeRelatedTo(source, source, target, /*reportErrors*/ false);
                }

                if (((source.Flags & TypeFlags.Union) != TypeFlags.None && (target.Flags & TypeFlags.Union) != TypeFlags.None) ||
                    ((source.Flags & TypeFlags.Intersection) != TypeFlags.None && (target.Flags & TypeFlags.Intersection) != TypeFlags.None))
                {
                    result = EachTypeRelatedToSomeType(source.Cast<IUnionOrIntersectionType>(), target.Cast<IUnionOrIntersectionType>());
                    if (result != /*0*/Ternary.False)
                    {
                        result &= EachTypeRelatedToSomeType(target.Cast<IUnionOrIntersectionType>(), source.Cast<IUnionOrIntersectionType>());
                        if (result != /*0*/Ternary.False)
                        {
                            return result;
                        }
                    }
                }

                return Ternary.False;
            }

            // Check if a property with the given name is known anywhere in the given type. In an object type, a property
            // is considered known if the object type is empty and the check is for assignability, if the object type has
            // index signatures, or if the property is actually declared in the object type. In a union or intersection
            // type, a property is considered known if it is known in any constituent type.
            public bool IsKnownProperty(IType type, string name)
            {
                if ((type.Flags & TypeFlags.ObjectType) != TypeFlags.None)
                {
                    var resolved = m_checker.ResolveStructuredTypeMembers(type);

                    if (((m_relation == m_checker.m_assignableRelation || m_relation == m_checker.m_comparableRelation) &&
                        (type == m_checker.m_globalObjectType || resolved.Properties.Count == 0)) ||
                        resolved.StringIndexType != null ||
                        resolved.NumberIndexType != null ||
                        m_checker.GetPropertyOfType(type, name) != null)
                    {
                        return true;
                    }
                }
                else if ((type.Flags & TypeFlags.UnionOrIntersection) != TypeFlags.None)
                {
                    foreach (var t in type.Cast<IUnionOrIntersectionType>().Types)
                    {
                        if (IsKnownProperty(t, name))
                        {
                            return true;
                        }
                    }
                }

                return false;
            }

            public bool HasExcessProperties(IFreshObjectLiteralType source, IType target, bool reportErrors)
            {
                if ((target.Flags & TypeFlags.ObjectLiteralPatternWithComputedProperties) == TypeFlags.None &&
                    m_checker.MaybeTypeOfKind(target, TypeFlags.ObjectType))
                {
                    foreach (var prop in m_checker.GetPropertiesOfObjectType(source).AsStructEnumerable())
                    {
                        if (!IsKnownProperty(target, prop.Name))
                        {
                            if (reportErrors)
                            {
                                // We know *exactly* where things went wrong when comparing the types.
                                // Use this property as the error node as this will be more helpful in
                                // reasoning about what went wrong.
                                ReportError(
                                    Errors.Object_literal_may_only_specify_known_properties_and_0_does_not_exist_in_type_1,
                                    m_checker.SymbolToString(prop),
                                    m_checker.TypeToString(target));
                            }

                            return true;
                        }
                    }
                }

                return false;
            }

            public Ternary EachTypeRelatedToSomeType(IUnionOrIntersectionType source, IUnionOrIntersectionType target)
            {
                var result = Ternary.True;
                var sourceTypes = source.Types;

                foreach (var sourceType in sourceTypes)
                {
                    var related = TypeRelatedToSomeType(sourceType, target, /*reportErrors*/ false);
                    if (related == /*0*/Ternary.False)
                    {
                        return Ternary.False;
                    }

                    result &= related;
                }

                return result;
            }

            public Ternary TypeRelatedToSomeType(IType source, IUnionOrIntersectionType target, bool reportErrors)
            {
                var targetTypes = target.Types;
                for (int i = 0, len = targetTypes.Count; i < len; i++)
                {
                    var related = IsRelatedTo(source, targetTypes[i], reportErrors && i == len - 1);
                    if (related != /*0*/Ternary.False)
                    {
                        return related;
                    }
                }

                return Ternary.False;
            }

            public Ternary TypeRelatedToEachType(IType source, IUnionOrIntersectionType target, bool reportErrors)
            {
                var result = Ternary.True;
                var targetTypes = target.Types;
                foreach (var targetType in targetTypes)
                {
                    var related = IsRelatedTo(source, targetType, reportErrors);
                    if (related == /*0*/Ternary.False)
                    {
                        return Ternary.False;
                    }

                    result &= related;
                }

                return result;
            }

            public Ternary SomeTypeRelatedToType(IUnionOrIntersectionType source, IType target, bool reportErrors)
            {
                var sourceTypes = source.Types;
                for (int i = 0, len = sourceTypes.Count; i < len; i++)
                {
                    var related = IsRelatedTo(sourceTypes[i], target, reportErrors && i == len - 1);
                    if (related != /*0*/Ternary.False)
                    {
                        return related;
                    }
                }

                return Ternary.False;
            }

            public Ternary EachTypeRelatedToType(IUnionOrIntersectionType source, IType target, bool reportErrors)
            {
                var result = Ternary.True;
                var sourceTypes = source.Types;
                foreach (var sourceType in sourceTypes)
                {
                    var related = IsRelatedTo(sourceType, target, reportErrors);
                    if (related == /*0*/Ternary.False)
                    {
                        return Ternary.False;
                    }

                    result &= related;
                }

                return result;
            }

            public Ternary TypeArgumentsRelatedTo(ITypeReference source, ITypeReference target, bool reportErrors)
            {
                var sources = source.TypeArguments ?? EmptyArray<IType>();
                var targets = target.TypeArguments ?? EmptyArray<IType>();

                if (sources.Count != targets.Count && m_relation == m_checker.m_identityRelation)
                {
                    return Ternary.False;
                }

                var length = sources.Count <= targets.Count ? sources.Count : targets.Count;
                var result = Ternary.True;

                for (var i = 0; i < length; i++)
                {
                    var related = IsRelatedTo(sources[i], targets[i], reportErrors);
                    if (related == /*0*/Ternary.False)
                    {
                        return Ternary.False;
                    }

                    result &= related;
                }

                return result;
            }

            // Determine if two object types are related by structure. First, check if the result is already available in the global cache.
            // Second, check if we have already started a comparison of the given two types in which case we assume the result to be true.
            // Third, check if both types are part of deeply nested chains of generic type instantiations and if so assume the types are
            // equal and infinitely expanding. Fourth, if we have reached a depth of 100 nested comparisons, assume we have runaway recursion
            // and issue an error. Otherwise, actually compare the structure of the two types.
            public Ternary ObjectTypeRelatedTo(IType source, IType originalSource, IType target, bool reportErrors)
            {
                if (Overflow)
                {
                    return Ternary.False;
                }

                // Instead of using string as a key, it could be better to switch to a custom key.
                // The following code allocates a lot.
                var id = m_relation != m_checker.m_identityRelation || source.Id < target.Id ?
                            string.Concat(source.Id.ToString(), ",", target.Id.ToString()) :
                            string.Concat(target.Id.ToString(), ",", source.Id.ToString());

                RelationComparisonResult related;
                if (m_relation.TryGetValue(id, out related))
                {
                    if (ElaborateErrors && related == RelationComparisonResult.Failed)
                    {
                        // We are elaborating errors and the cached result is an unreported failure. Record the result as a reported
                        // failure and continue computing the relation such that errors get reported.
                        m_relation[id] = RelationComparisonResult.FailedAndReported;
                    }
                    else
                    {
                        return related == RelationComparisonResult.Succeeded ? Ternary.True : Ternary.False;
                    }
                }

                if (m_depth > 0)
                {
                    for (var i = 0; i < m_depth; i++)
                    {
                        // If source and target are already being compared, consider them related with assumptions
                        if (m_maybeStack[i].ContainsKey(id))
                        {
                            return Ternary.Maybe;
                        }
                    }

                    if (m_depth == 100)
                    {
                        Overflow = true;
                        return Ternary.False;
                    }
                }
                else
                {
                    m_sourceStack.Clear();
                    m_targetStack.Clear();
                    m_maybeStack.Clear();
                    m_expandingFlags = 0;
                }

                m_sourceStack[m_depth] = source;
                m_targetStack[m_depth] = target;
                m_maybeStack[m_depth] = new Map<RelationComparisonResult>();
                m_maybeStack[m_depth][id] = RelationComparisonResult.Succeeded;
                m_depth++;

                var saveExpandingFlags = m_expandingFlags;

                if ((m_expandingFlags & 1) == 0 &&
                    IsDeeplyNestedGeneric(source, m_sourceStack.Values, m_depth))
                {
                    m_expandingFlags |= 1;
                }

                if ((m_expandingFlags & 2) == 0 &&
                    IsDeeplyNestedGeneric(target, m_targetStack.Values, m_depth))
                {
                    m_expandingFlags |= 2;
                }

                Ternary result;
                if (m_expandingFlags == 3)
                {
                    result = Ternary.Maybe;
                }
                else
                {
                    result = PropertiesRelatedTo(source, target, reportErrors);
                    if (result != /*0*/Ternary.False)
                    {
                        result &= SignaturesRelatedTo(source, target, SignatureKind.Call, reportErrors);
                        if (result != /*0*/Ternary.False)
                        {
                            result &= SignaturesRelatedTo(source, target, SignatureKind.Construct, reportErrors);
                            if (result != /*0*/Ternary.False)
                            {
                                result &= StringIndexTypesRelatedTo(source, originalSource, target, reportErrors);
                                if (result != /*0*/Ternary.False)
                                {
                                    result &= NumberIndexTypesRelatedTo(source, originalSource, target, reportErrors);
                                }
                            }
                        }
                    }
                }

                m_expandingFlags = saveExpandingFlags;
                m_depth--;

                if (result != /*0*/Ternary.False)
                {
                    var maybeCache = m_maybeStack[m_depth];

                    // If result is definitely true, copy assumptions to global cache, else copy to next level up
                    var destinationCache = result == Ternary.True || m_depth == 0 ?
                                            (IDictionary<string, RelationComparisonResult>)m_relation :
                                            m_maybeStack[m_depth - 1];

                    CopyMap(maybeCache, destinationCache);
                }
                else
                {
                    // A false result goes straight into global cache (when something is false under assumptions it
                    // will also be false without assumptions)
                    m_relation[id] = reportErrors ? RelationComparisonResult.FailedAndReported : RelationComparisonResult.Failed;
                }

                return result;
            }

            private Ternary PropertiesRelatedTo(IType source, IType target, bool reportErrors)
            {
                if (m_relation == m_checker.m_identityRelation)
                {
                    return PropertiesIdenticalTo(source, target);
                }

                var result = Ternary.True;
                var properties = m_checker.GetPropertiesOfObjectType(target);
                var requireOptionalProperties = (m_relation == m_checker.m_subtypeRelation) &&
                                                (source.Flags & TypeFlags.ObjectLiteral) == TypeFlags.None;

                foreach (var targetProp in properties.AsStructEnumerable())
                {
                    var sourceProp = m_checker.GetPropertyOfType(source, targetProp.Name);

                    if (sourceProp != targetProp)
                    {
                        if (sourceProp == null)
                        {
                            if ((targetProp.Flags & SymbolFlags.Optional) == SymbolFlags.None ||
                                requireOptionalProperties)
                            {
                                if (reportErrors)
                                {
                                    ReportError(
                                        Errors.Property_0_is_missing_in_type_1,
                                        m_checker.SymbolToString(targetProp),
                                        m_checker.TypeToString(source));
                                }

                                return Ternary.False;
                            }
                        }
                        else if ((targetProp.Flags & SymbolFlags.Prototype) == SymbolFlags.None)
                        {
                            var sourcePropFlags = GetDeclarationFlagsFromSymbol(sourceProp);
                            var targetPropFlags = GetDeclarationFlagsFromSymbol(targetProp);

                            if ((sourcePropFlags & NodeFlags.Private) != NodeFlags.None ||
                                (targetPropFlags & NodeFlags.Private) != NodeFlags.None)
                            {
                                if (sourceProp.ValueDeclaration != targetProp.ValueDeclaration)
                                {
                                    if (reportErrors)
                                    {
                                        if ((sourcePropFlags & NodeFlags.Private) != NodeFlags.None &&
                                            (targetPropFlags & NodeFlags.Private) != NodeFlags.None)
                                        {
                                            ReportError(
                                                Errors.Types_have_separate_declarations_of_a_private_property_0,
                                                m_checker.SymbolToString(targetProp));
                                        }
                                        else
                                        {
                                            ReportError(
                                                Errors.Property_0_is_private_in_type_1_but_not_in_type_2,
                                                m_checker.SymbolToString(targetProp),
                                                m_checker.TypeToString((sourcePropFlags & NodeFlags.Private) != NodeFlags.None ? source : target),
                                                m_checker.TypeToString((sourcePropFlags & NodeFlags.Private) != NodeFlags.None ? target : source));
                                        }
                                    }

                                    return Ternary.False;
                                }
                            }
                            else if ((targetPropFlags & NodeFlags.Protected) != NodeFlags.None)
                            {
                                var sourceDeclaredInClass = sourceProp.Parent != null && (sourceProp.Parent.Flags & SymbolFlags.Class) != SymbolFlags.None;
                                var sourceClass = sourceDeclaredInClass ?
                                                    m_checker.GetDeclaredTypeOfSymbol(sourceProp.Parent).Cast<IInterfaceType>() :
                                                    null;

                                var targetClass = m_checker.GetDeclaredTypeOfSymbol(targetProp.Parent).Cast<IInterfaceType>();

                                if (sourceClass == null ||
                                    !m_checker.HasBaseType(sourceClass, targetClass))
                                {
                                    if (reportErrors)
                                    {
                                        ReportError(
                                            Errors.Property_0_is_protected_but_type_1_is_not_a_class_derived_from_2,
                                            m_checker.SymbolToString(targetProp),
                                            m_checker.TypeToString(sourceClass ?? source),
                                            m_checker.TypeToString(targetClass));
                                    }

                                    return Ternary.False;
                                }
                            }
                            else if ((sourcePropFlags & NodeFlags.Protected) != NodeFlags.None)
                            {
                                if (reportErrors)
                                {
                                    ReportError(
                                        Errors.Property_0_is_protected_in_type_1_but_public_in_type_2,
                                        m_checker.SymbolToString(targetProp),
                                        m_checker.TypeToString(source),
                                        m_checker.TypeToString(target));
                                }

                                return Ternary.False;
                            }

                            var related = IsRelatedTo(
                                            m_checker.GetTypeOfSymbol(sourceProp),
                                            m_checker.GetTypeOfSymbol(targetProp),
                                            reportErrors);
                            if (related == /*0*/Ternary.False)
                            {
                                if (reportErrors)
                                {
                                    ReportError(
                                        Errors.Types_of_property_0_are_incompatible,
                                        m_checker.SymbolToString(targetProp));
                                }

                                return Ternary.False;
                            }

                            result &= related;

                            if ((sourceProp.Flags & SymbolFlags.Optional) != SymbolFlags.None &&
                                (targetProp.Flags & SymbolFlags.Optional) == SymbolFlags.None)
                            {
                                // TypeScript 1.0 spec (April 2014): 3.8.3
                                // S is a subtype of a type T, and T is a supertype of S if ...
                                // S' and T are object types and, for each member M in T..
                                // M is a property and S' contains a property N where
                                // if M is a required property, N is also a required property
                                // (M - property in T)
                                // (N - property in S)
                                if (reportErrors)
                                {
                                    ReportError(
                                        Errors.Property_0_is_optional_in_type_1_but_required_in_type_2,
                                        m_checker.SymbolToString(targetProp),
                                        m_checker.TypeToString(source),
                                        m_checker.TypeToString(target));
                                }

                                return Ternary.False;
                            }
                        }
                    }
                }

                return result;
            }

            private Ternary PropertiesIdenticalTo(IType source, IType target)
            {
                if (!((source.Flags & TypeFlags.ObjectType) != TypeFlags.None && (target.Flags & TypeFlags.ObjectType) != TypeFlags.None))
                {
                    return Ternary.False;
                }

                var sourceProperties = m_checker.GetPropertiesOfObjectType(source);
                var targetProperties = m_checker.GetPropertiesOfObjectType(target);
                if (sourceProperties.Count != targetProperties.Count)
                {
                    return Ternary.False;
                }

                var result = Ternary.True;
                foreach (var sourceProp in sourceProperties.AsStructEnumerable())
                {
                    var targetProp = m_checker.GetPropertyOfObjectType(target, sourceProp.Name);
                    if (targetProp == null)
                    {
                        return Ternary.False;
                    }

                    var related = m_checker.CompareProperties(sourceProp, targetProp, (s, t) => IsRelatedTo(s, t));
                    if (related == /*0*/Ternary.False)
                    {
                        return Ternary.False;
                    }

                    result &= related;
                }

                return result;
            }

            public Ternary SignaturesRelatedTo(IType source, IType target, SignatureKind kind, bool reportErrors)
            {
                if (m_relation == m_checker.m_identityRelation)
                {
                    return SignaturesIdenticalTo(source, target, kind);
                }

                if (target == m_checker.m_anyFunctionType || source == m_checker.m_anyFunctionType)
                {
                    return Ternary.True;
                }

                var sourceSignatures = m_checker.GetSignaturesOfType(source, kind);
                var targetSignatures = m_checker.GetSignaturesOfType(target, kind);
                var result = Ternary.True;
                var saveErrorInfo = ErrorInfo;

                // HINT: latest checker has changed compared to ported one.
                // TypeScript/JavaScript allows to index array outside of its bounds and returns undefined.
                // To avoid ArgumentOutOfRangeException following if statement has been changed
                if (kind == SignatureKind.Construct && sourceSignatures.Count != 0 && targetSignatures.Count != 0)
                {
                    // Only want to compare the construct signatures for abstractness guarantees.

                    // Because the "abstractness" of a class is the same across all construct signatures
                    // (internally we are checking the corresponding declaration), it is enough to perform
                    // the check and report an error once over all pairs of source and target construct signatures.
                    //
                    // sourceSig and targetSig are (possibly) undefined.
                    //
                    // Note that in an extends-clause, targetSignatures is stripped, so the check never proceeds.
                    var sourceSig = sourceSignatures[0];
                    var targetSig = targetSignatures[0];

                    result &= AbstractSignatureRelatedTo(source, sourceSig, target, targetSig, reportErrors);
                    if (result != Ternary.True)
                    {
                        return result;
                    }
                }

                // HINT: TS implementation uses goto to continue the outer foreach.
                //       In this ported version we instead use a flag.
                bool continueOuter = false;
                foreach (var t in targetSignatures.AsStructEnumerable())
                {
                    continueOuter = false;

                    if (!t.HasStringLiterals || (target.Flags & TypeFlags.FromSignature) != TypeFlags.None)
                    {
                        // Only elaborate errors from the first failure
                        var shouldElaborateErrors = reportErrors;
                        foreach (var s in sourceSignatures.AsStructEnumerable())
                        {
                            if (!s.HasStringLiterals || (source.Flags & TypeFlags.FromSignature) != TypeFlags.None)
                            {
                                var related = SignatureRelatedTo(s, t, shouldElaborateErrors);
                                if (related != /*0*/Ternary.False)
                                {
                                    result &= related;
                                    ErrorInfo = saveErrorInfo;

                                    continueOuter = true;
                                    break;
                                }

                                shouldElaborateErrors = false;
                            }
                        }

                        if (continueOuter)
                        {
                            continue;
                        }

                        // don't elaborate the primitive apparent types (like Number)
                        // because the actual primitives will have already been reported.
                        if (shouldElaborateErrors && !m_checker.IsPrimitiveApparentType(source))
                        {
                            ReportError(
                                Errors.Type_0_provides_no_match_for_the_signature_1,
                                m_checker.TypeToString(source),
                                m_checker.SignatureToString(t, /*enclosingDeclaration*/ null, /*flags*/ TypeFormatFlags.None, kind));
                        }

                        return Ternary.False;
                    }
                }

                return result;
            }

            public Ternary AbstractSignatureRelatedTo(IType source, ISignature sourceSig, IType target, ISignature targetSig, bool reportErrors)
            {
                if (sourceSig != null && targetSig != null)
                {
                    var sourceDecl = source.Symbol != null ? GetClassLikeDeclarationOfSymbol(source.Symbol) : null;
                    var targetDecl = target.Symbol != null ? GetClassLikeDeclarationOfSymbol(target.Symbol) : null;

                    if (sourceDecl == null)
                    {
                        // If the source object isn't itself a class declaration, it can be freely assigned, regardless
                        // of whether the constructed object is abstract or not.
                        return Ternary.True;
                    }

                    var sourceErasedSignature = m_checker.GetErasedSignature(sourceSig);
                    var targetErasedSignature = m_checker.GetErasedSignature(targetSig);

                    var sourceReturnType = sourceErasedSignature != null ? m_checker.GetReturnTypeOfSignature(sourceErasedSignature) : null;
                    var targetReturnType = targetErasedSignature != null ? m_checker.GetReturnTypeOfSignature(targetErasedSignature) : null;

                    var sourceReturnDecl = sourceReturnType?.Symbol != null ?
                                            GetClassLikeDeclarationOfSymbol(sourceReturnType.Symbol) :
                                            null;
                    var targetReturnDecl = targetReturnType?.Symbol != null ?
                                            GetClassLikeDeclarationOfSymbol(targetReturnType.Symbol) :
                                            null;

                    var sourceIsAbstract = (sourceReturnDecl != null) && (sourceReturnDecl.Flags & NodeFlags.Abstract) != NodeFlags.None;
                    var targetIsAbstract = (targetReturnDecl != null) && (targetReturnDecl.Flags & NodeFlags.Abstract) != NodeFlags.None;

                    if (sourceIsAbstract && !(targetIsAbstract && targetDecl != null))
                    {
                        // if target isn't a class-declaration type, then it can be new'd, so we forbid the assignment.
                        if (reportErrors)
                        {
                            ReportError(Errors.Cannot_assign_an_abstract_constructor_type_to_a_non_abstract_constructor_type);
                        }

                        return Ternary.False;
                    }
                }

                return Ternary.True;
            }

            /// <summary>
            /// See signatureAssignableTo, signatureAssignableTo
            /// </summary>
            public Ternary SignatureRelatedTo(ISignature source, ISignature target, bool reportErrors)
            {
                // TODO: De-duplicate code between related functions.
                if (source == target)
                {
                    return Ternary.True;
                }

                if (!target.HasRestParameter && source.MinArgumentCount > target.Parameters.Count)
                {
                    return Ternary.False;
                }

                var sourceMax = source.Parameters.Count;
                var targetMax = target.Parameters.Count;
                int checkCount;

                if (source.HasRestParameter && target.HasRestParameter)
                {
                    checkCount = sourceMax > targetMax ? sourceMax : targetMax;
                    sourceMax--;
                    targetMax--;
                }
                else if (source.HasRestParameter)
                {
                    sourceMax--;
                    checkCount = targetMax;
                }
                else if (target.HasRestParameter)
                {
                    targetMax--;
                    checkCount = sourceMax;
                }
                else
                {
                    checkCount = sourceMax < targetMax ? sourceMax : targetMax;
                }

                // Spec 1.0 Section 3.8.3 & 3.8.4:
                // M and N (the signatures) are instantiated using type Any as the type argument for all type parameters declared by M and N
                source = m_checker.GetErasedSignature(source);
                target = m_checker.GetErasedSignature(target);

                var result = Ternary.True;

                for (var i = 0; i < checkCount; i++)
                {
                    var s = i < sourceMax ? m_checker.GetTypeOfSymbol(source.Parameters[i]) : m_checker.GetRestTypeOfSignature(source);
                    var t = i < targetMax ? m_checker.GetTypeOfSymbol(target.Parameters[i]) : m_checker.GetRestTypeOfSignature(target);

                    var saveErrorInfo = ErrorInfo;
                    var related = IsRelatedTo(s, t, reportErrors);
                    if (related == /*0*/Ternary.False)
                    {
                        related = IsRelatedTo(t, s, /*reportErrors*/ false);
                        if (related == /*0*/Ternary.False)
                        {
                            if (reportErrors)
                            {
                                ReportError(
                                    Errors.Types_of_parameters_0_and_1_are_incompatible,
                                    source.Parameters[i < sourceMax ? i : sourceMax].Name,
                                    target.Parameters[i < targetMax ? i : targetMax].Name);
                            }

                            return Ternary.False;
                        }

                        ErrorInfo = saveErrorInfo;
                    }

                    result &= related;
                }

                var targetReturnType = m_checker.GetReturnTypeOfSignature(target);
                if (targetReturnType == m_checker.m_voidType)
                {
                    return result;
                }

                var sourceReturnType = m_checker.GetReturnTypeOfSignature(source);

                // The following block preserves behavior forbidding bool returning functions from being assignable to type guard returning functions
                if ((targetReturnType.Flags & TypeFlags.PredicateType) != TypeFlags.None &&
                    (targetReturnType.Cast<IPredicateType>().Predicate.Kind == TypePredicateKind.Identifier))
                {
                    if ((sourceReturnType.Flags & TypeFlags.PredicateType) == TypeFlags.None)
                    {
                        if (reportErrors)
                        {
                            ReportError(
                                Errors.Signature_0_must_have_a_type_predicate,
                                m_checker.SignatureToString(source));
                        }

                        return Ternary.False;
                    }
                }

                return result & IsRelatedTo(sourceReturnType, targetReturnType, reportErrors);
            }

            public Ternary SignaturesIdenticalTo(IType source, IType target, SignatureKind kind)
            {
                var sourceSignatures = m_checker.GetSignaturesOfType(source, kind);
                var targetSignatures = m_checker.GetSignaturesOfType(target, kind);

                if (sourceSignatures.Count != targetSignatures.Count)
                {
                    return Ternary.False;
                }

                var result = Ternary.True;
                for (int i = 0, len = sourceSignatures.Count; i < len; ++i)
                {
                    var related = m_checker.CompareSignaturesIdentical(
                                    sourceSignatures[i],
                                    targetSignatures[i],
                                    /*partialMatch*/ false,
                                    /*ignoreReturnTypes*/ false,
                                    (s, t) => IsRelatedTo(s, t));

                    if (related == /*0*/Ternary.False)
                    {
                        return Ternary.False;
                    }

                    result &= related;
                }

                return result;
            }

            public Ternary StringIndexTypesRelatedTo(IType source, IType originalSource, IType target, bool reportErrors)
            {
                if (m_relation == m_checker.m_identityRelation)
                {
                    return IndexTypesIdenticalTo(IndexKind.String, source, target);
                }

                var targetType = m_checker.GetIndexTypeOfType(target, IndexKind.String);
                if (targetType != null)
                {
                    if ((targetType.Flags & TypeFlags.Any) != TypeFlags.None &&
                        (originalSource.Flags & TypeFlags.Primitive) == TypeFlags.None)
                    {
                        // non-primitive assignment to any is always allowed, eg
                        //   `var x: { [index: string]: any } = { property: 12 };`
                        return Ternary.True;
                    }

                    var sourceType = m_checker.GetIndexTypeOfType(source, IndexKind.String);
                    if (sourceType == null)
                    {
                        if (reportErrors)
                        {
                            ReportError(
                                Errors.Index_signature_is_missing_in_type_0,
                                m_checker.TypeToString(source));
                        }

                        return Ternary.False;
                    }

                    var related = IsRelatedTo(sourceType, targetType, reportErrors);
                    if (related == /*0*/Ternary.False)
                    {
                        if (reportErrors)
                        {
                            ReportError(Errors.Index_signatures_are_incompatible);
                        }

                        return Ternary.False;
                    }

                    return related;
                }

                return Ternary.True;
            }

            public Ternary NumberIndexTypesRelatedTo(IType source, IType originalSource, IType target, bool reportErrors)
            {
                if (m_relation == m_checker.m_identityRelation)
                {
                    return IndexTypesIdenticalTo(IndexKind.Number, source, target);
                }

                var targetType = m_checker.GetIndexTypeOfType(target, IndexKind.Number);
                if (targetType != null)
                {
                    if ((targetType.Flags & TypeFlags.Any) != TypeFlags.None &&
                        (originalSource.Flags & TypeFlags.Primitive) == TypeFlags.None)
                    {
                        // non-primitive assignment to any is always allowed, eg
                        //   `var x: { [index: number]: any } = { property: 12 };`
                        return Ternary.True;
                    }

                    var sourceStringType = m_checker.GetIndexTypeOfType(source, IndexKind.String);
                    var sourceNumberType = m_checker.GetIndexTypeOfType(source, IndexKind.Number);
                    if (!(sourceStringType != null || sourceNumberType != null))
                    {
                        if (reportErrors)
                        {
                            ReportError(
                                Errors.Index_signature_is_missing_in_type_0,
                                m_checker.TypeToString(source));
                        }

                        return Ternary.False;
                    }

                    Ternary related;
                    if (sourceStringType != null && sourceNumberType != null)
                    {
                        // If we know for sure we're testing both string and numeric index types then only report errors from the second one
                        related = IsRelatedTo(sourceStringType, targetType, /*reportErrors*/ false);
                        if (related == /*0*/Ternary.False)
                        {
                            related = IsRelatedTo(sourceNumberType, targetType, reportErrors);
                        }
                    }
                    else
                    {
                        related = IsRelatedTo(sourceStringType ?? sourceNumberType, targetType, reportErrors);
                    }

                    if (related == /*0*/Ternary.False)
                    {
                        if (reportErrors)
                        {
                            ReportError(Errors.Index_signatures_are_incompatible);
                        }

                        return Ternary.False;
                    }

                    return related;
                }

                return Ternary.True;
            }

            public Ternary IndexTypesIdenticalTo(IndexKind indexKind, IType source, IType target)
            {
                var targetType = m_checker.GetIndexTypeOfType(target, indexKind);
                var sourceType = m_checker.GetIndexTypeOfType(source, indexKind);

                if (sourceType == null && targetType == null)
                {
                    return Ternary.True;
                }

                if (sourceType != null && targetType != null)
                {
                    return IsRelatedTo(sourceType, targetType);
                }

                return Ternary.False;
            }

            public Ternary EnumRelatedTo(IType source, IType target)
            {
                Contract.Requires(source != null);
                Contract.Requires(source.Symbol != null);
                Contract.Requires(target != null);
                Contract.Requires(target.Symbol != null);

                if (source.Symbol.Name.Equals(target.Symbol.Name, StringComparison.CurrentCulture) ||
                    (source.Symbol.Flags & SymbolFlags.ConstEnum) != SymbolFlags.None ||
                    (target.Symbol.Flags & SymbolFlags.ConstEnum) != SymbolFlags.None)
                {
                    return Ternary.False;
                }

                var targetEnumType = m_checker.GetTypeOfSymbol(target.Symbol);

                foreach (var property in m_checker.GetPropertiesOfType(m_checker.GetTypeOfSymbol(source.Symbol)).AsStructEnumerable())
                {
                    if ((property.Flags & SymbolFlags.EnumMember) != SymbolFlags.None)
                    {
                        var targetProperty = m_checker.GetPropertyOfType(targetEnumType, property.Name);

                        if (targetProperty == null ||
                            (targetProperty.Flags & SymbolFlags.EnumMember) == SymbolFlags.None)
                        {
                            ReportError(
                                Errors.Property_0_is_missing_in_type_1,
                                property.Name,
                                m_checker.TypeToString(target, /*enclosingDeclaration*/ null, TypeFormatFlags.UseFullyQualifiedType));

                            return Ternary.False;
                        }
                    }
                }

                return Ternary.True;
            }
        }

        // Return true if the given type is part of a deeply nested chain of generic instantiations. We consider this to be the case
        // when structural type comparisons have been started for 10 or more instantiations of the same generic type. It is possible,
        // though highly unlikely, for this test to be true in a situation where a chain of instantiations is not infinitely expanding.
        // Effectively, we will generate a false positive when two types are structurally equal to at least 10 levels, but unequal at
        // some level beyond that.
        private static bool IsDeeplyNestedGeneric(IType type, Dictionary<int, IType>.ValueCollection stack, int depth)
        {
            // We track type references (created by CreateTypeReference) and instantiated types (created by instantiateType)
            if ((type.Flags & (TypeFlags.Reference | TypeFlags.Instantiated)) != TypeFlags.None &&
                depth >= 5)
            {
                var symbol = type.Symbol;
                var count = 0;

                foreach (var t in stack)
                {
                    if ((t.Flags & (TypeFlags.Reference | TypeFlags.Instantiated)) != TypeFlags.None &&
                        (t.Symbol == symbol))
                    {
                        count++;
                        if (count >= 5)
                        {
                            return true;
                        }
                    }
                }
            }

            return false;
        }

        private bool IsPropertyIdenticalTo(ISymbol sourceProp, ISymbol targetProp)
        {
            return CompareProperties(sourceProp, targetProp, CompareTypesIdentical) != Ternary.False;
        }

        private Ternary CompareProperties(ISymbol sourceProp, ISymbol targetProp, Func<IType/*source*/, IType/*target*/, Ternary> compareTypes)
        {
            // Two members are considered identical when
            // - they are public properties with identical names, optionality, and types,
            // - they are private or protected properties originating in the same declaration and having identical types
            if (sourceProp == targetProp)
            {
                return Ternary.True;
            }

            var sourcePropAccessibility = GetDeclarationFlagsFromSymbol(sourceProp) & (NodeFlags.Private | NodeFlags.Protected);
            var targetPropAccessibility = GetDeclarationFlagsFromSymbol(targetProp) & (NodeFlags.Private | NodeFlags.Protected);

            if (sourcePropAccessibility != targetPropAccessibility)
            {
                return Ternary.False;
            }

            if (sourcePropAccessibility != NodeFlags.None)
            {
                if (GetTargetSymbol(sourceProp) != GetTargetSymbol(targetProp))
                {
                    return Ternary.False;
                }
            }
            else
            {
                if ((sourceProp.Flags & SymbolFlags.Optional) != (targetProp.Flags & SymbolFlags.Optional))
                {
                    return Ternary.False;
                }
            }

            return compareTypes(GetTypeOfSymbol(sourceProp), GetTypeOfSymbol(targetProp));
        }

        private static bool IsMatchingSignature(ISignature source, ISignature target, bool partialMatch)
        {
            // A source signature matches a target signature if the two signatures have the same number of required,
            // optional, and rest parameters.
            if (source.Parameters.Count == target.Parameters.Count &&
                source.MinArgumentCount == target.MinArgumentCount &&
                source.HasRestParameter == target.HasRestParameter)
            {
                return true;
            }

            // A source signature partially matches a target signature if the target signature has no fewer required
            // parameters and no more overall parameters than the source signature (where a signature with a rest
            // parameter is always considered to have more overall parameters than one without).
            if (partialMatch &&
                source.MinArgumentCount <= target.MinArgumentCount &&
                ((source.HasRestParameter && !target.HasRestParameter) || (source.HasRestParameter == target.HasRestParameter && source.Parameters.Count >= target.Parameters.Count)))
            {
                return true;
            }

            return false;
        }

        /// <summary>
        /// See signatureRelatedTo, compareSignaturesIdentical
        /// </summary>
        private Ternary CompareSignaturesIdentical(
            ISignature source,
            ISignature target,
            bool partialMatch,
            bool ignoreReturnTypes,
            Func<IType /*s*/, IType /*t*/, Ternary> compareTypes)
        {
            // TODO: De-duplicate code between related functions.
            if (source == target)
            {
                return Ternary.True;
            }

            if (!IsMatchingSignature(source, target, partialMatch))
            {
                return Ternary.False;
            }

            // Check that the two signatures have the same number of type parameters. We might consider
            // also checking that any type parameter constraints match, but that would require instantiating
            // the constraints with a common set of type arguments to get relatable entities in places where
            // type parameters occur in the constraints. The complexity of doing that doesn't seem worthwhile,
            // particularly as we're comparing erased versions of the signatures below.
            if ((source.TypeParameters != null ? source.TypeParameters.Count : 0) !=
                (target.TypeParameters != null ? target.TypeParameters.Count : 0))
            {
                return Ternary.False;
            }

            // Spec 1.0 Section 3.8.3 & 3.8.4:
            // M and N (the signatures) are instantiated using type Any as the type argument for all type parameters declared by M and N
            source = GetErasedSignature(source);
            target = GetErasedSignature(target);

            var result = Ternary.True;
            var targetLen = target.Parameters.Count;
            for (var i = 0; i < targetLen; i++)
            {
                var s = IsRestParameterIndex(source, i) ?
                            GetRestTypeOfSignature(source) :
                            GetTypeOfSymbol(source.Parameters[i]);

                var t = IsRestParameterIndex(target, i) ?
                            GetRestTypeOfSignature(target) :
                            GetTypeOfSymbol(target.Parameters[i]);

                var related = compareTypes(s, t);
                if (related == /*0*/Ternary.False)
                {
                    return Ternary.False;
                }

                result &= related;
            }

            if (!ignoreReturnTypes)
            {
                result &= compareTypes(GetReturnTypeOfSignature(source), GetReturnTypeOfSignature(target));
            }

            return result;
        }

        [System.Diagnostics.Contracts.Pure]
        private static bool IsRestParameterIndex(ISignature signature, int parameterIndex)
        {
            return signature.HasRestParameter && parameterIndex >= signature.Parameters.Count - 1;
        }

        private bool IsSupertypeOfEach(IType candidate, List<IType> types)
        {
            foreach (var type in types)
            {
                if (candidate != type && !IsTypeSubtypeOf(type, candidate))
                {
                    return false;
                }
            }

            return true;
        }

        private IType GetCommonSupertype(List<IType> types)
        {
            return ForEachUntil(types, t => IsSupertypeOfEach(t, types) ? t : null);
        }

        private void ReportNoCommonSupertypeError(List<IType> types, INode errorLocation, DiagnosticMessageChain errorMessageChainHead)
        {
            // The downfallType/bestSupertypeDownfallType is the first type that caused a particular candidate
            // to not be the common supertype. So if it weren't for this one downfallType (and possibly others),
            // the type in question could have been the common supertype.
            IType bestSupertype = null;
            IType bestSupertypeDownfallType = null;
            var bestSupertypeScore = 0;

            for (var i = 0; i < types.Count; i++)
            {
                var score = 0;
                IType downfallType = null;

                for (var j = 0; j < types.Count; j++)
                {
                    if (IsTypeSubtypeOf(types[j], types[i]))
                    {
                        score++;
                    }
                    else if (downfallType == null)
                    {
                        downfallType = types[j];
                    }
                }

                Contract.Assert(downfallType != null, "If there is no common supertype, each type should have a downfallType");

                if (score > bestSupertypeScore)
                {
                    bestSupertype = types[i];
                    bestSupertypeDownfallType = downfallType;
                    bestSupertypeScore = score;
                }

                // types.Length - 1 is the maximum score, given that getCommonSupertype returned false
                if (bestSupertypeScore == types.Count - 1)
                {
                    break;
                }
            }

            // In the following errors, the {1} slot is before the {0} slot because checkTypeSubtypeOf supplies the
            // subtype as the first argument to the error
            CheckTypeSubtypeOf(
                bestSupertypeDownfallType,
                bestSupertype,
                errorLocation,
                Errors.Type_argument_candidate_1_is_not_a_valid_type_argument_because_it_is_not_a_supertype_of_candidate_0,
                errorMessageChainHead);
        }

        private bool IsArrayType(IType type)
        {
            return (type.Flags & TypeFlags.Reference) != TypeFlags.None && type.Cast<ITypeReference>().Target == m_globalArrayType;
        }

        private bool IsArrayLikeType(IType type)
        {
            // A type is array-like if it is not the undefined or null type and if it is assignable to any[]
            return (type.Flags & (TypeFlags.Undefined | TypeFlags.Null)) == TypeFlags.None &&
                   IsTypeAssignableTo(type, m_anyArrayType);
        }

        private bool IsTupleLikeType(IType type)
        {
            return GetPropertyOfType(type, "0") != null;
        }

        private static bool IsStringLiteralType(IType type)
        {
            return (type.Flags & TypeFlags.StringLiteral) != TypeFlags.None;
        }

        /// <summary>
        /// Check if a Type was written as a tuple type literal.
        /// Prefer using isTupleLikeType() unless the use of `elementTypes` is required.
        /// </summary>
        private static bool IsTupleType(IType type) // HINT: this is a type guard for TupleType
        {
            return (type.Flags & TypeFlags.Tuple) != TypeFlags.None;
        }

        private IType GetRegularTypeOfObjectLiteral(IType type)
        {
            if ((type.Flags & TypeFlags.FreshObjectLiteral) != TypeFlags.None)
            {
                var freshObjectLiteral = (IFreshObjectLiteralType)type;
                return freshObjectLiteral.GetOrSetRegularType(
                    this,
                    (resolvedType, @this) =>
                    {
                        // HINT: fresh objects are resolved, so this cast is safe
                        var result = CreateObjectType<ResolvedType>(resolvedType.Flags & ~TypeFlags.FreshObjectLiteral, resolvedType.Symbol);

                        var resolvedTypeData = new ResolvedTypeData()
                        {
                            Members = resolvedType.Members,
                            Properties = resolvedType.Properties,
                            CallSignatures = resolvedType.CallSignatures,
                            ConstructSignatures = resolvedType.ConstructSignatures,
                            StringIndexType = resolvedType.StringIndexType,
                            NumberIndexType = resolvedType.NumberIndexType,
                        };

                        return result.Resolve(resolvedTypeData);
                    });
            }

            return type;
        }

        private IType GetWidenedTypeOfObjectLiteral(IType type)
        {
            var properties = GetPropertiesOfObjectType(type);

            ISymbolTable members = new SymbolTable();

            foreach (var prop in properties.AsStructEnumerable())
            {
                var p = prop;
                var propType = GetTypeOfSymbol(p);
                var widenedType = GetWidenedType(propType);

                if (propType != widenedType)
                {
                    var symbolData = new SymbolData
                    {
                        ReadOnlyDeclarations = p.DeclarationList.ToList(),
                        Parent = p.Parent,
                        Type = widenedType,
                        Target = p,
                        ValueDeclaration = p.ValueDeclaration,
                    };
                    var symbol = CreateTransientSymbol(
                        p.Flags | SymbolFlags.Transient,
                        p.Name,
                        ref symbolData);

                    p = symbol;
                }

                members[p.Name] = p;
            }

            var stringIndexType = GetIndexTypeOfType(type, IndexKind.String);
            var numberIndexType = GetIndexTypeOfType(type, IndexKind.Number);

            if (stringIndexType != null)
            {
                stringIndexType = GetWidenedType(stringIndexType);
            }

            if (numberIndexType != null)
            {
                numberIndexType = GetWidenedType(numberIndexType);
            }

            return CreateAnonymousType(
                    type.Symbol,
                    members,
                    s_emptySignatureEnumerable,
                    s_emptySignatureEnumerable,
                    stringIndexType,
                    numberIndexType);
        }

        private IType GetWidenedType(IType type)
        {
            if ((type.Flags & TypeFlags.RequiresWidening) != TypeFlags.None)
            {
                if ((type.Flags & (TypeFlags.Undefined | TypeFlags.Null)) != TypeFlags.None)
                {
                    return m_anyType;
                }

                if ((type.Flags & TypeFlags.PredicateType) != TypeFlags.None)
                {
                    return m_booleanType;
                }

                if ((type.Flags & TypeFlags.ObjectLiteral) != TypeFlags.None)
                {
                    return GetWidenedTypeOfObjectLiteral(type);
                }

                if ((type.Flags & TypeFlags.Union) != TypeFlags.None)
                {
                    return GetUnionType(
                            type.Cast<IUnionType>().Types.Map(this, (t, @this) => @this.GetWidenedType(t)),
                            /*noSubtypeReduction*/ true);
                }

                if (IsArrayType(type))
                {
                    return CreateArrayType(GetWidenedType(type.Cast<ITypeReference>().TypeArguments[0]));
                }

                if (IsTupleType(type))
                {
                    return CreateTupleType(type.Cast<ITupleType>().ElementTypes.Map(this, (t, @this) => @this.GetWidenedType(t)));
                }
            }

            return type;
        }

        /// <summary>
        /// Reports implicit any errors that occur as a result of widening 'null' and 'undefined'
        /// to 'any'. A call to reportWideningErrorsInType is normally accompanied by a call to
        /// getWidenedType. But in some cases getWidenedType is called without reporting errors
        /// (type argument inference is an example).
        ///
        /// The return value indicates whether an error was in fact reported. The particular circumstances
        /// are on a best effort basis. Currently, if the null or undefined that causes widening is inside
        /// an object literal property (arbitrarily deeply), this  reports an error. If no error is
        /// reported, reportImplicitAnyError is a suitable fallback to report a general error.
        /// </summary>
        private bool ReportWideningErrorsInType(IType type)
        {
            var errorReported = false;

            if ((type.Flags & TypeFlags.Union) != TypeFlags.None)
            {
                foreach (var t in type.Cast<IUnionType>().Types)
                {
                    if (ReportWideningErrorsInType(t))
                    {
                        errorReported = true;
                    }
                }
            }

            if (IsArrayType(type))
            {
                return ReportWideningErrorsInType(type.Cast<ITypeReference>().TypeArguments[0]);
            }

            if (IsTupleType(type))
            {
                foreach (var t in type.Cast<ITupleType>().ElementTypes.AsStructEnumerable())
                {
                    if (ReportWideningErrorsInType(t))
                    {
                        errorReported = true;
                    }
                }
            }

            if ((type.Flags & TypeFlags.ObjectLiteral) != TypeFlags.None)
            {
                foreach (var p in GetPropertiesOfObjectType(type).AsStructEnumerable())
                {
                    var t = GetTypeOfSymbol(p);

                    if ((t.Flags & TypeFlags.ContainsUndefinedOrNull) != TypeFlags.None)
                    {
                        if (!ReportWideningErrorsInType(t))
                        {
                            Error(
                                p.ValueDeclaration,
                                Errors.Object_literal_s_property_0_implicitly_has_an_1_type,
                                p.Name,
                                TypeToString(GetWidenedType(t)));
                        }

                        errorReported = true;
                    }
                }
            }

            return errorReported;
        }

        private void ReportImplicitAnyError(IDeclaration declaration, IType type)
        {
            var typeAsString = TypeToString(GetWidenedType(type));
            IDiagnosticMessage diagnostic = null;

            switch (declaration.Kind)
            {
                case SyntaxKind.PropertyDeclaration:
                case SyntaxKind.PropertySignature:
                    diagnostic = Errors.Member_0_implicitly_has_an_1_type;
                    break;

                case SyntaxKind.Parameter:
                    diagnostic = declaration.Cast<IParameterDeclaration>().DotDotDotToken ?
                        Errors.Rest_parameter_0_implicitly_has_an_any_type :
                        Errors.Parameter_0_implicitly_has_an_1_type;
                    break;

                case SyntaxKind.FunctionDeclaration:
                case SyntaxKind.MethodDeclaration:
                case SyntaxKind.MethodSignature:
                case SyntaxKind.GetAccessor:
                case SyntaxKind.SetAccessor:
                case SyntaxKind.FunctionExpression:
                case SyntaxKind.ArrowFunction:
                    if (declaration.Name == null)
                    {
                        Error(
                            declaration,
                            Errors.Function_expression_which_lacks_return_type_annotation_implicitly_has_an_0_return_type,
                            typeAsString);

                        return;
                    }

                    diagnostic = Errors.Zero_which_lacks_return_type_annotation_implicitly_has_an_1_return_type;
                    break;

                default:
                    diagnostic = Errors.Variable_0_implicitly_has_an_1_type;
                    break;
            }

            Error(
                declaration,
                diagnostic,
                DeclarationNameToString(declaration.Name),
                typeAsString);
        }

        private void ReportErrorsFromWidening(IDeclaration declaration, IType type)
        {
            if (m_produceDiagnostics &&
                m_compilerOptions.NoImplicitAny.HasValue && m_compilerOptions.NoImplicitAny.Value &&
                (type.Flags & TypeFlags.ContainsUndefinedOrNull) != TypeFlags.None)
            {
                // Report implicit any error within type if possible, otherwise report error on declaration
                if (!ReportWideningErrorsInType(type))
                {
                    ReportImplicitAnyError(declaration, type);
                }
            }
        }

        private void ForEachMatchingParameterType<TState>(
            ISignature source,
            ISignature target,
            TState state,
            Action<TState, IType/*s*/, IType/*t*/> callback)
        {
            var sourceMax = source.Parameters.Count;
            var targetMax = target.Parameters.Count;

            int count;
            if (source.HasRestParameter && target.HasRestParameter)
            {
                count = sourceMax > targetMax ? sourceMax : targetMax;
                sourceMax--;
                targetMax--;
            }
            else if (source.HasRestParameter)
            {
                sourceMax--;
                count = targetMax;
            }
            else if (target.HasRestParameter)
            {
                targetMax--;
                count = sourceMax;
            }
            else
            {
                count = sourceMax < targetMax ? sourceMax : targetMax;
            }

            for (var i = 0; i < count; i++)
            {
                var s = i < sourceMax ? GetTypeOfSymbol(source.Parameters[i]) : GetRestTypeOfSignature(source);
                var t = i < targetMax ? GetTypeOfSymbol(target.Parameters[i]) : GetRestTypeOfSignature(target);
                callback(state, s, t);
            }
        }

        private static IInferenceContext CreateInferenceContext(IReadOnlyList<ITypeParameter> typeParameters, bool inferUnionTypes)
        {
            // TODO: This is odd. Could just do new List<ITypeInferences>(typeParameters.Count)...
            var inferences = typeParameters.Select(t => CreateTypeInferencesObject()).ToList();

            return new InferenceContext()
            {
                TypeParameters = typeParameters,
                InferUnionTypes = inferUnionTypes,
                Inferences = inferences,

                // Observe it is important here to return a list with the appropriate size
                InferredTypes = new IType[typeParameters.Count].ToList(),
            };
        }

        private static ITypeInferences CreateTypeInferencesObject()
        {
            return new TypeInferences();
        }

        private void InferTypes(IInferenceContext context, IType source, IType target)
        {
            InferTypesClosure closure = new InferTypesClosure(this, context);
            closure.InferFromTypes(source, target);
        }

        private sealed class InferTypesClosure
        {
            private readonly Checker m_checker;

            private readonly IInferenceContext m_context;

            // HINT: TS implementation defines the stacks as lists, but it assigns values
            //       at arbitrary indices, so it makes more sense to have them as Dictionary
            private readonly Dictionary<int, IType> m_sourceStack = new Dictionary<int, IType>();
            private readonly Dictionary<int, IType> m_targetStack = new Dictionary<int, IType>();
            private int m_depth = 0;
            private int m_inferiority = 0;

            public InferTypesClosure(Checker checker, IInferenceContext context)
            {
                m_checker = checker;
                m_context = context;
            }

            private bool IsInProcess(IType source, IType target)
            {
                for (var i = 0; i < m_depth; i++)
                {
                    if (source == m_sourceStack[i] && target == m_targetStack[i])
                    {
                        return true;
                    }
                }

                return false;
            }

            public void InferFromTypes(IType source, IType target)
            {
                if (((source.Flags & TypeFlags.Union) != TypeFlags.None && (target.Flags & TypeFlags.Union) != TypeFlags.None) ||
                    ((source.Flags & TypeFlags.Intersection) != TypeFlags.None && (target.Flags & TypeFlags.Intersection) != TypeFlags.None))
                {
                    // Source and target are both unions or both intersections. First, find each
                    // target constituent type that has an identically matching source constituent
                    // type, and for each such target constituent type infer from the type to itself.
                    // When inferring from a type to itself we effectively find all type parameter
                    // occurrences within that type and infer themselves as their type arguments.
                    var matchingTypes = new List<IType>();
                    foreach (var t in target.Cast<IUnionOrIntersectionType>().Types)
                    {
                        if (m_checker.TypeIdenticalToSomeType(t, source.Cast<IUnionOrIntersectionType>().Types))
                        {
                            matchingTypes.Add(t);
                            InferFromTypes(t, t);
                        }
                    }

                    // Next, to improve the quality of inferences, reduce the source and target types by
                    // removing the identically matched constituents. For example, when inferring from
                    // 'string | string[]' to 'string | T' we reduce the types to 'string[]' and 'T'.
                    if (matchingTypes.Count != 0)
                    {
                        source = m_checker.RemoveTypesFromUnionOrIntersection(source.Cast<IUnionOrIntersectionType>(), matchingTypes);
                        target = m_checker.RemoveTypesFromUnionOrIntersection(target.Cast<IUnionOrIntersectionType>(), matchingTypes);
                    }
                }

                if ((target.Flags & TypeFlags.TypeParameter) != TypeFlags.None)
                {
                    // If target is a type parameter, make an inference, unless the source type contains
                    // the anyFunctionType (the wildcard type that's used to avoid contextually typing functions).
                    // Because the anyFunctionType is internal, it should not be exposed to the user by adding
                    // it as an inference candidate. Hopefully, a better candidate will come along that does
                    // not contain anyFunctionType when we come back to this argument for its second round
                    // of inference.
                    if ((source.Flags & TypeFlags.ContainsAnyFunctionType) != TypeFlags.None)
                    {
                        return;
                    }

                    var typeParameters = m_context.TypeParameters;
                    for (var i = 0; i < typeParameters.Count; i++)
                    {
                        if (target == typeParameters[i])
                        {
                            var inferences = m_context.Inferences[i];

                            if (!inferences.IsFixed)
                            {
                                // Any inferences that are made to a type parameter in a union type are inferior
                                // to inferences made to a flat (non-union) type. This is because if we infer to
                                // T | string[], we really don't know if we should be inferring to T or not (because
                                // the correct constituent on the target side could be string[]). Therefore, we put
                                // such inferior inferences into a secondary bucket, and only use them if the primary
                                // bucket is empty.
                                var candidates = m_inferiority != 0 ?
                                                    inferences.Secondary ?? (inferences.Secondary = new List<IType>()) :
                                                    inferences.Primary ?? (inferences.Primary = new List<IType>());

                                if (!candidates.Contains(source))
                                {
                                    candidates.Add(source);
                                }
                            }

                            return;
                        }
                    }
                }
                else if ((source.Flags & TypeFlags.Reference) != TypeFlags.None &&
                         (target.Flags & TypeFlags.Reference) != TypeFlags.None &&
                         (source.Cast<ITypeReference>().Target == target.Cast<ITypeReference>().Target))
                {
                    // If source and target are references to the same generic type, infer from type arguments
                    var sourceTypes = source.Cast<ITypeReference>().TypeArguments ?? EmptyArray<IType>();
                    var targetTypes = target.Cast<ITypeReference>().TypeArguments ?? EmptyArray<IType>();

                    var count = sourceTypes.Count < targetTypes.Count ? sourceTypes.Count : targetTypes.Count;
                    for (var i = 0; i < count; i++)
                    {
                        InferFromTypes(sourceTypes[i], targetTypes[i]);
                    }
                }
                else if ((source.Flags & TypeFlags.PredicateType) != TypeFlags.None &&
                         (target.Flags & TypeFlags.PredicateType) != TypeFlags.None)
                {
                    if (source.Cast<IPredicateType>().Predicate.Kind == target.Cast<IPredicateType>().Predicate.Kind)
                    {
                        InferFromTypes(
                            source.Cast<IPredicateType>().Predicate.Type,
                            target.Cast<IPredicateType>().Predicate.Type);
                    }
                }
                else if ((source.Flags & TypeFlags.Tuple) != TypeFlags.None &&
                         (target.Flags & TypeFlags.Tuple) != TypeFlags.None &&
                         (source.Cast<ITupleType>().ElementTypes.Count == target.Cast<ITupleType>().ElementTypes.Count))
                {
                    // If source and target are tuples of the same size, infer from element types
                    var sourceTypes = source.Cast<ITupleType>().ElementTypes;
                    var targetTypes = target.Cast<ITupleType>().ElementTypes;
                    for (var i = 0; i < sourceTypes.Count; i++)
                    {
                        InferFromTypes(sourceTypes[i], targetTypes[i]);
                    }
                }
                else if ((target.Flags & TypeFlags.UnionOrIntersection) != TypeFlags.None)
                {
                    var targetTypes = target.Cast<IUnionOrIntersectionType>().Types;
                    var typeParameterCount = 0;
                    ITypeParameter typeParameter = null;

                    // First infer to each type in union or intersection that isn't a type parameter
                    foreach (var t in targetTypes)
                    {
                        if ((t.Flags & TypeFlags.TypeParameter) != TypeFlags.None &&
                            TypeScript.Net.Extensions.CollectionExtensions.Contains(m_context.TypeParameters, typeParameter))
                        {
                            typeParameter = t.Cast<ITypeParameter>();
                            typeParameterCount++;
                        }
                        else
                        {
                            InferFromTypes(source, t);
                        }
                    }

                    // Next, if target is a union type containing a single naked type parameter, make a
                    // secondary inference to that type parameter. We don't do this for intersection types
                    // because in a target type like Foo & T we don't know how which parts of the source type
                    // should be matched by Foo and which should be inferred to T.
                    if ((target.Flags & TypeFlags.Union) != TypeFlags.None && typeParameterCount == 1)
                    {
                        m_inferiority++;

                        InferFromTypes(source, typeParameter);

                        m_inferiority--;
                    }
                }
                else if ((source.Flags & TypeFlags.UnionOrIntersection) != TypeFlags.None)
                {
                    // Source is a union or intersection type, infer from each consituent type
                    var sourceTypes = source.Cast<IUnionOrIntersectionType>().Types;
                    foreach (var sourceType in sourceTypes)
                    {
                        InferFromTypes(sourceType, target);
                    }
                }
                else
                {
                    source = m_checker.GetApparentType(source);

                    if ((source.Flags & TypeFlags.ObjectType) != TypeFlags.None && (
                        ((target.Flags & TypeFlags.Reference) != TypeFlags.None && target.Cast<ITypeReference>().TypeArguments != null) ||
                        (target.Flags & TypeFlags.Tuple) != TypeFlags.None ||
                        ((target.Flags & TypeFlags.Anonymous) != TypeFlags.None && target.Symbol != null && (target.Symbol.Flags & (SymbolFlags.Method | SymbolFlags.TypeLiteral | SymbolFlags.Class)) != SymbolFlags.None)))
                    {
                        // If source is an object type, and target is a type reference with type arguments, a tuple type,
                        // the type of a method, or a type literal, infer from members
                        if (IsInProcess(source, target))
                        {
                            return;
                        }

                        if (IsDeeplyNestedGeneric(source, m_sourceStack.Values, m_depth) &&
                            IsDeeplyNestedGeneric(target, m_targetStack.Values, m_depth))
                        {
                            return;
                        }

                        if (m_depth == 0)
                        {
                            m_sourceStack.Clear();
                            m_targetStack.Clear();
                        }

                        m_sourceStack[m_depth] = source;
                        m_targetStack[m_depth] = target;
                        m_depth++;

                        InferFromProperties(source, target);
                        InferFromSignatures(source, target, SignatureKind.Call);
                        InferFromSignatures(source, target, SignatureKind.Construct);
                        InferFromIndexTypes(source, target, IndexKind.String, IndexKind.String);
                        InferFromIndexTypes(source, target, IndexKind.Number, IndexKind.Number);
                        InferFromIndexTypes(source, target, IndexKind.String, IndexKind.Number);

                        m_depth--;
                    }
                }
            }

            private void InferFromProperties(IType source, IType target)
            {
                var properties = m_checker.GetPropertiesOfObjectType(target);
                foreach (var targetProp in properties.AsStructEnumerable())
                {
                    var sourceProp = m_checker.GetPropertyOfObjectType(source, targetProp.Name);
                    if (sourceProp != null)
                    {
                        InferFromTypes(
                            m_checker.GetTypeOfSymbol(sourceProp),
                            m_checker.GetTypeOfSymbol(targetProp));
                    }
                }
            }

            private void InferFromSignatures(IType source, IType target, SignatureKind kind)
            {
                var sourceSignatures = m_checker.GetSignaturesOfType(source, kind);
                var targetSignatures = m_checker.GetSignaturesOfType(target, kind);

                var sourceLen = sourceSignatures.Count;
                var targetLen = targetSignatures.Count;
                var len = sourceLen < targetLen ? sourceLen : targetLen;

                for (var i = 0; i < len; i++)
                {
                    InferFromSignature(
                        m_checker.GetErasedSignature(sourceSignatures[sourceLen - len + i]),
                        m_checker.GetErasedSignature(targetSignatures[targetLen - len + i]));
                }
            }

            private void InferFromSignature(ISignature source, ISignature target)
            {
                m_checker.ForEachMatchingParameterType(
                    source,
                    target,
                    this,
                    (@this, s, t) => @this.InferFromTypes(s, t));

                InferFromTypes(
                    m_checker.GetReturnTypeOfSignature(source),
                    m_checker.GetReturnTypeOfSignature(target));
            }

            private void InferFromIndexTypes(IType source, IType target, IndexKind sourceKind, IndexKind targetKind)
            {
                var targetIndexType = m_checker.GetIndexTypeOfType(target, targetKind);
                if (targetIndexType != null)
                {
                    var sourceIndexType = m_checker.GetIndexTypeOfType(source, sourceKind);
                    if (sourceIndexType != null)
                    {
                        InferFromTypes(sourceIndexType, targetIndexType);
                    }
                }
            }
        }

        private bool TypeIdenticalToSomeType(IType type, List<IType> types)
        {
            foreach (var t in types)
            {
                if (IsTypeIdenticalTo(t, type))
                {
                    return true;
                }
            }

            return false;
        }

        /// <summary>
        /// Return a new union or intersection type computed by removing a given set of types
        /// from a given union or intersection type.
        /// </summary>
        private IType RemoveTypesFromUnionOrIntersection(IUnionOrIntersectionType type, List<IType> typesToRemove)
        {
            List<IType> reducedTypes = new List<IType>();
            foreach (var t in type.Types)
            {
                if (!TypeIdenticalToSomeType(t, typesToRemove))
                {
                    reducedTypes.Add(t);
                }
            }

            return (type.Flags & TypeFlags.Union) != TypeFlags.None ?
                    GetUnionType(reducedTypes, /*noSubtypeReduction*/ true) :
                    GetIntersectionType(reducedTypes);
        }

        private static List<IType> GetInferenceCandidates(IInferenceContext context, int index)
        {
            var inferences = context.Inferences[index];
            return inferences.Primary ?? (inferences.Secondary ?? /*TODO:emptyArray*/new List<IType>());
        }

        private IType GetInferredType(IInferenceContext context, int index)
        {
            Contract.Requires(index < context.InferredTypes.Count);
            Contract.Requires(index < context.TypeParameters.Count);

            var inferredType = context.InferredTypes[index];
            bool inferenceSucceeded = false;

            if (inferredType == null)
            {
                var inferences = GetInferenceCandidates(context, index);
                if (inferences.Count != 0)
                {
                    // Infer widened union or supertype, or the unknown type for no common supertype
                    var unionOrSuperType = context.InferUnionTypes ?
                                            GetUnionType(inferences) :
                                            GetCommonSupertype(inferences);

                    inferredType = unionOrSuperType != null ?
                                    GetWidenedType(unionOrSuperType) :
                                    m_unknownType;

                    inferenceSucceeded = unionOrSuperType != null;
                }
                else
                {
                    // Infer the empty object type when no inferences were made. It is important to remember that
                    // in this case, inference still succeeds, meaning there is no error for not having inference
                    // candidates. An inference error only occurs when there are *conflicting* candidates, i.e.,
                    // candidates with no common supertype.
                    inferredType = m_emptyObjectType;
                    inferenceSucceeded = true;
                }

                // HINT: This only works because CreateInferenceContext creates
                //       InferredTypes as List with capacity of TypeParameters.Count.
                //       Index must be smaller than that capacity, otherwise C# will throw (but TS won't!)
                context.InferredTypes[index] = inferredType;

                // Only do the constraint check if inference succeeded (to prevent cascading errors)
                if (inferenceSucceeded)
                {
                    var constraint = GetConstraintOfTypeParameter(context.TypeParameters[index]);
                    if (constraint != null)
                    {
                        var instantiatedConstraint = InstantiateType(constraint, GetInferenceMapper(context));
                        if (!IsTypeAssignableTo(
                                inferredType,
                                GetTypeWithThisArgument(instantiatedConstraint, inferredType)))
                        {
                            context.InferredTypes[index] = inferredType = instantiatedConstraint;
                        }
                    }
                }
                else if (!context.FailedTypeParameterIndex || context.FailedTypeParameterIndex.Value > index)
                {
                    // If inference failed, it is necessary to record the index of the failed type parameter (the one we are on).
                    // It might be that inference has already failed on a later type parameter on a previous call to inferTypeArguments.
                    // So if this failure is on preceding type parameter, this type parameter is the new failure index.
                    context.FailedTypeParameterIndex = Optional.Create(index);
                }
            }

            return inferredType;
        }

        private List<IType> GetInferredTypes(IInferenceContext context)
        {
            for (var i = 0; i < context.InferredTypes.Count; i++)
            {
                GetInferredType(context, i);
            }

            return context.InferredTypes;
        }

        // EXPRESSION TYPE CHECKING
        private ISymbol GetOrSetResolvedSymbol<T>(INode node, T data, Func<T, ISymbol> factory)
        {
            if (m_interactiveMode)
            {
                var links = GetNodeLinks(node);
                return links.ResolvedSymbolForIncrementalMode ?? (links.ResolvedSymbolForIncrementalMode = factory(data));
            }

            return node.ResolvedSymbol ?? (node.ResolvedSymbol = factory(data));
        }

        private void SetResolvedSymbol(INode node, ISymbol symbol)
        {
            if (m_interactiveMode)
            {
                GetNodeLinks(node).ResolvedSymbolForIncrementalMode = symbol;
            }

            node.ResolvedSymbol = symbol;
        }

        private ISymbol GetResolvedSymbol(INode node)
        {
            if (m_interactiveMode)
            {
                return GetNodeLinks(node).ResolvedSymbolForIncrementalMode;
            }

            return node.ResolvedSymbol;
        }

        private IType GetOrSetResolvedType<T>(INode node, T data, Func<NodeLinks, T, Tuple<IType, ISymbol>> getResolvedTypeAndSymbolFactory)
        {
            var links = GetNodeLinks(node);
            if (links.ResolvedType != null)
            {
                return links.ResolvedType;
            }

            lock (links.SyncRoot)
            {
                if (links.ResolvedType == null)
                {
                    var result = getResolvedTypeAndSymbolFactory(links, data);
                    links.ResolvedType = result.Item1;
                    SetResolvedSymbol(node, result.Item2);
                }
            }

            return links.ResolvedType;
        }

        private ISymbol GetResolvedSymbol(IIdentifier nodeArg)
        {
            return GetOrSetResolvedSymbol(nodeArg, (checker: this, nodeArg), tuple =>
            {
                var @this = tuple.checker;
                var node = tuple.nodeArg;
                ISymbol symbol = null;

                if (!NodeIsMissing(node))
                {
                    symbol = @this.ResolveName(
                                node,
                                node.Text,
                                SymbolFlags.Value | SymbolFlags.ExportValue,
                                Errors.Cannot_find_name_0,
                                node);
                }

                return symbol ?? @this.m_unknownSymbol;
            });
        }

        private static bool IsInTypeQuery(INode node)
        {
            // TypeScript 1.0 spec (April 2014): 3.6.3
            // A type query consists of the keyword typeof followed by an expression.
            // The expression is restricted to a single identifier or a sequence of identifiers separated by periods
            while (node != null)
            {
                switch (node.Kind)
                {
                    case SyntaxKind.TypeQuery:
                        return true;
                    case SyntaxKind.Identifier:
                    case SyntaxKind.QualifiedName:
                        node = node.Parent;
                        continue;
                    default:
                        return false;
                }
            }

            Contract.Assert(false, "should not get here");
            throw new InvalidOperationException("Unreachable");
        }

        private bool HasInitializer(IVariableLikeDeclaration node)
        {
            // TODO: Verify correctness! (there seems to be no guarantee that node.Parent.Parent will be type IVariableLikeDeclaration)
            return node.Initializer != null || (IsBindingPattern(node.Parent) != null && HasInitializer(node.Parent.Parent.Cast<IVariableLikeDeclaration>()));
        }

        // Check if a given variable is assigned within a given syntax node
        private bool IsVariableAssignedWithin(ISymbol symbol, INode node)
        {
            return
                GetNodeLinks(node)
                .AssignmentChecks
                .GetOrAddAtomic(
                    symbol.Id,
                     (checker: this, symbol),
                    (id, capture) => capture.checker.IsAssignedIn(node, capture.symbol));
        }

        private bool IsAssignedInBinaryExpression(IBinaryExpression node, ISymbol symbol)
        {
            if (node.OperatorToken.Kind >= SyntaxKind.FirstAssignment && node.OperatorToken.Kind <= SyntaxKind.LastAssignment)
            {
                var n = SkipParenthesizedNodes(node.Left);
                if (n.Kind == SyntaxKind.Identifier && GetResolvedSymbol(n.Cast<IIdentifier>()) == symbol)
                {
                    return true;
                }
            }

            return NodeWalker.ForEachChild(
                node,
                 (checker: this, symbol),
                (n, capture) => capture.checker.IsAssignedIn(n, capture.symbol));
        }

        private bool IsAssignedInVariableDeclaration(IVariableLikeDeclaration node, ISymbol symbol)
        {
            if (IsBindingPattern(node.Name) == null &&
                GetSymbolOfNode(node) == symbol &&
                HasInitializer(node))
            {
                return true;
            }

            return NodeWalker.ForEachChild(
                node,
                 (checker: this, symbol),
                (n, capture) => capture.checker.IsAssignedIn(n, capture.symbol));
        }

        private bool IsAssignedIn(INode node, ISymbol symbol)
        {
            switch (node.Kind)
            {
                case SyntaxKind.BinaryExpression:
                    return IsAssignedInBinaryExpression(node.Cast<IBinaryExpression>(), symbol);

                case SyntaxKind.VariableDeclaration:
                case SyntaxKind.BindingElement:
                    return IsAssignedInVariableDeclaration(node.Cast<IVariableLikeDeclaration>(), symbol);

                case SyntaxKind.ObjectBindingPattern:
                case SyntaxKind.ArrayBindingPattern:
                case SyntaxKind.ArrayLiteralExpression:
                case SyntaxKind.ObjectLiteralExpression:
                case SyntaxKind.PropertyAccessExpression:
                case SyntaxKind.ElementAccessExpression:
                case SyntaxKind.CallExpression:
                case SyntaxKind.NewExpression:
                case SyntaxKind.TypeAssertionExpression:
                case SyntaxKind.AsExpression:
                case SyntaxKind.ParenthesizedExpression:
                case SyntaxKind.PrefixUnaryExpression:
                case SyntaxKind.DeleteExpression:
                case SyntaxKind.AwaitExpression:
                case SyntaxKind.TypeOfExpression:
                case SyntaxKind.VoidExpression:
                case SyntaxKind.PostfixUnaryExpression:
                case SyntaxKind.YieldExpression:
                case SyntaxKind.ConditionalExpression:
                case SyntaxKind.SpreadElementExpression:
                case SyntaxKind.Block:
                case SyntaxKind.VariableStatement:
                case SyntaxKind.ExpressionStatement:
                case SyntaxKind.IfStatement:
                case SyntaxKind.DoStatement:
                case SyntaxKind.WhileStatement:
                case SyntaxKind.ForStatement:
                case SyntaxKind.ForInStatement:
                case SyntaxKind.ForOfStatement:
                case SyntaxKind.ReturnStatement:
                case SyntaxKind.WithStatement:
                case SyntaxKind.SwitchStatement:
                case SyntaxKind.CaseClause:
                case SyntaxKind.DefaultClause:
                case SyntaxKind.LabeledStatement:
                case SyntaxKind.ThrowStatement:
                case SyntaxKind.TryStatement:
                case SyntaxKind.CatchClause:
                    return NodeWalker.ForEachChild(
                        node,
                         (checker: this, symbol),
                        (n, capture) => capture.checker.IsAssignedIn(n, capture.symbol));
            }

            return false;
        }

        private readonly struct NodeAndChild
        {
            public readonly INode Node;
            public readonly INode Child;

            public NodeAndChild(INode node, INode child)
            {
                Node = node;
                Child = child;
            }
        }

        // Get the narrowed type of a given symbol at a given location
        private IType GetNarrowedTypeOfSymbol(ISymbol symbol, INode node)
        {
            using (var pooledClosure = s_narrowedTypeOfSymbolClosurePool.GetInstance())
            {
                var closure = pooledClosure.Instance.Init(this, symbol);
                return closure.GetNarrowedTypeOfSymbol(node);
            }
        }

        private static readonly ObjectPool<NarrowedTypeOfSymbolClosure> s_narrowedTypeOfSymbolClosurePool = new ObjectPool<NarrowedTypeOfSymbolClosure>(
            () => new NarrowedTypeOfSymbolClosure(),
            closure => { closure.Clear(); return closure; });

        private sealed class NarrowedTypeOfSymbolClosure
        {
            private static readonly ObjectPool<Stack<NodeAndChild>> s_stackPool = new ObjectPool<Stack<NodeAndChild>>(
                () => new Stack<NodeAndChild>(),
                c => { c.Clear(); return c; });

            private Checker m_checker;
            private ISymbol m_symbol;

            public NarrowedTypeOfSymbolClosure Init(Checker checker, ISymbol symbol)
            {
                m_checker = checker;
                m_symbol = symbol;
                return this;
            }

            public void Clear()
            {
                m_checker = null;
                m_symbol = null;
            }

            // Get the narrowed type of a given symbol at a given location
            public IType GetNarrowedTypeOfSymbol(INode node)
            {
                Contract.Assert(m_checker != null);
                var type = m_checker.GetTypeOfSymbol(m_symbol);

                // Only narrow when symbol is variable of type any or an object, union, or type parameter type
                if (node != null && (m_symbol.Flags & SymbolFlags.Variable) != SymbolFlags.None)
                {
                    if (IsTypeAny(type) ||
                        (type.Flags & (TypeFlags.ObjectType | TypeFlags.Union | TypeFlags.TypeParameter)) != TypeFlags.None)
                    {
                        var declaration = GetDeclarationOfKind(m_symbol, SyntaxKind.VariableDeclaration);
                        var top = declaration != null ? GetDeclarationContainer(declaration) : null;
                        var originalType = type;

                        using (var pooledNodeStack = s_stackPool.GetInstance())
                        {
                            var nodeStack = pooledNodeStack.Instance;

                            while (node.Parent != null)
                            {
                                var child = node;
                                node = node.Parent;

                                // TypeScript version used switch with labeled break, to simplify the migration
                                // if-else was used.
                                if (node.Kind == SyntaxKind.IfStatement ||
                                    node.Kind == SyntaxKind.ConditionalExpression ||
                                    node.Kind == SyntaxKind.BinaryExpression)
                                {
                                    nodeStack.Push(new NodeAndChild(node, child));
                                }
                                else if (node.Kind == SyntaxKind.SourceFile || node.Kind == SyntaxKind.ModuleDeclaration)
                                {
                                    // Stop at the first containing file or module declaration
                                    break;
                                }

                                if (node.ResolveUnionType() == top.ResolveUnionType())
                                {
                                    break;
                                }
                            }

                            NodeAndChild nodes;
                            while (nodeStack.Count != 0)
                            {
                                nodes = nodeStack.Pop();

                                var n = nodes.Node;
                                var c = nodes.Child;

                                switch (n.Kind)
                                {
                                    case SyntaxKind.IfStatement:
                                        // In a branch of an if statement, narrow based on controlling expression
                                        if (c.ResolveUnionType() != n.Cast<IIfStatement>().Expression.ResolveUnionType())
                                        {
                                            type = NarrowType(
                                                    type,
                                                    n.Cast<IIfStatement>().Expression,
                                                    /*assumeTrue*/ c.ResolveUnionType() == n.Cast<IIfStatement>().ThenStatement.ResolveUnionType());
                                        }

                                        break;

                                    case SyntaxKind.ConditionalExpression:
                                        // In a branch of a conditional expression, narrow based on controlling condition
                                        if (c.ResolveUnionType() != n.Cast<IConditionalExpression>().Condition.ResolveUnionType())
                                        {
                                            type = NarrowType(
                                                    type,
                                                    n.Cast<IConditionalExpression>().Condition,
                                                    /*assumeTrue*/ c.ResolveUnionType() == n.Cast<IConditionalExpression>().WhenTrue.ResolveUnionType());
                                        }

                                        break;

                                    case SyntaxKind.BinaryExpression:
                                        // In the right operand of an && or ||, narrow based on left operand
                                        if (c.ResolveUnionType() == n.Cast<IBinaryExpression>().Right.ResolveUnionType())
                                        {
                                            if (n.Cast<IBinaryExpression>().OperatorToken.Kind == SyntaxKind.AmpersandAmpersandToken)
                                            {
                                                type = NarrowType(
                                                        type,
                                                        n.Cast<IBinaryExpression>().Left,
                                                        /*assumeTrue*/ true);
                                            }
                                            else if (n.Cast<IBinaryExpression>().OperatorToken.Kind == SyntaxKind.BarBarToken)
                                            {
                                                type = NarrowType(
                                                        type,
                                                        n.Cast<IBinaryExpression>().Left,
                                                        /*assumeTrue*/ false);
                                            }
                                        }

                                        break;

                                    default:
                                        Contract.Assert(false, "Unreachable!");
                                        throw new InvalidOperationException("Unreachable");
                                }

                                // Use original type if construct contains assignments to variable
                                if (type != originalType && m_checker.IsVariableAssignedWithin(m_symbol, n))
                                {
                                    type = originalType;
                                }
                            }

                            // Preserve old top-level behavior - if the branch is really an empty set, revert to prior type
                            if (type == m_checker.m_emptyUnionType)
                            {
                                type = originalType;
                            }
                        }
                    }
                }

                return type;
            }

            private IType NarrowTypeByEquality(IType type, IBinaryExpression expr, bool assumeTrue)
            {
                // Check that we have 'typeof <symbol>' on the left and string literal on the right
                if (expr.Left.Kind != SyntaxKind.TypeOfExpression ||
                    expr.Right.Kind != SyntaxKind.StringLiteral)
                {
                    return type;
                }

                var left = expr.Left.Cast<ITypeOfExpression>();
                var right = expr.Right.Cast<ILiteralExpression>();

                if ((left.Expression.Kind != SyntaxKind.Identifier) ||
                    (m_checker.GetResolvedSymbol(left.Expression.Cast<IIdentifier>()) != m_symbol))
                {
                    return type;
                }

                if (expr.OperatorToken.Kind == SyntaxKind.ExclamationEqualsEqualsToken)
                {
                    assumeTrue = !assumeTrue;
                }

                TypeAndFlag typeInfo;
                bool primitiveType = m_checker.m_primitiveTypeInfo.TryGetValue(right.Text, out typeInfo);

                // Don't narrow `undefined`
                if (primitiveType && typeInfo.Type == m_checker.m_undefinedType)
                {
                    return type;
                }

                // If the type to be narrowed is any and we're checking a primitive with assumeTrue=true, return the primitive
                if ((type.Flags & TypeFlags.Any) != TypeFlags.None &&
                    primitiveType &&
                    assumeTrue)
                {
                    return typeInfo.Type;
                }

                TypeFlags flags = TypeFlags.None;
                if (primitiveType)
                {
                    flags = typeInfo.Flags;
                }
                else
                {
                    assumeTrue = !assumeTrue;
                    flags = TypeFlags.NumberLike | TypeFlags.StringLike | TypeFlags.EsSymbol | TypeFlags.Boolean;
                }

                // At this point we can bail if it's not a union
                if ((type.Flags & TypeFlags.Union) == TypeFlags.None)
                {
                    // If the active non-union type would be removed from a union by this type guard, return an empty union
                    return FilterUnion(type, assumeTrue, flags) ? type : m_checker.m_emptyUnionType;
                }

                return m_checker.GetUnionType(
                        type.Cast<IUnionType>().Types.Filter(
                             (checker: this, assumeTrue, flags),
                            (t, tuple) =>
                            {
                                var @this = tuple.checker;
                                var capturedAssumeTrue = tuple.assumeTrue;
                                var capturedFlags = tuple.flags;
                                return FilterUnion(t, capturedAssumeTrue, capturedFlags);
                            }),
                        noSubtypeReduction: true);
            }

            private static bool FilterUnion(IType type, bool assumeTrue, TypeFlags flags)
            {
                return assumeTrue == ((type.Flags & flags) != TypeFlags.None);
            }

            private IType NarrowTypeByAnd(IType type, IBinaryExpression expr, bool assumeTrue)
            {
                if (assumeTrue)
                {
                    // The assumed result is true, therefore we narrow assuming each operand to be true.
                    return NarrowType(
                            NarrowType(type, expr.Left, /*assumeTrue*/ true),
                            expr.Right,
                            /*assumeTrue*/ true);
                }

                // The assumed result is false. This means either the first operand was false, or the first operand was true
                // and the second operand was false. We narrow with those assumptions and union the two resulting types.
                using (var types = ListOf(
                    NarrowType(type, expr.Left, /*assumeTrue*/ false),
                    NarrowType(type, expr.Right, /*assumeTrue*/ false)))
                {
                    return m_checker.GetUnionType(types.Instance);
                }
            }

            private IType NarrowTypeByOr(IType type, IBinaryExpression expr, bool assumeTrue)
            {
                if (assumeTrue)
                {
                    // The assumed result is true. This means either the first operand was true, or the first operand was false
                    // and the second operand was true. We narrow with those assumptions and union the two resulting types.
                    using (var types = ListOf(
                        NarrowType(type, expr.Left, /*assumeTrue*/ true),
                        NarrowType(type, expr.Right, /*assumeTrue*/ true)))
                    {
                        return m_checker.GetUnionType(types.Instance);
                    }
                }

                // The assumed result is false, therefore we narrow assuming each operand to be false.
                return NarrowType(
                    NarrowType(type, expr.Left, /*assumeTrue*/ false),
                    expr.Right,
                    /*assumeTrue*/ false);
            }

            private IType NarrowTypeByInstanceof(IType type, IBinaryExpression expr, bool assumeTrue)
            {
                // Check that type is not any, assumed result is true, and we have variable symbol on the left
                if (IsTypeAny(type) ||
                    expr.Left.Kind != SyntaxKind.Identifier ||
                    m_checker.GetResolvedSymbol(expr.Left.Cast<IIdentifier>()) != m_symbol)
                {
                    return type;
                }

                // Check that right operand is a function type with a prototype property
                var rightType = m_checker.CheckExpression(expr.Right);
                if (!m_checker.IsTypeSubtypeOf(rightType, m_checker.m_globalFunctionType))
                {
                    return type;
                }

                IType targetType = null;
                var prototypeProperty = m_checker.GetPropertyOfType(rightType, "prototype");
                if (prototypeProperty != null)
                {
                    // Target type is type of the prototype property
                    var prototypePropertyType = m_checker.GetTypeOfSymbol(prototypeProperty);
                    if (!IsTypeAny(prototypePropertyType))
                    {
                        targetType = prototypePropertyType;
                    }
                }

                if (targetType == null)
                {
                    // Target type is type of construct signature
                    IReadOnlyList<ISignature> constructSignatures = null;
                    if ((rightType.Flags & TypeFlags.Interface) != TypeFlags.None)
                    {
                        constructSignatures = m_checker.ResolveDeclaredMembers(
                                                rightType.Cast<IInterfaceType>()).DeclaredConstructSignatures;
                    }
                    else if ((rightType.Flags & TypeFlags.Anonymous) != TypeFlags.None)
                    {
                        constructSignatures = m_checker.GetSignaturesOfType(rightType, SignatureKind.Construct);
                    }

                    if (constructSignatures?.Count > 0)
                    {
                        targetType = m_checker.GetUnionType(
                                        constructSignatures.Map(
                                            m_checker,
                                            (signature, checker) => checker.GetReturnTypeOfSignature(checker.GetErasedSignature(signature))));
                    }
                }

                if (targetType != null)
                {
                    return GetNarrowedType(type, targetType, assumeTrue);
                }

                return type;
            }

            private IType GetNarrowedType(IType originalType, IType narrowedTypeCandidate, bool assumeTrue)
            {
                if (!assumeTrue)
                {
                    if ((originalType.Flags & TypeFlags.Union) != TypeFlags.None)
                    {
                        return m_checker.GetUnionType(
                                originalType.Cast<IUnionType>().Types.Filter(
                                    (m_checker, narrowedTypeCandidate),
                                    (t, tuple) =>
                                    {
                                        var checker = tuple.m_checker;
                                        var narrowedType = tuple.narrowedTypeCandidate;
                                        return !checker.IsTypeSubtypeOf(t, narrowedType);
                                    }));
                    }

                    return originalType;
                }

                // If the current type is a union type, remove all constituents that aren't assignable to target. If that produces
                // 0 candidates, fall back to the assignability check
                if ((originalType.Flags & TypeFlags.Union) != TypeFlags.None)
                {
                    var assignableConstituents = originalType.Cast<IUnionType>().Types.Filter(
                        (m_checker, narrowedTypeCandidate),
                        (t, tuple) =>
                        {
                            var checker = tuple.m_checker;
                            var narrowedType = tuple.narrowedTypeCandidate;
                            return checker.IsTypeAssignableTo(t, narrowedType);
                        });

                    if (assignableConstituents.Count != 0)
                    {
                        return m_checker.GetUnionType(assignableConstituents);
                    }
                }

                if (m_checker.IsTypeAssignableTo(narrowedTypeCandidate, originalType))
                {
                    // Narrow to the target type if it's assignable to the current type
                    return narrowedTypeCandidate;
                }

                return originalType;
            }

            private IType NarrowTypeByTypePredicate(IType type, ICallExpression expr, bool assumeTrue)
            {
                if ((type.Flags & TypeFlags.Any) != TypeFlags.None)
                {
                    return type;
                }

                var signature = m_checker.GetResolvedSignature(expr);
                var predicateType = m_checker.GetReturnTypeOfSignature(signature);

                if (predicateType == null || (predicateType.Flags & TypeFlags.PredicateType) == TypeFlags.None)
                {
                    return type;
                }

                var predicate = predicateType.Cast<IPredicateType>().Predicate;
                if (IsIdentifierTypePredicate(predicate) != null)
                {
                    // TODO: Verify correctness!
                    // TS implementation does:
                    // var callExpression = expr as CallExpression;
                    // if (callExpression.arguments[predicate.parameterIndex] &&
                    //     getSymbolAtTypePredicatePosition(callExpression.arguments[predicate.parameterIndex]) === symbol) {
                    if (expr.Arguments.ElementAtOrDefault(((IIdentifierTypePredicate)predicate).ParameterIndex.Value) != null &&
                        GetSymbolAtTypePredicatePosition(expr.Arguments[((IIdentifierTypePredicate)predicate).ParameterIndex.Value]) == m_symbol)
                    {
                        return GetNarrowedType(type, predicate.Type, assumeTrue);
                    }
                }
                else
                {
                    var expression = SkipParenthesizedNodes(expr.Expression);
                    return NarrowTypeByThisTypePredicate(type, (IThisTypePredicate)predicate, expression, assumeTrue);
                }

                return type;
            }

            private IType NarrowTypeByTypePredicateMember(IType type, /*HINT: ElementAccessExpression | PropertyAccessExpression*/ IExpression expr, bool assumeTrue)
            {
                if ((type.Flags & TypeFlags.Any) != TypeFlags.None)
                {
                    return type;
                }

                var memberType = m_checker.GetTypeOfExpression(expr);
                if ((memberType.Flags & TypeFlags.PredicateType) == TypeFlags.None)
                {
                    return type;
                }

                return NarrowTypeByThisTypePredicate(
                        type,
                        (IThisTypePredicate)memberType.Cast<IPredicateType>().Predicate, // TODO: Verify! - How do we know Predicate is of type ThisTypePredicate?
                        expr,
                        assumeTrue);
            }

            private IType NarrowTypeByThisTypePredicate(IType type, IThisTypePredicate predicate, IExpression expression, bool assumeTrue)
            {
                if (expression.Kind == SyntaxKind.ElementAccessExpression || expression.Kind == SyntaxKind.PropertyAccessExpression)
                {
                    var leftHandSideAccessExpression = expression.Kind == SyntaxKind.ElementAccessExpression ?
                                                            expression.Cast<IElementAccessExpression>().Expression :
                                                            expression.Cast<IPropertyAccessExpression>().Expression;

                    var possibleIdentifier = SkipParenthesizedNodes(leftHandSideAccessExpression);

                    if (possibleIdentifier.Kind == SyntaxKind.Identifier &&
                        GetSymbolAtTypePredicatePosition(possibleIdentifier) == m_symbol)
                    {
                        return GetNarrowedType(type, predicate.Type, assumeTrue);
                    }
                }

                return type;
            }

            private ISymbol GetSymbolAtTypePredicatePosition(IExpression expr)
            {
                expr = SkipParenthesizedNodes(expr);

                switch (expr.Kind)
                {
                    case SyntaxKind.Identifier:
                    case SyntaxKind.PropertyAccessExpression:
                    case SyntaxKind.QualifiedName:
                        return m_checker.GetSymbolOfEntityNameOrPropertyAccessExpression(expr);
                }

                return null;
            }

            // Narrow the given type based on the given expression having the assumed boolean value. The returned type
            // will be a subtype or the same type as the argument.
            private IType NarrowType(IType type, IExpression expr, bool assumeTrue)
            {
                switch (expr.Kind)
                {
                    case SyntaxKind.CallExpression:
                        return NarrowTypeByTypePredicate(type, expr.Cast<ICallExpression>(), assumeTrue);

                    case SyntaxKind.ParenthesizedExpression:
                        return NarrowType(type, expr.Cast<IParenthesizedExpression>().Expression, assumeTrue);

                    case SyntaxKind.BinaryExpression:
                        var @operator = expr.Cast<IBinaryExpression>().OperatorToken.Kind;

                        if (@operator == SyntaxKind.EqualsEqualsEqualsToken ||
                            @operator == SyntaxKind.ExclamationEqualsEqualsToken)
                        {
                            return NarrowTypeByEquality(type, expr.Cast<IBinaryExpression>(), assumeTrue);
                        }

                        if (@operator == SyntaxKind.AmpersandAmpersandToken)
                        {
                            return NarrowTypeByAnd(type, expr.Cast<IBinaryExpression>(), assumeTrue);
                        }

                        if (@operator == SyntaxKind.BarBarToken)
                        {
                            return NarrowTypeByOr(type, expr.Cast<IBinaryExpression>(), assumeTrue);
                        }

                        if (@operator == SyntaxKind.InstanceOfKeyword)
                        {
                            return NarrowTypeByInstanceof(type, expr.Cast<IBinaryExpression>(), assumeTrue);
                        }

                        break;

                    case SyntaxKind.PrefixUnaryExpression:
                        if (expr.Cast<IPrefixUnaryExpression>().Operator == SyntaxKind.ExclamationToken)
                        {
                            return NarrowType(type, expr.Cast<IPrefixUnaryExpression>().Operand, !assumeTrue);
                        }

                        break;

                    case SyntaxKind.ElementAccessExpression:
                    case SyntaxKind.PropertyAccessExpression:
                        return NarrowTypeByTypePredicateMember(type, expr, assumeTrue);
                }

                return type;
            }
        }

        private static IExpression SkipParenthesizedNodes(IExpression expression)
        {
            while (expression.Kind == SyntaxKind.ParenthesizedExpression)
            {
                expression = expression.Cast<IParenthesizedExpression>().Expression;
            }

            return expression;
        }

        private IType CheckIdentifier(IIdentifier node)
        {
            var symbol = GetResolvedSymbol(node);

            if (m_trackFileToFileDependencies)
            {
                RecordFile2FileRelationships(node, symbol);
            }

            // As noted in ECMAScript 6 language spec, arrow functions never have an arguments objects.
            // Although in down-level emit of arrow function, we emit it using function expression which means that
            // arguments objects will be bound to the inner object; emitting arrow function natively in ES6, arguments objects
            // will be bound to non-arrow function that contain this arrow function. This results in inconsistent behavior.
            // To avoid that we will give an error to users if they use arguments objects in arrow function so that they
            // can explicitly bound arguments objects
            if (symbol == m_argumentsSymbol)
            {
                var container = GetContainingFunction(node);
                if (container.Kind == SyntaxKind.ArrowFunction)
                {
                    if (m_languageVersion < ScriptTarget.Es6)
                    {
                        Error(
                            node,
                            Errors.The_arguments_object_cannot_be_referenced_in_an_arrow_function_in_ES3_and_ES5_Consider_using_a_standard_function_expression);
                    }
                }

                if (node.IsAwait())
                {
                    GetNodeLinks(container).Flags |= NodeCheckFlags.CaptureArguments;
                    GetNodeLinks(node).Flags |= NodeCheckFlags.LexicalArguments;
                }
            }

            if ((symbol.Flags & SymbolFlags.Alias) != SymbolFlags.None &&
                !IsInTypeQuery(node) &&
                !IsConstEnumOrConstEnumOnlyModule(ResolveAlias(symbol)))
            {
                MarkAliasSymbolAsReferenced(symbol);
            }

            CheckCollisionWithCapturedSuperVariable(node, node);
            CheckCollisionWithCapturedThisVariable(node, node);
            CheckBlockScopedBindingCapturedInLoop(node, symbol);

            return GetNarrowedTypeOfSymbol(
                    GetExportSymbolOfValueSymbolIfExported(symbol),
                    node);
        }

        private static bool IsInsideFunction(INode node, INode threshold)
        {
            var current = node;
            while (current != null && current.ResolveUnionType() != threshold.ResolveUnionType())
            {
                if (IsFunctionLike(current) != null)
                {
                    return true;
                }

                current = current.Parent;
            }

            return false;
        }

        private void CheckBlockScopedBindingCapturedInLoop(IIdentifier node, ISymbol symbol)
        {
            if (m_languageVersion >= ScriptTarget.Es6 ||
                (symbol.Flags & (SymbolFlags.BlockScopedVariable | SymbolFlags.Class)) == SymbolFlags.None ||
                symbol.ValueDeclaration.Parent.Kind == SyntaxKind.CatchClause)
            {
                return;
            }

            // 1. walk from the use site up to the declaration and check
            // if there is anything function like between declaration and use-site (is binding/class is captured in function).
            // 2. walk from the declaration up to the boundary of lexical environment and check
            // if there is an iteration statement in between declaration and boundary (is binding/class declared inside iteration statement)
            INode container = null;
            if ((symbol.Flags & SymbolFlags.Class) != SymbolFlags.None)
            {
                // get parent of class declaration
                container = GetClassLikeDeclarationOfSymbol(symbol).Parent;
            }
            else
            {
                // nesting structure:
                // (variable declaration or binding element) -> variable declaration list -> container
                container = symbol.ValueDeclaration;

                while (container.Kind != SyntaxKind.VariableDeclarationList)
                {
                    container = container.Parent;
                }

                // get the parent of variable declaration list
                container = container.Parent;
                if (container.Kind == SyntaxKind.VariableStatement)
                {
                    // if parent is variable statement - get its parent
                    container = container.Parent;
                }
            }

            var inFunction = IsInsideFunction(node.Parent, container);

            var current = container;
            while (current != null && !NodeStartsNewLexicalEnvironment(current))
            {
                if (IsIterationStatement(current, /*lookInLabeledStatements*/ false))
                {
                    if (inFunction)
                    {
                        GetNodeLinks(current).Flags |= NodeCheckFlags.LoopWithBlockScopedBindingCapturedInFunction;
                    }

                    // mark value declaration so during emit they can have a special handling
                    GetNodeLinks(symbol.ValueDeclaration).Flags |=
                        NodeCheckFlags.BlockScopedBindingInLoop;

                    break;
                }

                current = current.Parent;
            }
        }

        private void CaptureLexicalThis(INode node, INode container)
        {
            GetNodeLinks(node).Flags |= NodeCheckFlags.LexicalThis;

            if (container.Kind == SyntaxKind.PropertyDeclaration || container.Kind == SyntaxKind.Constructor)
            {
                var classNode = container.Parent;
                GetNodeLinks(classNode).Flags |= NodeCheckFlags.CaptureThis;
            }
            else
            {
                GetNodeLinks(container).Flags |= NodeCheckFlags.CaptureThis;
            }
        }

        private IType CheckThisExpression(INode node)
        {
            // Stop at the first arrow function so that we can
            // tell whether 'this' needs to be captured.
            var container = GetThisContainer(node, /* includeArrowFunctions */ true);

            Contract.Assert(container != null);
            var needToCaptureLexicalThis = false;

            // Now skip arrow functions to get the "real" owner of 'this'.
            if (container.Kind == SyntaxKind.ArrowFunction)
            {
                container = GetThisContainer(container, /* includeArrowFunctions */ false);

                // When targeting es6, arrow function lexically bind "this" so we do not need to do the work of binding "this" in emitted code
                needToCaptureLexicalThis = m_languageVersion < ScriptTarget.Es6;
            }

            switch (container.Kind)
            {
                case SyntaxKind.ModuleDeclaration:
                    Error(
                        node,
                        Errors.This_cannot_be_referenced_in_a_module_or_namespace_body);

                    // do not return here so in case if lexical this is captured - it will be reflected in flags on NodeLinks
                    break;

                case SyntaxKind.EnumDeclaration:
                    Error(
                        node,
                        Errors.This_cannot_be_referenced_in_current_location);

                    // do not return here so in case if lexical this is captured - it will be reflected in flags on NodeLinks
                    break;

                case SyntaxKind.Constructor:
                    if (IsInConstructorArgumentInitializer(node, container))
                    {
                        Error(
                            node,
                            Errors.This_cannot_be_referenced_in_constructor_arguments);

                        // do not return here so in case if lexical this is captured - it will be reflected in flags on NodeLinks
                    }

                    break;

                case SyntaxKind.PropertyDeclaration:
                case SyntaxKind.PropertySignature:
                    if ((container.Flags & NodeFlags.Static) != NodeFlags.None)
                    {
                        Error(
                            node,
                            Errors.This_cannot_be_referenced_in_a_static_property_initializer);

                        // do not return here so in case if lexical this is captured - it will be reflected in flags on NodeLinks
                    }

                    break;

                case SyntaxKind.ComputedPropertyName:
                    Error(
                        node,
                        Errors.This_cannot_be_referenced_in_a_computed_property_name);

                    break;
            }

            if (needToCaptureLexicalThis)
            {
                CaptureLexicalThis(node, container);
            }

            if (IsClassLike(container.Parent) != null)
            {
                var symbol = GetSymbolOfNode(container.Parent);
                return (container.Flags & NodeFlags.Static) != NodeFlags.None ?
                        GetTypeOfSymbol(symbol) :
                        GetDeclaredTypeOfSymbol(symbol).Cast<IInterfaceType>().ThisType; // TODO: Verify correctness - how can we safely cast to IInterfaceType?
            }

            // If this is a function in a JS file, it might be a class method. Check if it's the RHS
            // of a x.prototype.y = function [name]() { .... }
            if (node.IsJavaScriptFile() && container.Kind == SyntaxKind.FunctionExpression)
            {
                if (GetSpecialPropertyAssignmentKind(container.Parent) == SpecialPropertyAssignmentKind.PrototypeProperty)
                {
                    // Get the 'x' of 'x.prototype.y = f' (here, 'f' is 'container')
                    var className = container.Parent.Cast<IBinaryExpression>() // x.protoype.y = f
                                        .Left.Cast<IPropertyAccessExpression>() // x.prototype.y
                                        .Expression.Cast<IPropertyAccessExpression>() // x.prototype
                                        .Expression; // x

                    var classSymbol = CheckExpression(className).Symbol;
                    if (classSymbol?.Members != null && (classSymbol.Flags & SymbolFlags.Function) != SymbolFlags.None)
                    {
                        return GetInferredClassType(classSymbol);
                    }
                }
            }

            return m_anyType;
        }

        private static bool IsInConstructorArgumentInitializer(INode node, INode constructorDecl)
        {
            for (var n = node; n != null && n.ResolveUnionType() != constructorDecl.ResolveUnionType(); n = n.Parent)
            {
                if (n.Kind == SyntaxKind.Parameter)
                {
                    return true;
                }
            }

            return false;
        }

        // TODO: Irrelevant for our purposes (so far)
        private static IType CheckSuperExpression(INode node)
        {
            throw PlaceHolder.NotImplemented();

            // var isCallExpression = node.Parent.Kind == SyntaxKind.CallExpression && (node.Cast<ICallExpression>().Parent).Expression == node;

            // var container = getSuperContainer(node, /*stopOnFunctions*/ true);
            // var needToCaptureLexicalThis = false;

            // if (!isCallExpression)

            // {
            //    // adjust the container reference in case if super is used inside arrow functions with arbitrary deep nesting
            //    while (container && container.Kind == SyntaxKind.ArrowFunction)
            //    {
            //        container = getSuperContainer(container, /*stopOnFunctions*/ true);
            //        needToCaptureLexicalThis = languageVersion < ScriptTarget.ES6;
            //    }
            // }

            // var canUseSuperExpression = isLegalUsageOfSuperExpression(container);
            // NodeCheckFlags nodeCheckFlag = 0;

            // if (!canUseSuperExpression)
            // {
            //            // issue more specific error if super is used in computed property name
            //            // class A { foo() { return "1" }}
            //            // class B {
            //            //     [super.foo()]() {}
            //            // }
            //            var current = node;
            //        while (current && current != container && current.Kind != SyntaxKind.ComputedPropertyName)
            //        {
            //            current = current.Parent;
            //        }
            //        if (current && current.Kind == SyntaxKind.ComputedPropertyName)
            //        {
            //            error(node, Errors.Super_cannot_be_referenced_in_a_computed_property_name);
            //        }
            //        else if (isCallExpression != null)
            //        {
            //            error(node, Errors.Super_calls_are_not_permitted_outside_constructors_or_in_nested_functions_inside_constructors);
            //        }
            //        else if (!container || !container.Parent || !(IsClassLike(container.Parent) || container.Parent.Kind == SyntaxKind.ObjectLiteralExpression))
            //        {
            //            error(node, Errors.Super_can_only_be_referenced_in_members_of_derived_classes_or_object_literal_expressions);
            //        }
            //        else
            //        {
            //            error(node, Errors.Super_property_access_is_permitted_only_in_a_constructor_member_function_or_member_accessor_of_a_derived_class);
            //        }
            //        return m_unknownType;
            //    }

            // if ((container.Flags & NodeFlags.Static) || isCallExpression)

            // {
            //        nodeCheckFlag = NodeCheckFlags.SuperStatic;
            //    }
            //    else
            //    {
            //        nodeCheckFlag = NodeCheckFlags.SuperInstance;
            //    }

            // GetNodeLinks(node).flags |= nodeCheckFlag;

            // if (needToCaptureLexicalThis != null)

            // {
            //        // call expressions are allowed only in constructors so they should always capture correct 'this'
            //        // super property access expressions can also appear in arrow functions -
            //        // in this case they should also use correct lexical this
            //        captureLexicalThis(node.Parent, container);
            //    }

            // if (container.Parent.Kind == SyntaxKind.ObjectLiteralExpression)

            // {
            //        if (languageVersion < ScriptTarget.ES6)
            //        {
            //            error(node, Errors.Super_is_only_allowed_in_members_of_object_literal_expressions_when_option_target_is_ES2015_or_higher);
            //            return m_unknownType;
            //        }
            //        else
            //        {
            //            // for object literal assume that type of 'super' is 'any'
            //            return anyType;
            //        }
            //    }

            // // at this point the only legal case for parent is ClassLikeDeclaration
            //    var classLikeDeclaration = container.Cast<IClassLikeDeclaration>().Parent;
            //    var classType = GetDeclaredTypeOfSymbol.Cast<IInterfaceType>()(GetSymbolOfNode(classLikeDeclaration));
            //    var baseClassType = classType && getBaseTypes(classType)[0];
            //    if (!baseClassType)
            //    {
            //        if (!getClassExtendsHeritageClauseElement(classLikeDeclaration))
            //        {
            //            error(node, Errors.Super_can_only_be_referenced_in_a_derived_class);
            //        }
            //        return m_unknownType;
            //    }

            // if (container.Kind == SyntaxKind.Constructor && isInConstructorArgumentInitializer(node, container))

            // {
            //        // issue custom error message for super property access in constructor arguments (to be aligned with old compiler)
            //        error(node, Errors.Super_cannot_be_referenced_in_constructor_arguments);
            //        return m_unknownType;
            //    }

            // return nodeCheckFlag == NodeCheckFlags.SuperStatic
            //        ? getBaseConstructorTypeOfClass(classType)
            //        : baseClassType;
        }

        // Return contextual type of parameter or undefined if no contextual type is available
        private IType GetContextuallyTypedParameterType(IParameterDeclaration parameter)
        {
            var func = parameter.Parent;

            if (IsFunctionExpressionOrArrowFunction(func) || IsObjectLiteralMethod(func) != null)
            {
                if (IsContextSensitive(func))
                {
                    var contextualSignature = GetContextualSignature(func);

                    if (contextualSignature != null)
                    {
                        ISignatureDeclaration functionDeclaration = func.Cast<ISignatureDeclaration>();

                        var funcHasRestParameters = HasRestParameter(functionDeclaration);
                        var len = functionDeclaration.Parameters.Length - (funcHasRestParameters ? 1 : 0);
                        var indexOfParameter = IndexOf(functionDeclaration.Parameters, parameter);

                        if (indexOfParameter < len)
                        {
                            return GetTypeAtPosition(contextualSignature, indexOfParameter);
                        }

                        // If last parameter is contextually rest parameter get its type
                        if (funcHasRestParameters &&
                            indexOfParameter == functionDeclaration.Parameters.Length - 1 &&
                            IsRestParameterIndex(contextualSignature, functionDeclaration.Parameters.Length - 1))
                        {
                            return GetTypeOfSymbol(contextualSignature.Parameters.LastOrDefault());
                        }
                    }
                }
            }

            return null;
        }

        // In a variable, parameter or property declaration with a type annotation, the contextual type of an initializer
        // expression is the type of the variable, parameter or property. Otherwise, in a parameter declaration of a
        // contextually typed function expression, the contextual type of an initializer expression is the contextual type
        // of the parameter. Otherwise, in a variable or parameter declaration with a binding pattern name, the contextual
        // type of an initializer expression is the type implied by the binding pattern.
        private IType GetContextualTypeForInitializerExpression(IExpression node)
        {
            var declaration = node.Parent.Cast<IVariableLikeDeclaration>();

            if (node.ResolveUnionType() == declaration.Initializer.ResolveUnionType())
            {
                if (declaration.Type != null)
                {
                    return GetTypeFromTypeNode(declaration.Type);
                }

                if (declaration.Kind == SyntaxKind.Parameter)
                {
                    var type = GetContextuallyTypedParameterType(declaration.Cast<IParameterDeclaration>());
                    if (type != null)
                    {
                        return type;
                    }
                }

                if (IsBindingPattern(declaration.Name) != null)
                {
                    return GetTypeFromBindingPattern(declaration.Name.Cast<IBindingPattern>(), /*includePatternInType*/ true);
                }
            }

            return null;
        }

        private IType GetContextualTypeForReturnExpression(IExpression node)
        {
            var func = GetContainingFunction(node);

            if (func != null && !func.AsteriskToken)
            {
                return GetContextualReturnType(func);
            }

            return null;
        }

        private IType GetContextualTypeForYieldOperand(IYieldExpression node)
        {
            var func = GetContainingFunction(node);

            if (func != null)
            {
                var contextualReturnType = GetContextualReturnType(func);

                if (contextualReturnType != null)
                {
                    return node.AsteriskToken != null ?
                            contextualReturnType :
                            GetElementTypeOfIterableIterator(contextualReturnType);
                }
            }

            return null;
        }

        private static bool IsInParameterInitializerBeforeContainingFunction(INode node)
        {
            while (node.Parent != null && IsFunctionLike(node.Parent) == null)
            {
                if (node.Parent.Kind == SyntaxKind.Parameter &&
                    node.Parent.Cast<IParameterDeclaration>().Initializer.ResolveUnionType() == node.ResolveUnionType())
                {
                    return true;
                }

                node = node.Parent;
            }

            return false;
        }

        private IType GetContextualReturnType(IFunctionLikeDeclaration functionDecl)
        {
            // If the containing function has a return type annotation, is a constructor, or is a get accessor whose
            // corresponding set accessor has a type annotation, return statements in the function are contextually typed
            if (functionDecl.Type != null ||
                functionDecl.Kind == SyntaxKind.Constructor ||
                (functionDecl.Kind == SyntaxKind.GetAccessor &&
                GetSetAccessorTypeAnnotationNode(GetDeclarationOfKind(functionDecl.Symbol, SyntaxKind.SetAccessor)?.Cast<IAccessorDeclaration>()) != null))
            {
                return GetReturnTypeOfSignature(GetSignatureFromDeclaration(functionDecl));
            }

            // Otherwise, if the containing function is contextually typed by a function type with exactly one call signature
            // and that call signature is non-generic, return statements are contextually typed by the return type of the signature
            var signature = GetContextualSignatureForFunctionLikeDeclaration(functionDecl);
            if (signature != null)
            {
                return GetReturnTypeOfSignature(signature);
            }

            return null;
        }

        // In a typed function call, an argument or substitution expression is contextually typed by the type of the corresponding parameter.
        private IType GetContextualTypeForArgument(/*HINT: CallLikeExpression*/ INode callTarget, IExpression arg)
        {
            // Using pooled list to avoid transient allocations.
            using (var pooledList = ObjectPools.ExpressionListPool.GetInstance())
            {
                var callArgs = pooledList.Instance;
                var args = GetEffectiveCallArguments(callTarget, callArgs);
                args = args ?? callArgs;

                var argIndex = args.IndexOf(arg);

                if (argIndex >= 0)
                {
                    var signature = GetResolvedSignature(callTarget);
                    return GetTypeAtPosition(signature, argIndex);
                }
            }

            return null;
        }

        private IType GetContextualTypeForSubstitutionExpression(ITemplateExpression template, IExpression substitutionExpression)
        {
            if (template.Parent.Kind == SyntaxKind.TaggedTemplateExpression)
            {
                return GetContextualTypeForArgument(
                        template.Parent.Cast<ITaggedTemplateExpression>(),
                        substitutionExpression);
            }

            return null;
        }

        private IType GetContextualTypeForBinaryOperand(IExpression node)
        {
            // HINT: node.Parent is IBinaryExpression is guaranteed by caller
            var binaryExpression = node.Parent.Cast<IBinaryExpression>();
            var @operator = binaryExpression.OperatorToken.Kind;

            if (@operator >= SyntaxKind.FirstAssignment && @operator <= SyntaxKind.LastAssignment)
            {
                // In an assignment expression, the right operand is contextually typed by the type of the left operand.
                if (node.ResolveUnionType() == binaryExpression.Right.ResolveUnionType())
                {
                    return CheckExpression(binaryExpression.Left);
                }
            }
            else if (@operator == SyntaxKind.BarBarToken)
            {
                // When an || expression has a contextual type, the operands are contextually typed by that type. When an ||
                // expression has no contextual type, the right operand is contextually typed by the type of the left operand.
                var type = GetContextualType(binaryExpression);

                if (type == null && node.ResolveUnionType() == binaryExpression.Right.ResolveUnionType())
                {
                    type = CheckExpression(binaryExpression.Left);
                }

                return type;
            }

            return null;
        }

        // Apply a mapping  to a contextual type and return the resulting type. If the contextual type
        // is a union type, the mapping  is applied to each constituent type and a union of the resulting
        // types is returned.
        private IType ApplyToContextualType<TState>(TState state, IType type, Func<TState, IType /*t*/, IType> mapper)
        {
            if ((type.Flags & TypeFlags.Union) == TypeFlags.None)
            {
                return mapper(state, type);
            }

            var types = type.Cast<IUnionType>().Types;
            IType mappedType = null;
            List<IType> mappedTypes = null;

            foreach (var current in types)
            {
                var t = mapper(state, current);
                if (t != null)
                {
                    if (mappedType == null)
                    {
                        mappedType = t;
                    }
                    else if (mappedTypes == null)
                    {
                        mappedTypes = new List<IType> { mappedType, t };
                    }
                    else
                    {
                        mappedTypes.Add(t);
                    }
                }
            }

            return mappedTypes != null ? GetUnionType(mappedTypes) : mappedType;
        }

        private IType GetTypeOfPropertyOfContextualType(IType type, string name)
        {
            return ApplyToContextualType((checker: this, name), type, (tpl, t) =>
            {
                var @this = tpl.checker;
                var localName = tpl.name;
                var prop = (t.Flags & TypeFlags.StructuredType) != TypeFlags.None ?
                            @this.GetPropertyOfType(t, localName) :
                            null;

                return prop != null ? @this.GetTypeOfSymbol(prop) : null;
            });
        }

        private IType GetIndexTypeOfContextualType(IType type, IndexKind kind)
        {
            return ApplyToContextualType((checker: this, kind), type,
                (tpl, t) =>
                {
                    var @this = tpl.checker;
                    var localKind = tpl.kind;
                    return @this.GetIndexTypeOfStructuredType(t, localKind);
                });
        }

        private static bool ContextualTypeIsStringLiteralType(IType type)
        {
            return (type.Flags & TypeFlags.Union) != TypeFlags.None ?
                    Any(type.Cast<IUnionType>().Types, t => IsStringLiteralType(t)) :
                    IsStringLiteralType(type);
        }

        // Return true if the given contextual type is a tuple-like type
        private bool ContextualTypeIsTupleLikeType(IType type)
        {
            return (type.Flags & TypeFlags.Union) != TypeFlags.None ?
                    Any(type.Cast<IUnionType>().Types, this, (t, @this) => @this.IsTupleLikeType(t)) :
                    IsTupleLikeType(type);
        }

        // Return true if the given contextual type provides an index signature of the given kind
        private bool ContextualTypeHasIndexSignature(IType type, IndexKind kind)
        {
            return
                (type.Flags & TypeFlags.Union) != TypeFlags.None
                ? ForEachUntil(type.Cast<IUnionType>().Types, (kind, checker: this), (t, tpl) => tpl.Item2.GetIndexTypeOfStructuredType(t, tpl.kind)) != null
                : GetIndexTypeOfStructuredType(type, kind) != null;
        }

        // In an object literal contextually typed by a type T, the contextual type of a property assignment is the type of
        // the matching property in T, if one exists. Otherwise, it is the type of the numeric index signature in T, if one
        // exists. Otherwise, it is the type of the string index signature in T, if one exists.
        private IType GetContextualTypeForObjectLiteralMethod(IMethodDeclaration node)
        {
            Contract.Assert(IsObjectLiteralMethod(node) != null);

            if (IsInsideWithStatementBody(node))
            {
                // We cannot answer semantic questions within a with block, do not proceed any further
                return null;
            }

            return GetContextualTypeForObjectLiteralElement(node);
        }

        private IType GetContextualTypeForObjectLiteralElement(IObjectLiteralElement element)
        {
            var objectLiteral = element.Parent.Cast<IObjectLiteralExpression>();
            var type = GetApparentTypeOfContextualType(objectLiteral);

            if (type != null)
            {
                if (!HasDynamicName(element))
                {
                    // For a (non-symbol) computed property, there is no reason to look up the name
                    // in the type. It will just be "__computed", which does not appear in any
                    // SymbolTable.
                    var symbolName = GetSymbolOfNode(element).Name;
                    var propertyType = GetTypeOfPropertyOfContextualType(type, symbolName);
                    if (propertyType != null)
                    {
                        return propertyType;
                    }
                }

                IType result = null;
                if (IsNumericName(element.Name))
                {
                    result = GetIndexTypeOfContextualType(type, IndexKind.Number);
                }

                result = result ?? GetIndexTypeOfContextualType(type, IndexKind.String);
                return result;
            }

            return null;
        }

        // In an array literal contextually typed by a type T, the contextual type of an element expression at index N is
        // the type of the property with the numeric name N in T, if one exists. Otherwise, if T has a numeric index signature,
        // it is the type of the numeric index signature in T. Otherwise, in ES6 and higher, the contextual type is the iterated
        // type of T.
        private IType GetContextualTypeForElementExpression(IExpression node)
        {
            // HINT: node is IArrayLiteralExpression is guaranteed by the caller
            var arrayLiteral = node.Parent.Cast<IArrayLiteralExpression>();
            var type = GetApparentTypeOfContextualType(arrayLiteral);

            if (type != null)
            {
                var index = IndexOf(arrayLiteral.Elements, node);

                return GetTypeOfPropertyOfContextualType(type, index.ToString()) ??
                       GetIndexTypeOfContextualType(type, IndexKind.Number) ??
                       (m_languageVersion >= ScriptTarget.Es6 ? GetElementTypeOfIterable(type, /*errorNode*/ null) : null);
            }

            return null;
        }

        // In a contextually typed conditional expression, the true/false expressions are contextually typed by the same type.
        private IType GetContextualTypeForConditionalOperand(IExpression node)
        {
            var conditional = node.Parent.Cast<IConditionalExpression>();
            return (node.ResolveUnionType() == conditional.WhenTrue.ResolveUnionType()) || (node.ResolveUnionType() == conditional.WhenFalse.ResolveUnionType()) ?
                    GetContextualType(conditional) :
                    null;
        }

        // Return the contextual type for a given expression node. During overload resolution, a contextual type may temporarily
        // be "pushed" onto a node using the contextualType property.
        private IType GetApparentTypeOfContextualType(IExpression node)
        {
            var type = GetContextualType(node);

            return type != null ? GetApparentType(type) : null;
        }

        /// <summary>
        /// Woah! Do you really want to use this function?
        ///
        /// Unless you're trying to get the *non-apparent* type for a
        /// value-literal type or you're authoring relevant portions of this algorithm,
        /// you probably meant to use 'getApparentTypeOfContextualType'.
        /// Otherwise this may not be very useful.
        ///
        /// In cases where you *are* working on this function, you should understand
        /// when it is appropriate to use 'getContextualType' and 'getApparentTypeOfContetxualType'.
        ///
        ///   - Use 'getContextualType' when you are simply going to propagate the result to the expression.
        ///   - Use 'getApparentTypeOfContextualType' when you're going to need the members of the type.
        ///
        /// </summary>
        /// <param name="node">The expression whose contextual type will be returned.</param>
        /// <returns>The contextual type of an expression.</returns>
        public IType GetContextualType(IExpression node)
        {
            if (IsInsideWithStatementBody(node))
            {
                // We cannot answer semantic questions within a with block, do not proceed any further
                return null;
            }

            var nodeContextualType = GetContextualTypeOrDefault(node);
            if (nodeContextualType != null)
            {
                return nodeContextualType;
            }

            var parent = node.Parent;
            switch (parent.Kind)
            {
                case SyntaxKind.VariableDeclaration:
                case SyntaxKind.Parameter:
                case SyntaxKind.PropertyDeclaration:
                case SyntaxKind.PropertySignature:
                case SyntaxKind.BindingElement:
                    return GetContextualTypeForInitializerExpression(node);

                case SyntaxKind.ArrowFunction:
                case SyntaxKind.ReturnStatement:
                    return GetContextualTypeForReturnExpression(node);

                case SyntaxKind.YieldExpression:
                    return GetContextualTypeForYieldOperand(parent.Cast<IYieldExpression>());

                case SyntaxKind.CallExpression:
                case SyntaxKind.NewExpression:
                    return GetContextualTypeForArgument(parent.Cast<ICallExpression>(), node);

                case SyntaxKind.TypeAssertionExpression:
                    return GetTypeFromTypeNode(parent.Cast<ITypeAssertion>().Type);

                case SyntaxKind.AsExpression:
                    return GetTypeFromTypeNode(parent.Cast<IAsExpression>().Type);

                case SyntaxKind.BinaryExpression:
                    return GetContextualTypeForBinaryOperand(node);

                case SyntaxKind.PropertyAssignment:
                    return GetContextualTypeForObjectLiteralElement(parent.Cast<IObjectLiteralElement>());

                case SyntaxKind.ArrayLiteralExpression:
                    return GetContextualTypeForElementExpression(node);

                case SyntaxKind.ConditionalExpression:
                    return GetContextualTypeForConditionalOperand(node);

                case SyntaxKind.TemplateSpan:
                    Contract.Assert(parent.Parent.Kind == SyntaxKind.TemplateExpression);
                    return GetContextualTypeForSubstitutionExpression(parent.Parent.Cast<ITemplateExpression>(), node);

                case SyntaxKind.ParenthesizedExpression:
                    return GetContextualType(parent.Cast<IParenthesizedExpression>());
            }

            return null;
        }

        // Ported from commit 740792c5a1fdc738f13e5530e9395d4d1fabe242
        private bool ShouldAcquireLiteralType(ILiteralExpression literalNode)
        {
            if (IsEqualityComparisonOperand(literalNode))
            {
                return true;
            }

            var contextualType = GetContextualType(literalNode);

            return contextualType != null && ContextualTypeIsStringLiteralType(contextualType);
        }

        /// <summary>
        /// Returns true if an expression might be evaluated as part of an equality comparison.
        /// This includes inequality(e.g. '!==') and 'switch'/'case' equality.
        /// </summary>
        /// <remarks>Ported from commit 740792c5a1fdc738f13e5530e9395d4d1fabe242</remarks>
        private bool IsEqualityComparisonOperand(IExpression expression)
        {
            var parent = expression?.Parent;

            switch (parent?.Kind ?? SyntaxKind.Unknown)
            {
                // The operand of a 'switch' should get a literal type.
                case SyntaxKind.SwitchStatement:
                    return expression.ResolveUnionType() == parent.As<ISwitchStatement>().Expression.ResolveUnionType();

                // The tested expression of a 'case' clause should get a literal type.
                case SyntaxKind.CaseClause:
                    return expression.ResolveUnionType() == parent.As<ICaseClause>().Expression.ResolveUnionType();

                case SyntaxKind.BinaryExpression:
                    var binaryExpr = parent.Cast<IBinaryExpression>();

                    switch (binaryExpr.OperatorToken.Kind)
                    {
                        // Either operand of an equality/inequality comparison
                        // should get a literal type.
                        case SyntaxKind.EqualsEqualsEqualsToken:
                        case SyntaxKind.ExclamationEqualsEqualsToken:
                        case SyntaxKind.EqualsEqualsToken:
                        case SyntaxKind.ExclamationEqualsToken:
                            return true;

                        case SyntaxKind.AmpersandAmpersandToken:
                        case SyntaxKind.CommaToken:
                            if (expression.ResolveUnionType() == binaryExpr.Right.ResolveUnionType())
                            {
                                return IsEqualityComparisonOperand(binaryExpr);
                            }

                            return false;

                        case SyntaxKind.BarBarToken:
                            return IsEqualityComparisonOperand(binaryExpr);
                    }

                    // No binary operators apply.
                    return false;

                case SyntaxKind.ConditionalExpression:
                    var conditional = parent.As<IConditionalExpression>();
                    if (expression.ResolveUnionType() == conditional.WhenTrue.ResolveUnionType() || expression.ResolveUnionType() == conditional.WhenFalse.ResolveUnionType())
                    {
                        return IsEqualityComparisonOperand(conditional);
                    }

                    return false;

                case SyntaxKind.ParenthesizedExpression:
                    return IsEqualityComparisonOperand(parent.As<IParenthesizedExpression>());

                case SyntaxKind.TypeAssertionExpression:
                case SyntaxKind.AsExpression:
                    return IsEqualityComparisonOperand(parent.As<ITypeAssertion>());
            }

            return false;
        }

        // If the given type is an object or union type, if that type has a single signature, and if
        // that signature is non-generic, return the signature. Otherwise return null.
        private ISignature GetNonGenericSignature(IType type)
        {
            var signatures = GetSignaturesOfStructuredType(type, SignatureKind.Call);
            if (signatures.Count == 1)
            {
                var signature = signatures[0];

                if (signature.TypeParameters == null)
                {
                    return signature;
                }
            }

            return null;
        }

        private static bool IsFunctionExpressionOrArrowFunction(INode node)
        {
            return node.Kind == SyntaxKind.FunctionExpression || node.Kind == SyntaxKind.ArrowFunction;
        }

        private ISignature GetContextualSignatureForFunctionLikeDeclaration(/*HINT: IFunctionLikeDeclaration*/ INode node)
        {
            // Only  expressions, arrow functions, and object literal methods are contextually typed.
            return IsFunctionExpressionOrArrowFunction(node) || (IsObjectLiteralMethod(node) != null)
                ? GetContextualSignature(node)
                : null;
        }

        // Return the contextual signature for a given expression node. A contextual type provides a
        // contextual signature if it has a single call signature and if that call signature is non-generic.
        // If the contextual type is a union type, get the signature from each type possible and if they are
        // all identical ignoring their return type, the result is same signature but with return type as
        // union type of return types from these signatures
        private ISignature GetContextualSignature(/*HINT: FunctionExpression | MethodDeclaration*/ INode node)
        {
            Contract.Requires(node.Kind != SyntaxKind.MethodDeclaration || IsObjectLiteralMethod(node) != null);

            var type = IsObjectLiteralMethod(node) != null ?
                        GetContextualTypeForObjectLiteralMethod(node.Cast<IMethodDeclaration>()) :
                        GetApparentTypeOfContextualType(node.Cast<IExpression>());

            if (type == null)
            {
                return null;
            }

            if ((type.Flags & TypeFlags.Union) == TypeFlags.None)
            {
                return GetNonGenericSignature(type);
            }

            List<ISignature> signatureList = null;
            var types = type.Cast<IUnionType>().Types;
            foreach (var current in types)
            {
                var signature = GetNonGenericSignature(current);
                if (signature != null)
                {
                    if (signatureList == null)
                    {
                        // This signature will contribute to contextual union signature
                        signatureList = new List<ISignature> { signature };
                    }
                    else if (CompareSignaturesIdentical(
                                signatureList[0],
                                signature,
                                /*partialMatch*/ false,
                                /*ignoreReturnTypes*/ true,
                                CompareTypesIdentical) == Ternary.False)
                    {
                        // Signatures aren't identical, do not use
                        return null;
                    }
                    else
                    {
                        // Use this signature for contextual union signature
                        signatureList.Add(signature);
                    }
                }
            }

            // Result is union of signatures collected (return type is union of return types of this signature set)
            ISignature result = null;
            if (signatureList != null)
            {
                result = CloneSignature(signatureList[0], signatureList);

                // Clear resolved return type we possibly got from cloneSignature
                result.ResolvedReturnType = null;
            }

            return result;
        }

        /// <summary>
        /// Detect if the mapper implies an inference context. Specifically, there are 4 possible values
        /// for a mapper. Let's go through each one of them:
        ///
        ///    1. undefined - this means we are not doing inferential typing, but we may do contextual typing,
        ///       which could cause us to assign a parameter a type
        ///    2. identityMapper - means we want to avoid assigning a parameter a type, whether or not we are in
        ///       inferential typing (context is undefined for the identityMapper)
        ///    3. a mapper created by createInferenceMapper - we are doing inferential typing, we want to assign
        ///       types to parameters and fix type parameters (context is defined)
        ///    4. an instantiation mapper created by createTypeMapper or createTypeEraser - this should never be
        ///       passed as the contextual mapper when checking an expression (context is null for these)
        ///
        /// isInferentialContext is detecting if we are in case 3
        /// </summary>
        private static IInferenceContext IsInferentialContext(ITypeMapper mapper)
        {
            return mapper?.Context;
        }

        // A node is an assignment target if it is on the left hand side of an '=' token, if it is parented by a property
        // assignment in an object literal that is an assignment target, or if it is parented by an array literal that is
        // an assignment target. Examples include 'a = xxx', '{ p : a } = xxx', '[{p : a}] = xxx'.
        private bool IsAssignmentTarget(INode node)
        {
            var parent = node.Parent;

            if (parent.Kind == SyntaxKind.BinaryExpression &&
                parent.Cast<IBinaryExpression>().OperatorToken.Kind == SyntaxKind.EqualsToken &&
                parent.Cast<IBinaryExpression>().Left.ResolveUnionType() == node.ResolveUnionType())
            {
                return true;
            }

            if (parent.Kind == SyntaxKind.PropertyAssignment)
            {
                return IsAssignmentTarget(parent.Parent);
            }

            if (parent.Kind == SyntaxKind.ArrayLiteralExpression)
            {
                return IsAssignmentTarget(parent);
            }

            return false;
        }

        private IType CheckSpreadElementExpression(ISpreadElementExpression node, ITypeMapper contextualMapper = null)
        {
            // It is usually not safe to call checkExpressionCached if we can be contextually typing.
            // You can tell that we are contextually typing because of the contextualMapper parameter.
            // While it is true that a spread element can have a contextual type, it does not do anything
            // with this type. It is neither affected by it, nor does it propagate it to its operand.
            // So the fact that contextualMapper is passed is not important, because the operand of a spread
            // element is not contextually typed.
            var arrayOrIterableType = CheckExpressionCached(node.Expression, contextualMapper);

            return CheckIteratedTypeOrElementType(
                    arrayOrIterableType,
                    node.Expression,
                    /*allowStringInput*/ false);
        }

        private static bool HasDefaultValue(/*HINT: BindingElement | Expression*/ INode node)
        {
            return (node.Kind == SyntaxKind.BindingElement && node.Cast<IBindingElement>().Initializer != null) ||
                   (node.Kind == SyntaxKind.BinaryExpression && node.Cast<IBinaryExpression>().OperatorToken.Kind == SyntaxKind.EqualsToken);
        }

        // HINT: This is a private function, used to factor out common logic from CheckArrayLiteral
        private void PadElementTypes<T>(NodeArray<T> patternElements, IType contextualType, List<IType> elementTypes) where T : INode
        {
            for (var i = elementTypes.Count; i < patternElements.Length; i++)
            {
                var patternElement = patternElements[i];

                if (HasDefaultValue(patternElement))
                {
                    elementTypes.Add(contextualType.Cast<ITupleType>().ElementTypes[i]);
                }
                else
                {
                    if (patternElement.Kind != SyntaxKind.OmittedExpression)
                    {
                        Error(
                            patternElement,
                            Errors.Initializer_provides_no_value_for_this_binding_element_and_the_binding_element_has_no_default_value);
                    }

                    elementTypes.Add(m_unknownType);
                }
            }
        }

        private IType CheckArrayLiteral(IArrayLiteralExpression node, ITypeMapper contextualMapper = null)
        {
            var elements = node.Elements;
            var hasSpreadElement = false;
            List<IType> elementTypes = new List<IType>(elements.Count);
            var inDestructuringPattern = IsAssignmentTarget(node);

            foreach (var e in elements.AsStructEnumerable())
            {
                if (inDestructuringPattern && e.Kind == SyntaxKind.SpreadElementExpression)
                {
                    // Given the following situation:
                    //    var c: {};
                    //    [...c] = ["", 0];
                    //
                    // c is represented in the tree as a spread element in an array literal.
                    // But c really functions as a rest element, and its purpose is to provide
                    // a contextual type for the right hand side of the assignment. Therefore,
                    // instead of calling checkExpression on "...c", which will give an error
                    // if c is not iterable/array-like, we need to act as if we are trying to
                    // get the contextual element type from it. So we do something similar to
                    // getContextualTypeForElementExpression, which will crucially not error
                    // if there is no index type / iterated type.
                    var restArrayType = CheckExpression(e.Cast<ISpreadElementExpression>().Expression, contextualMapper);
                    var restElementType = GetIndexTypeOfType(restArrayType, IndexKind.Number) ??
                                          (m_languageVersion >= ScriptTarget.Es6 ?
                                                GetElementTypeOfIterable(restArrayType, /*errorNode*/ null) :
                                                null);

                    if (restElementType != null)
                    {
                        elementTypes.Add(restElementType);
                    }
                }
                else
                {
                    var type = CheckExpression(e, contextualMapper);
                    elementTypes.Add(type);
                }

                hasSpreadElement = hasSpreadElement || e.Kind == SyntaxKind.SpreadElementExpression;
            }

            if (!hasSpreadElement)
            {
                // If array literal is actually a destructuring pattern, mark it as an implied type. We do this such
                // that we get the same behavior for "var [x, y] = []" and "[x, y] = []".
                if (inDestructuringPattern && elementTypes.Count != 0)
                {
                    var type = CreateNewTupleType(elementTypes);
                    type.Pattern = new DestructuringPattern(node);
                    return type;
                }

                var contextualType = GetApparentTypeOfContextualType(node);
                if (contextualType != null && ContextualTypeIsTupleLikeType(contextualType))
                {
                    var pattern = contextualType.Pattern;

                    // If array literal is contextually typed by a binding pattern or an assignment pattern, pad the resulting
                    // tuple type with the corresponding binding or assignment element types to make the lengths equal.
                    if (pattern != null && (pattern.Kind == SyntaxKind.ArrayBindingPattern || pattern.Kind == SyntaxKind.ArrayLiteralExpression))
                    {
                        if (pattern.Kind == SyntaxKind.ArrayBindingPattern)
                        {
                            PadElementTypes(pattern.Cast<IBindingPattern>().Elements, contextualType, elementTypes);
                        }
                        else
                        {
                            PadElementTypes(pattern.Cast<IArrayLiteralExpression>().Elements, contextualType, elementTypes);
                        }
                    }

                    if (elementTypes.Count != 0)
                    {
                        return CreateTupleType(elementTypes);
                    }
                }
            }

            return CreateArrayType(elementTypes.Count != 0 ? GetUnionType(elementTypes) : m_undefinedType);
        }

        private bool IsNumericName(DeclarationName name)
        {
            return name.Kind == SyntaxKind.ComputedPropertyName ?
                    IsNumericComputedName(name.Cast<IComputedPropertyName>()) :
                    Number.IsNumericLiteralName(name.Cast<IIdentifier>().Text); // TODO: Verify correctness! How can we guarantee name is IIdentifier here?
        }

        private bool IsNumericComputedName(IComputedPropertyName name)
        {
            // It seems odd to consider an expression of type Any to result in a numeric name,
            // but this behavior is consistent with checkIndexedAccess
            return IsTypeAnyOrAllConstituentTypesHaveKind(
                    CheckComputedPropertyName(name),
                    TypeFlags.NumberLike);
        }

        private bool IsTypeAnyOrAllConstituentTypesHaveKind(IType type, TypeFlags kind)
        {
            return IsTypeAny(type) || IsTypeOfKind(type, kind);
        }

        private IType CheckComputedPropertyName(IComputedPropertyName nodeArg)
        {
            return GetNodeLinks(nodeArg).GetOrSetResolvedType(
                 (checker: this, nodeArg),
                (links, tuple) =>
                {
                    var @this = tuple.checker;
                    var node = tuple.nodeArg;
                    var resolvedType = CheckExpression(node.Expression);

                    // This will allow types number, string, symbol or any. It will also allow enums, the unknown
                    // type, and any union of these types (like string | number).
                    if (!@this.IsTypeAnyOrAllConstituentTypesHaveKind(resolvedType, TypeFlags.NumberLike | TypeFlags.StringLike | TypeFlags.EsSymbol))
                    {
                        Error(
                            node,
                            Errors.A_computed_property_name_must_be_of_type_string_number_symbol_or_any);
                    }
                    else
                    {
                        @this.CheckThatExpressionIsProperSymbolReference(
                            node.Expression,
                            resolvedType,
                            /*reportError*/ true);
                    }

                    return resolvedType;
                });
        }

        private IType CheckObjectLiteral(IObjectLiteralExpression node, ITypeMapper contextualMapper = null)
        {
            var inDestructuringPattern = IsAssignmentTarget(node);

            // Grammar checking
            CheckGrammarObjectLiteralExpression(node, inDestructuringPattern);

            ISymbolTable propertiesTable = new SymbolTable(node.Properties.Length);
            List<ISymbol> propertiesArray = new List<ISymbol>(node.Properties.Length);
            var contextualType = GetApparentTypeOfContextualType(node);
            var contextualTypeHasPattern = contextualType?.Pattern != null &&
                                           (contextualType.Pattern.Kind == SyntaxKind.ObjectBindingPattern || contextualType.Pattern.Kind == SyntaxKind.ObjectLiteralExpression);
            TypeFlags typeFlags = TypeFlags.None;

            var patternWithComputedProperties = false;

            foreach (var memberDecl in node.Properties)
            {
                var member = memberDecl.Symbol;

                if (memberDecl.Kind == SyntaxKind.PropertyAssignment ||
                    memberDecl.Kind == SyntaxKind.ShorthandPropertyAssignment ||
                    IsObjectLiteralMethod(memberDecl) != null)
                {
                    IType type = null;
                    if (memberDecl.Kind == SyntaxKind.PropertyAssignment)
                    {
                        type = CheckPropertyAssignment(memberDecl.Cast<IPropertyAssignment>(), contextualMapper);
                    }
                    else if (memberDecl.Kind == SyntaxKind.MethodDeclaration)
                    {
                        type = CheckObjectLiteralMethod(memberDecl.Cast<IMethodDeclaration>(), contextualMapper);
                    }
                    else
                    {
                        Contract.Assert(memberDecl.Kind == SyntaxKind.ShorthandPropertyAssignment);
                        type = CheckExpression(memberDecl.Cast<IShorthandPropertyAssignment>().Name, contextualMapper);
                    }

                    typeFlags |= type.Flags;

                    var flags = SymbolFlags.Property | SymbolFlags.Transient | member.Flags;

                    if (inDestructuringPattern)
                    {
                        // If object literal is an assignment pattern and if the assignment pattern specifies a default value
                        // for the property, make the property optional.
                        var isOptional =
                            (memberDecl.Kind == SyntaxKind.PropertyAssignment && HasDefaultValue(memberDecl.Cast<IPropertyAssignment>().Initializer)) ||
                            (memberDecl.Kind == SyntaxKind.ShorthandPropertyAssignment && memberDecl.Cast<IShorthandPropertyAssignment>().ObjectAssignmentInitializer != null);

                        if (isOptional)
                        {
                            flags |= SymbolFlags.Optional;
                        }

                        if (HasDynamicName(memberDecl))
                        {
                            patternWithComputedProperties = true;
                        }
                    }
                    else if (contextualTypeHasPattern &&
                            (contextualType.Flags & TypeFlags.ObjectLiteralPatternWithComputedProperties) == TypeFlags.None)
                    {
                        // If object literal is contextually typed by the implied type of a binding pattern, and if the
                        // binding pattern specifies a default value for the property, make the property optional.
                        var impliedProp = GetPropertyOfType(contextualType, member.Name);
                        if (impliedProp != null)
                        {
                            flags |= impliedProp.Flags & SymbolFlags.Optional;
                        }
                        else if (!m_compilerOptions.SuppressExcessPropertyErrors.HasValue || !m_compilerOptions.SuppressExcessPropertyErrors.Value)
                        {
                            Error(
                                memberDecl.Name,
                                Errors.Object_literal_may_only_specify_known_properties_and_0_does_not_exist_in_type_1,
                                SymbolToString(member),
                                TypeToString(contextualType));
                        }
                    }

                    var symbolData = new SymbolData
                    {
                        ReadOnlyDeclarations = member.DeclarationList.ToList(),
                        Parent = member.Parent,
                        ValueDeclaration = member.ValueDeclaration,
                        Type = type,
                        Target = member,
                    };
                    var prop = CreateTransientSymbol(
                        flags,
                        member.Name,
                        ref symbolData);

                    member = (ISymbol)prop;
                }
                else
                {
                    // TypeScript 1.0 spec (April 2014)
                    // A get accessor declaration is processed in the same manner as
                    // an ordinary function declaration(section 6.1) with no parameters.
                    // A set accessor declaration is processed in the same manner
                    // as an ordinary function declaration with a single parameter and a Void return type.
                    Contract.Assert(memberDecl.Kind == SyntaxKind.GetAccessor || memberDecl.Kind == SyntaxKind.SetAccessor);
                    CheckAccessorDeclaration(memberDecl.Cast<IAccessorDeclaration>());
                }

                if (!HasDynamicName(memberDecl))
                {
                    propertiesTable[member.Name] = member;
                }

                propertiesArray.Add(member);
            }

            // If object literal is contextually typed by the implied type of a binding pattern, augment the result
            // type with those properties for which the binding pattern specifies a default value.
            if (contextualTypeHasPattern)
            {
                foreach (var prop in GetPropertiesOfType(contextualType).AsStructEnumerable())
                {
                    if (!HasProperty(propertiesTable, prop.Name))
                    {
                        if ((prop.Flags & SymbolFlags.Optional) == SymbolFlags.None)
                        {
                            Error(
                                prop.ValueDeclaration ?? ((ITransientSymbol)prop).BindingElement,
                                Errors.Initializer_provides_no_value_for_this_binding_element_and_the_binding_element_has_no_default_value);
                        }

                        propertiesTable[prop.Name] = prop;
                        propertiesArray.Add(prop);
                    }
                }
            }

            IType GetIndexType(IObjectLiteralExpression literal, IndexKind kind)
            {
                if (contextualType != null && ContextualTypeHasIndexSignature(contextualType, kind))
                {
                    List<IType> propTypes = new List<IType>(propertiesArray.Count);

                    for (var i = 0; i < propertiesArray.Count; i++)
                    {
                        var propertyDecl = literal.Properties[i];

                        if (kind == IndexKind.String || IsNumericName(propertyDecl.Name))
                        {
                            // Do not call GetSymbolOfNode(propertyDecl), as that will get the
                            // original symbol for the node. We actually want to get the symbol
                            // created by checkObjectLiteral, since that will be appropriately
                            // contextually typed and resolved.
                            var type = GetTypeOfSymbol(propertiesArray[i]);
                            if (!propTypes.Contains(type))
                            {
                                propTypes.Add(type);
                            }
                        }
                    }

                    var r = propTypes.Count != 0 ? GetUnionType(propTypes) : m_undefinedType;
                    typeFlags |= r.Flags;

                    return r;
                }

                return null;
            }

            var stringIndexType = GetIndexType(node, IndexKind.String);
            var numberIndexType = GetIndexType(node, IndexKind.Number);

            var result = CreateAnonymousType(
                            node.Symbol,
                            propertiesTable,
                            s_emptySignatureEnumerable,
                            s_emptySignatureEnumerable,
                            stringIndexType,
                            numberIndexType);

            var freshObjectLiteralFlag = m_compilerOptions.SuppressExcessPropertyErrors.HasValue && m_compilerOptions.SuppressExcessPropertyErrors.Value ?
                                            TypeFlags.None :
                                            TypeFlags.FreshObjectLiteral;

            result.Flags |= TypeFlags.ObjectLiteral |
                            TypeFlags.ContainsObjectLiteral |
                            freshObjectLiteralFlag |
                            (typeFlags & TypeFlags.PropagatingFlags) |
                            (patternWithComputedProperties ? TypeFlags.ObjectLiteralPatternWithComputedProperties : TypeFlags.None);

            if (inDestructuringPattern)
            {
                result.Pattern = new DestructuringPattern(node);
            }

            return result;
        }

        // If a symbol is a synthesized symbol with no value declaration, we assume it is a property. Example of this are the synthesized
        // '.prototype' property as well as synthesized tuple index properties.
        private static SyntaxKind GetDeclarationKindFromSymbol(ISymbol s)
        {
            return s.ValueDeclaration?.Kind ?? SyntaxKind.PropertyDeclaration;
        }

        private static NodeFlags GetDeclarationFlagsFromSymbol(ISymbol s)
        {
            return s.ValueDeclaration != null ?
                GetCombinedNodeFlags(s.ValueDeclaration) :
                (s.Flags & SymbolFlags.Prototype) != SymbolFlags.None ?
                    NodeFlags.Public | NodeFlags.Static :
                    NodeFlags.None;
        }

        // TODO: Irrelevant for our purposes (so far).

        /// <summary>
        /// Check whether the requested property access is valid.
        /// </summary>
        /// <param name="node">The node to be checked.</param>
        /// <param name="left">The left hand side of the property access (e.g.: the super in `super.foo`).</param>
        /// <param name="type">The type of left.</param>
        /// <param name="prop">The symbol for the right hand side of the property access.</param>
        /// <returns>
        /// Returns true if node is a valid property access, and false otherwise.
        /// </returns>
        private static bool CheckClassPropertyAccess(
            /*HINT:PropertyAccessExpression | QualifiedName*/ INode node,
            /*HINT:Expression | QualifiedName*/ INode left,
            IType type,
            ISymbol prop)
        {
            throw PlaceHolder.NotImplemented();

            // var flags = getDeclarationFlagsFromSymbol(prop);
            // var declaringClass = GetDeclaredTypeOfSymbol.Cast<IInterfaceType>()(prop.Parent);

            // if (left.Kind == SyntaxKind.SuperKeyword)

            // {
            //    var errorNode = node.Kind == SyntaxKind.PropertyAccessExpression ?
            //        (node.Cast<IPropertyAccessExpression>()).Name :
            //        (node.Cast<IQualifiedName>()).right;

            // // TS 1.0 spec (April 2014): 4.8.2
            //    // - In a constructor, instance member function, instance member accessor, or
            //    //   instance member variable initializer where this references a derived class instance,
            //    //   a super property access is permitted and must specify a public instance member  of the base class.
            //    // - In a static member  or static member accessor
            //    //   where this references the constructor  object of a derived class,
            //    //   a super property access is permitted and must specify a public static member  of the base class.
            //    if (languageVersion < ScriptTarget.ES6 && getDeclarationKindFromSymbol(prop) != SyntaxKind.MethodDeclaration)
            //    {
            //        // `prop` refers to a *property* declared in the super class
            //        // rather than a *method*, so it does not satisfy the above criteria.

            // error(errorNode, Errors.Only_public_and_protected_methods_of_the_base_class_are_accessible_via_the_super_keyword);
            //        return false;
            //    }

            // if (((flags & NodeFlags.Abstract)) != 0)

            // {
            //        // A method cannot be accessed in a super property access if the method is abstract.
            //        // This error could mask a private property access error. But, a member
            //        // cannot simultaneously be private and abstract, so this will trigger an
            //        // additional error elsewhere.

            // error(errorNode, Errors.Abstract_method_0_in_class_1_cannot_be_accessed_via_super_expression, symbolToString(prop), typeToString(declaringClass));
            //        return false;
            //    }
            // }

            //// Public properties are otherwise accessible.
            // if (!(flags & (NodeFlags.Private | NodeFlags.Protected)))
            // {
            //    return true;
            // }

            //// Property is known to be private or protected at this point
            //// Get the declaring and enclosing class instance types
            // var enclosingClassDeclaration = getContainingClass(node);

            // var enclosingClass = enclosingClassDeclaration ? GetDeclaredTypeOfSymbol(GetSymbolOfNode(enclosingClassDeclaration).Cast<IInterfaceType>()) : null;

            //// Private property is accessible if declaring and enclosing class are the same
            // if (((flags & NodeFlags.Private)) != 0)
            // {
            //    if (declaringClass != enclosingClass)
            //    {
            //        error(node, Errors.Property_0_is_private_and_only_accessible_within_class_1, symbolToString(prop), typeToString(declaringClass));
            //        return false;
            //    }
            //    return true;
            // }

            //// Property is known to be protected at this point

            //// All protected properties of a supertype are accessible in a super access
            // if (left.Kind == SyntaxKind.SuperKeyword)
            // {
            //    return true;
            // }
            //// A protected property is accessible in the declaring class and classes derived from it
            // if (!enclosingClass || !hasBaseType(enclosingClass, declaringClass))
            // {
            //    error(node, Errors.Property_0_is_protected_and_only_accessible_within_class_1_and_its_subclasses, symbolToString(prop), typeToString(declaringClass));
            //    return false;
            // }
            //// No further restrictions for static properties
            // if (((flags & NodeFlags.Static)) != 0)
            // {
            //    return true;
            // }
            //// An instance property must be accessed through an instance of the enclosing class
            // if (type.Flags & TypeFlags.ThisType)
            // {
            //    // get the original type -- represented as the type varraint of the 'this' type
            //    type = getConstraintOfTypeParameter(type.Cast<ITypeParameter>());
            // }

            //// why/* TODO:is the first part of this check here?
            // if (!(getTargetType(type).flags & (TypeFlags.Class | TypeFlags.Interface) && hasBaseType(type.Cast<IInterfaceType>(), enclosingClass)))
            // {
            //    error(node, Errors.Property_0_is_protected_and_only_accessible_through_an_instance_of_class_1, symbolToString(prop), typeToString(enclosingClass));
            //    return false;
            // }
            // return true;
        }

        private IType CheckPropertyAccessExpression(IPropertyAccessExpression node)
        {
            return CheckPropertyAccessExpressionOrQualifiedName(node, node.Expression, node.Name);
        }

        private IType CheckQualifiedName(IQualifiedName node)
        {
            return CheckPropertyAccessExpressionOrQualifiedName(node, node.Left, node.Right);
        }

        /// <inheritdoc />
        public RoaringBitSet GetFileDependentsOf(ISourceFile sourceFile)
        {
            return sourceFile.FileDependents;
        }

        /// <inheritdoc />
        public RoaringBitSet GetFileDependenciesOf(ISourceFile sourceFile)
        {
            return sourceFile.FileDependencies;
        }

        /// <inheritdoc />
        public HashSet<string> GetModuleDependenciesOf(ISourceFile sourceFile)
        {
            return ((SourceFile)sourceFile).ModuleDependencies;
        }

        /// <inheritdoc />
        public bool IsPreludeDeclaration(IDeclaration declaration)
        {
            return m_host.IsPreludeFile(declaration.GetSourceFile());
        }

        private void RecordFile2FileRelationships(INode currentNode, ISymbol resolvedTargetSymbol, bool ignoreSourceFileOrNamespace = true)
        {
            // Can't track file-2-file dependencies if target symbol is null or doesn't have any declarations.
            if (!m_trackFileToFileDependencies || resolvedTargetSymbol == null || resolvedTargetSymbol.DeclarationList.Count == 0)
            {
                return;
            }

            // If the target declaration is the namespace then the current logic can be skipped.
            // Namespace could have a large amount of declarations because all of them are merged together.
            // Adding all of them to the dependency map will make the whole feature useless because every file will depends on every other file.
            // If a value from the namespace is used than we'll add an entry to the file-2-file map any way.
            //
            // Ast conversion is aware of this. If the workspace was filtered based on file-2-file dependencies, it is possible that all the namespace declarations are filtered out.
            // Here is an example:
            // file1.dsc
            // export namespace X { export const value = 42;}
            // file2.dsc
            // export const x = X;
            // If the user specifies the file2.dsc as filter, then the file1.dsc will be filtered out.
            // The namespace 'X' is referenced, but never used, so the 'x' will be undefined.
            var firstDeclaration = resolvedTargetSymbol.DeclarationList.FirstOrDefault();

            if (firstDeclaration == null)
            {
                return;
            }

            // Ignore files or namespaces only if the ignoreSourceFileOrNamespace is true.
            if (ignoreSourceFileOrNamespace && (IsFileOrNamespace(resolvedTargetSymbol) && !IsPreludeDeclaration(firstDeclaration)))
            {
                // There is one special case when the namespace member was used: something defined in prelude, like toString.
                // In this case we don't know what to do and will add all the declarations to the map.
                return;
            }

            foreach (var declaration in resolvedTargetSymbol.DeclarationList)
            {
                AddDependencyFor(currentNode, declaration);
            }
        }

        private static bool IsFileOrNamespace([NotNull]ISymbol symbol)
        {
            return (symbol.Flags & SymbolFlags.ValueModule) != SymbolFlags.None ||
                   (symbol.Flags & SymbolFlags.NamespaceModule) != SymbolFlags.None;
        }

        private static void AddDependencyFor(INode currentNode, IDeclaration declaration)
        {
            var targetSourceFile = (SourceFile)declaration.GetSourceFile();

            var currentSourceFile = (SourceFile)GetSourceFile(currentNode);

            // Files can be null in case of prelude.
            if (currentSourceFile == null || targetSourceFile == null)
            {
                return;
            }

            var currentFilePath = currentSourceFile.CurrentFileIndex;
            var targetFilePath = targetSourceFile.CurrentFileIndex;

            if (currentFilePath == targetFilePath)
            {
                return;
            }

            // Adding upstream and downstream dependencies.
            // We can skip the second step if the first one returns false (meaning that the relationship was already saved).
            if (currentSourceFile.AddFileDependency(targetFilePath))
            {
                targetSourceFile.AddDependentFile(currentFilePath);
            }
        }

        private IType CheckPropertyAccessExpressionOrQualifiedName(
            /*HINT:PropertyAccessExpression | QualifiedName*/ INode node,
            /*HINT:Expression | QualifiedName*/ INode left,
            IIdentifier right)
        {
            var type = CheckExpression(left);
            if (IsTypeAny(type))
            {
                return type;
            }

            var apparentType = GetApparentType(GetWidenedType(type));
            if (apparentType == m_unknownType)
            {
                // handle cases when type is Type parameter with invalid constraint
                return m_unknownType;
            }

            var prop = GetPropertyOfType(apparentType, right.Text);
            if (prop == null)
            {
                if (!string.IsNullOrEmpty(right.Text))
                {
                    // DScript-specific. If something like A.$ occurs we want to provide a more specific error message.
                    if (right.Text == Names.RootNamespace)
                    {
                        Error(
                            right,
                            Errors.The_root_namespace_can_only_be_referenced_as_0_Namespace_qualifications_are_not_allowed,
                            Names.RootNamespace);
                    }
                    else
                    {
                        Error(
                            right,
                            Errors.Property_0_does_not_exist_on_type_1,
                            DeclarationNameToString(right),
                            TypeToString((type.Flags & TypeFlags.ThisType) != TypeFlags.None ? apparentType : type));
                    }
                }

                return m_unknownType;
            }

            RecordFile2FileRelationships(node, prop);

            SetResolvedSymbol(node, prop);

            if (prop.Parent != null && (prop.Parent.Flags & SymbolFlags.Class) != SymbolFlags.None)
            {
                CheckClassPropertyAccess(node, left, apparentType, prop);
            }

            return GetTypeOfSymbol(prop);
        }

        /// <nodoc />
        public bool IsValidPropertyAccess(/*HINT: IPropertyAccessExpression | IQualifiedName*/ INode node, string propertyName)
        {
            var left = node.Kind == SyntaxKind.PropertyAccessExpression ?
                        node.Cast<IPropertyAccessExpression>().Expression :
                        node.Cast<IQualifiedName>().Left;

            var type = CheckExpression(left);

            if (type != m_unknownType && !IsTypeAny(type))
            {
                var prop = GetPropertyOfType(
                            GetWidenedType(type),
                            propertyName);

                if (prop != null && prop.Parent != null && (prop.Parent.Flags & SymbolFlags.Class) != SymbolFlags.None)
                {
                    return CheckClassPropertyAccess(node, left, type, prop);
                }
            }

            return true;
        }

        private IType CheckIndexedAccess(IElementAccessExpression node)
        {
            // Grammar checking
            if (node.ArgumentExpression == null)
            {
                var sourceFile = GetSourceFile(node);
                if (node.Parent.Kind == SyntaxKind.NewExpression &&
                    node.Parent.Cast<INewExpression>().Expression.ResolveUnionType() == node.ResolveUnionType())
                {
                    var start = SkipTrivia(sourceFile.Text, node.Expression.End);
                    var end = node.End;
                    GrammarErrorAtPos(
                        sourceFile,
                        start,
                        end - start,
                        Errors.New_T_cannot_be_used_to_create_an_array_Use_new_Array_T_instead);
                }
                else
                {
                    var start = node.End - "]".Length;
                    var end = node.End;
                    GrammarErrorAtPos(
                        sourceFile,
                        start,
                        end - start,
                        Errors.Expression_expected);
                }
            }

            // Obtain base constraint such that we can bail out if the constraint is an unknown type
            var objectType = GetApparentType(CheckExpression(node.Expression));
            var indexType = node.ArgumentExpression != null ? CheckExpression(node.ArgumentExpression) : m_unknownType;

            if (objectType == m_unknownType)
            {
                return m_unknownType;
            }

            var isConstEnum = IsConstEnumObjectType(objectType);
            if (isConstEnum &&
                (node.ArgumentExpression == null || node.ArgumentExpression.Kind != SyntaxKind.StringLiteral))
            {
                Error(
                    node.ArgumentExpression,
                    Errors.A_const_enum_member_can_only_be_accessed_using_a_string_literal);

                return m_unknownType;
            }

            // TypeScript 1.0 spec (April 2014): 4.10 Property Access
            // - If IndexExpr is a string literal or a numeric literal and ObjExpr's apparent type has a property with the name
            //    given by that literal(converted to its string representation in the case of a numeric literal), the property access is of the type of that property.
            // - Otherwise, if ObjExpr's apparent type has a numeric index signature and IndexExpr is of type Any, the Number primitive type, or an enum type,
            //    the property access is of the type of that index signature.
            // - Otherwise, if ObjExpr's apparent type has a string index signature and IndexExpr is of type Any, the String or Number primitive type, or an enum type,
            //    the property access is of the type of that index signature.
            // - Otherwise, if IndexExpr is of type Any, the String or Number primitive type, or an enum type, the property access is of type Any.

            // See if we can index as a property.
            if (node.ArgumentExpression != null)
            {
                var name = GetPropertyNameForIndexedAccess(node.ArgumentExpression, indexType);
                if (name != null)
                {
                    var prop = GetPropertyOfType(objectType, name);
                    if (prop != null)
                    {
                        SetResolvedSymbol(node, prop);
                        return GetTypeOfSymbol(prop);
                    }

                    if (isConstEnum)
                    {
                        Error(
                            node.ArgumentExpression,
                            Errors.Property_0_does_not_exist_on_const_enum_1,
                            name,
                            SymbolToString(objectType.Symbol));

                        return m_unknownType;
                    }
                }
            }

            // Check for compatible indexer types.
            if (IsTypeAnyOrAllConstituentTypesHaveKind(indexType, TypeFlags.StringLike | TypeFlags.NumberLike | TypeFlags.EsSymbol))
            {
                // Try to use a number indexer.
                if (IsTypeAnyOrAllConstituentTypesHaveKind(indexType, TypeFlags.NumberLike))
                {
                    var numberIndexType = GetIndexTypeOfType(objectType, IndexKind.Number);
                    if (numberIndexType != null)
                    {
                        return numberIndexType;
                    }
                }

                // Try to use string indexing.
                var stringIndexType = GetIndexTypeOfType(objectType, IndexKind.String);
                if (stringIndexType != null)
                {
                    return stringIndexType;
                }

                // Fall back to any.
                if (m_compilerOptions.NoImplicitAny.HasValue && m_compilerOptions.NoImplicitAny.Value &&
                    (!m_compilerOptions.SuppressImplicitAnyIndexErrors.HasValue || !m_compilerOptions.SuppressImplicitAnyIndexErrors.Value) &&
                    !IsTypeAny(objectType))
                {
                    Error(node, Errors.Index_signature_of_object_type_implicitly_has_an_any_type);
                }

                return m_anyType;
            }

            // REVIEW: Users should know the type that was actually used.
            Error(node, Errors.An_index_expression_argument_must_be_of_type_string_number_symbol_or_any);

            return m_unknownType;
        }

        /// <summary>
        /// If indexArgumentExpression is a string literal or number literal, returns its text.
        /// If indexArgumentExpression is a constant value, returns its string value.
        /// If indexArgumentExpression is a well known symbol, returns the property name corresponding
        ///    to this symbol, as long as it is a proper symbol reference.
        /// Otherwise, returns undefined.
        /// </summary>
        private string GetPropertyNameForIndexedAccess(IExpression indexArgumentExpression, IType indexArgumentType)
        {
            if (indexArgumentExpression.Kind == SyntaxKind.StringLiteral || indexArgumentExpression.Kind == SyntaxKind.NumericLiteral)
            {
                return indexArgumentExpression.Cast<ILiteralExpression>().Text;
            }

            if (indexArgumentExpression.Kind == SyntaxKind.ElementAccessExpression || indexArgumentExpression.Kind == SyntaxKind.PropertyAccessExpression)
            {
                var value = GetConstantValue(/*<ElementAccessExpression | PropertyAccessExpression>*/ indexArgumentExpression);
                if (value != null)
                {
                    return value.ToString();
                }
            }

            if (CheckThatExpressionIsProperSymbolReference(indexArgumentExpression, indexArgumentType, /*reportError*/ false))
            {
                var rightHandSideName = indexArgumentExpression.Cast<IPropertyAccessExpression>().Name.Text;
                return GetPropertyNameForKnownSymbolName(rightHandSideName);
            }

            return null;
        }

        /// <summary>
        /// A proper symbol reference requires the following:
        ///   1. The property access denotes a property that exists
        ///   2. The expression is of the form Symbol.&lt;identifier&gt;
        ///   3. The property access is of the primitive type symbol.
        ///   4. Symbol in this context resolves to the global Symbol object
        /// </summary>
        private bool CheckThatExpressionIsProperSymbolReference(IExpression expression, IType expressionType, bool reportError)
        {
            if (expressionType == m_unknownType)
            {
                // There is already an error, so no need to report one.
                return false;
            }

            if (!IsWellKnownSymbolSyntactically(expression))
            {
                return false;
            }

            // Make sure the property type is the primitive symbol type
            if ((expressionType.Flags & TypeFlags.EsSymbol) == TypeFlags.None)
            {
                if (reportError)
                {
                    Error(
                        expression,
                        Errors.A_computed_property_name_of_the_form_0_must_be_of_type_symbol,
                        GetTextOfNode(expression));
                }

                return false;
            }

            // The name is Symbol.<someName>, so make sure Symbol actually resolves to the
            // global Symbol object

            // HINT: The casts to IPropertyAccessExpression and IIdentifier are guaranteed to work by IsWellKnownSymbolSyntactically
            var leftHandSide = expression.Cast<IPropertyAccessExpression>().Expression.Cast<IIdentifier>();
            var leftHandSideSymbol = GetResolvedSymbol(leftHandSide);

            if (leftHandSideSymbol == null)
            {
                return false;
            }

            var globalEsSymbol = GetGlobalEsSymbolConstructorSymbol();
            if (globalEsSymbol == null)
            {
                // Already errored when we tried to look up the symbol
                return false;
            }

            if (leftHandSideSymbol != globalEsSymbol)
            {
                if (reportError)
                {
                    Error(
                        leftHandSide,
                        Errors.Symbol_reference_does_not_refer_to_the_global_Symbol_constructor_object);
                }

                return false;
            }

            return true;
        }

        private ISignature ResolveUntypedCall(/*HINT:CallLikeExpression*/ INode node)
        {
            if (node.Kind == SyntaxKind.TaggedTemplateExpression)
            {
                CheckExpression(node.Cast<ITaggedTemplateExpression>().TemplateExpression);
            }
            else if (node.Kind != SyntaxKind.Decorator)
            {
                // HINT: Cast is safe because CallLikeExpression = ICallExpression | INewExpression | ITaggedTemplateExpression | IDecorator
                //       so if node.Kind != Decorator, and node.Kind != TaggedTemplateExpression, then node must be
                //       either ICallExpression or INewExpression (which derives from ICallExpression).
                ForEach(node.Cast<ICallExpression>().Arguments, argument =>
                {
                    CheckExpression(argument);
                });
            }

            return m_anySignature;
        }

        private ISignature ResolveErrorCall(/*HINT:CallLikeExpression*/ INode node)
        {
            ResolveUntypedCall(node);
            return m_unknownSignature;
        }

        // Re-order candidate signatures into the result array. Assumes the result array to be empty.
        // The candidate list orders groups in reverse, but within a group signatures are kept in declaration order
        // A nit here is that we reorder only signatures that belong to the same symbol,
        // so order how inherited signatures are processed is still preserved.
        // interface A { (x: string): void }
        // interface B extends A { (x: 'foo'): string }
        // const b: B;
        // b('foo') // <- here overloads should be processed as [(x:'foo'): string, (x: string): void]
        private IReadOnlyList<ISignature> GetOrderedCandidates(IReadOnlyList<ISignature> signatures)
        {
            // Nothing to do if there is no signatures or just one.
            if (signatures.Count <= 1)
            {
                return signatures;
            }

            INode lastParent = null;
            ISymbol lastSymbol = null;
            int cutoffIndex = 0;
            int index = 0;
            var specializedIndex = -1;

            List<ISignature> result = new List<ISignature>();

            foreach (var signature in signatures.AsStructEnumerable())
            {
                var symbol = signature.Declaration != null ? GetSymbolOfNode(signature.Declaration) : null;
                var parent = signature.Declaration?.Parent;

                if (lastSymbol == null || symbol == lastSymbol)
                {
                    if (lastParent != null && parent.ResolveUnionType() == lastParent.ResolveUnionType())
                    {
                        index++;
                    }
                    else
                    {
                        lastParent = parent;
                        index = cutoffIndex;
                    }
                }
                else
                {
                    // current declaration belongs to a different symbol
                    // set cutoffIndex so re-orderings in the future won't change result set from 0 to cutoffIndex
                    index = cutoffIndex = result.Count;
                    lastParent = parent;
                }

                lastSymbol = symbol;

                // specialized signatures always need to be placed before non-specialized signatures regardless
                // of the cutoff position; see GH#1133
                var spliceIndex = 0;
                if (signature.HasStringLiterals)
                {
                    specializedIndex++;
                    spliceIndex = specializedIndex;

                    // The cutoff index always needs to be greater than or equal to the specialized signature index
                    // in order to prevent non-specialized signatures from being added before a specialized
                    // signature.
                    cutoffIndex++;
                }
                else
                {
                    spliceIndex = index;
                }

                result.Insert(spliceIndex, signature);
            }

            return result;
        }

        [System.Diagnostics.Contracts.Pure]
        private static int GetSpreadArgumentIndex(IReadOnlyList<IExpression> args)
        {
            for (var i = 0; i < args.Count; i++)
            {
                var arg = args[i];

                // TODO: why can arg be null??
                if (arg != null && arg.Kind == SyntaxKind.SpreadElementExpression)
                {
                    return i;
                }
            }

            return -1;
        }

        private static bool HasCorrectArity(/*HINT:CallLikeExpression*/ INode node, IReadOnlyList<IExpression> args, ISignature signature, ScriptTarget languageVersion)
        {
            int adjustedArgCount = 0;                   // Apparent number of arguments we will have in this call
            NodeArray<ITypeNode> typeArguments = null;  // Type arguments (undefined if none)
            bool callIsIncomplete = false;              // In incomplete call we want to be lenient when we have too few arguments
            var spreadArgIndex = -1;

            if (node.Kind == SyntaxKind.TaggedTemplateExpression)
            {
                var tagExpression = node.Cast<ITaggedTemplateExpression>();

                // Even if the call is incomplete, we'll have a missing expression as our last argument,
                // so we can say the count is just the arg list length
                adjustedArgCount = args.Count;
                typeArguments = null;

                if (tagExpression.TemplateExpression.Kind == SyntaxKind.TemplateExpression)
                {
                    // If a tagged template expression lacks a tail literal, the call is incomplete.
                    // Specifically, a template only can end in a TemplateTail or a Missing literal.
                    var templateExpression = tagExpression.TemplateExpression.Cast<ITemplateExpression>();
                    var lastSpan = templateExpression.TemplateSpans.LastOrDefault();

                    Contract.Assert(lastSpan != null); // we should always have at least one span.

                    callIsIncomplete = NodeIsMissing(lastSpan.Literal) || lastSpan.Literal.IsUnterminated;
                }
                else
                {
                    // If the template didn't end in a backtick, or its beginning occurred right prior to EOF,
                    // then this might actually turn out to be a TemplateHead in the future;
                    // so we consider the call to be incomplete.
                    var templateLiteral = tagExpression.TemplateExpression.Cast<ILiteralExpression>();

                    Contract.Assert(templateLiteral.Kind == SyntaxKind.NoSubstitutionTemplateLiteral);

                    callIsIncomplete = templateLiteral.IsUnterminated && templateLiteral.IsUnterminated;
                }
            }
            else if (node.Kind == SyntaxKind.Decorator)
            {
                typeArguments = null;

                var effectiveArgumentCount = GetEffectiveArgumentCount(
                    node,
                    args: null,
                    signature: signature,
                    langaugeVersion: languageVersion);

                if (effectiveArgumentCount.HasValue)
                {
                    adjustedArgCount = effectiveArgumentCount.Value;
                }

                // else TODO: Verify correctness - GetEffectiveArgumentCount can *technically* return undefined.
            }
            else
            {
                var callExpression = node.Cast<ICallExpression>();
                if (callExpression.Arguments == null)
                {
                    // This only happens when we have something of the form: 'new C'
                    Contract.Assert(callExpression.Kind == SyntaxKind.NewExpression);

                    return signature.MinArgumentCount == 0;
                }

                // For IDE scenarios we may have an incomplete call, so a trailing comma is tantamount to adding another argument.
                adjustedArgCount = callExpression.Arguments.HasTrailingComma ? args.Count + 1 : args.Count;

                // If we are missing the close paren, the call is incomplete.
                callIsIncomplete = callExpression.Arguments.End == callExpression.End;

                typeArguments = callExpression.TypeArguments;
                spreadArgIndex = GetSpreadArgumentIndex(args);
            }

            // If the user supplied type arguments, but the number of type arguments does not match
            // the declared number of type parameters, the call has an incorrect arity.
            var hasRightNumberOfTypeArgs = (typeArguments == null) ||
                                           (signature.TypeParameters != null && typeArguments.Length == signature.TypeParameters.Count);
            if (!hasRightNumberOfTypeArgs)
            {
                return false;
            }

            // If spread arguments are present, check that they correspond to a rest parameter. If so, no
            // further checking is necessary.
            if (spreadArgIndex >= 0)
            {
                return IsRestParameterIndex(signature, spreadArgIndex);
            }

            // Too many arguments implies incorrect arity.
            if (!signature.HasRestParameter && adjustedArgCount > signature.Parameters.Count)
            {
                return false;
            }

            // If the call is incomplete, we should skip the lower bound check.
            var hasEnoughArguments = adjustedArgCount >= signature.MinArgumentCount;

            return callIsIncomplete || hasEnoughArguments;
        }

        // If type has a single call signature and no other members, return that signature. Otherwise, return undefined.
        private ISignature GetSingleCallSignature(IType type)
        {
            if ((type.Flags & TypeFlags.ObjectType) != TypeFlags.None)
            {
                var resolved = ResolveStructuredTypeMembers(type);

                if (resolved.CallSignatures.Count == 1 &&
                    resolved.ConstructSignatures.Count == 0 &&
                    resolved.Properties.Count == 0 && resolved.StringIndexType == null && resolved.NumberIndexType == null)
                {
                    return resolved.CallSignatures[0];
                }
            }

            return null;
        }

        // Instantiate a generic signature in the context of a non-generic signature (section 3.8.5 in TypeScript spec)
        private ISignature InstantiateSignatureInContextOf(ISignature signature, ISignature contextualSignature, ITypeMapper contextualMapper)
        {
            var context = CreateInferenceContext(signature.TypeParameters, /*inferUnionTypes*/ true);

            ForEachMatchingParameterType(contextualSignature, signature, (checker: this, contextualMapper, context), (tuple, source, target) =>
            {
                var @this = tuple.checker;
                var capturedContextualMapper = tuple.contextualMapper;
                var capturedContext = tuple.context;

                // Type parameters from outer context referenced by source type are fixed by instantiation of the source type
                @this.InferTypes(
                    capturedContext,
                    @this.InstantiateType(source, capturedContextualMapper),
                    target);
            });

            return GetSignatureInstantiation(
                    signature,
                    GetInferredTypes(context));
        }

        private void InferTypeArguments(
            /*HINT:CallLikeExpression*/ INode node,
            ISignature signature,
            IReadOnlyList<IExpression> args,
            List<bool?> excludeArgument,
            IInferenceContext context)
        {
            var typeParameters = signature.TypeParameters;
            var inferenceMapper = GetInferenceMapper(context);

            // Clear out all the inference results from the last time inferTypeArguments was called on this context
            for (var i = 0; i < typeParameters.Count; i++)
            {
                // As an optimization, we don't have to clear (and later recompute) inferred types
                // for type parameters that have already been fixed on the previous call to inferTypeArguments.
                // It would be just as correct to reset all of them. But then we'd be repeating the same work
                // for the type parameters that were fixed, namely the work done by getInferredType.
                if (!context.Inferences[i].IsFixed)
                {
                    context.InferredTypes[i] = null;
                }
            }

            // On this call to inferTypeArguments, we may get more inferences for certain type parameters that were not
            // fixed last time. This means that a type parameter that failed inference last time may succeed this time,
            // or vice versa. Therefore, the failedTypeParameterIndex is useless if it points to an unfixed type parameter,
            // because it may change. So here we reset it. However, getInferredType will not revisit any type parameters
            // that were previously fixed. So if a fixed type parameter failed previously, it will fail again because
            // it will contain the exact same set of inferences. So if we reset the index from a fixed type parameter,
            // we will lose information that we won't recover this time around.
            if (context.FailedTypeParameterIndex.HasValue && !context.Inferences[context.FailedTypeParameterIndex.Value].IsFixed)
            {
                context.FailedTypeParameterIndex = Optional.Undefined<int>();
            }

            // We perform two passes over the arguments. In the first pass we infer from all arguments, but use
            // wildcards for all context sensitive function expressions.
            var argCount = GetEffectiveArgumentCount(node, args, signature, m_languageVersion);

            for (var i = 0; i < argCount; i++)
            {
                var arg = GetEffectiveArgument(node, args, i);

                // If the effective argument is 'undefined', then it is an argument that is present but is synthetic.
                if (arg == null || arg.Kind != SyntaxKind.OmittedExpression)
                {
                    var paramType = GetTypeAtPosition(signature, i);
                    var argType = GetEffectiveArgumentType(node, i, arg);

                    // If the effective argument type is 'undefined', there is no synthetic type
                    // for the argument. In that case, we should check the argument.
                    if (argType == null)
                    {
                        // For context sensitive arguments we pass the identityMapper, which is a signal to treat all
                        // context sensitive function expressions as wildcards
                        ITypeMapper mapper = excludeArgument?[i] != null ?
                                        s_identityMapper :
                                        inferenceMapper;

                        argType = CheckExpressionWithContextualType(arg, paramType, mapper);
                    }

                    InferTypes(context, argType, paramType);
                }
            }

            // In the second pass we visit only context sensitive arguments, and only those that aren't excluded, this
            // time treating function expressions normally (which may cause previously inferred type arguments to be fixed
            // as we construct types for contextually typed parameters)
            // Decorators will not have `excludeArgument`, as their arguments cannot be contextually typed.
            // Tagged template expressions will always have `undefined` for `excludeArgument[0]`.
            if (excludeArgument != null)
            {
                for (var i = 0; i < argCount; i++)
                {
                    // No need to check for omitted args and template expressions, their exclusion value is always null
                    if (excludeArgument[i] == false)
                    {
                        var arg = args[i];
                        var paramType = GetTypeAtPosition(signature, i);

                        InferTypes(
                            context,
                            CheckExpressionWithContextualType(arg, paramType, inferenceMapper),
                            paramType);
                    }
                }
            }

            GetInferredTypes(context);
        }

        private bool CheckTypeArguments(
            ISignature signature,
            NodeArray<ITypeNode> typeArgumentNodes,
            IReadOnlyList<IType> typeArgumentTypes,
            bool reportErrors,
            IDiagnosticMessage headMessage = null)
        {
            var typeParameters = signature.TypeParameters;
            var typeArgumentsAreAssignable = true;
            ITypeMapper mapper = null;

            for (var i = 0; i < typeParameters.Count; i++)
            {
                if (typeArgumentsAreAssignable /* so far */)
                {
                    var constraint = GetConstraintOfTypeParameter(typeParameters[i]);
                    if (constraint != null)
                    {
                        DiagnosticMessageChain errorInfo = null;
                        var typeArgumentHeadMessage = Errors.Type_0_does_not_satisfy_the_constraint_1;

                        if (reportErrors && headMessage != null)
                        {
                            errorInfo = ChainDiagnosticMessages(errorInfo, typeArgumentHeadMessage);
                            typeArgumentHeadMessage = headMessage;
                        }

                        if (mapper == null)
                        {
                            mapper = CreateTypeMapper(typeParameters, typeArgumentTypes);
                        }

                        var typeArgument = typeArgumentTypes[i];

                        typeArgumentsAreAssignable = CheckTypeAssignableTo(
                                                        typeArgument,
                                                        GetTypeWithThisArgument(
                                                            InstantiateType(constraint, mapper),
                                                            typeArgument),
                                                        reportErrors ? typeArgumentNodes[i] : null,
                                                        typeArgumentHeadMessage,
                                                        errorInfo);
                    }
                }
            }

            return typeArgumentsAreAssignable;
        }

        private bool CheckApplicableSignature(
            /*HINT:CallLikeExpression*/ INode node,
            IReadOnlyList<IExpression> args,
            ISignature signature,
            ConcurrentMap<RelationComparisonResult> relation,
            List<bool?> excludeArgument,
            bool reportErrors)
        {
            var argCount = GetEffectiveArgumentCount(node, args, signature, m_languageVersion);

            for (var i = 0; i < argCount; i++)
            {
                var arg = GetEffectiveArgument(node, args, i);

                // If the effective argument is 'undefined', then it is an argument that is present but is synthetic.
                if (arg == null || arg.Kind != SyntaxKind.OmittedExpression)
                {
                    // Check spread elements against rest type (from arity check we know spread argument corresponds to a rest parameter)
                    var paramType = GetTypeAtPosition(signature, i);
                    var argType = GetEffectiveArgumentType(node, i, arg);

                    // If the effective argument type is 'undefined', there is no synthetic type
                    // for the argument. In that case, we should check the argument.
                    if (argType == null)
                    {
                        argType = (arg.Kind == SyntaxKind.StringLiteral) && !reportErrors ?
                                    GetStringLiteralTypeForText(arg.Cast<IStringLiteral>().Text) :
                                    CheckExpressionWithContextualType(
                                        arg,
                                        paramType,
                                        excludeArgument != null && excludeArgument[i] == true ? s_identityMapper : null);
                    }

                    // Use argument expression as error location when reporting errors
                    var errorNode = reportErrors ?
                                        GetEffectiveArgumentErrorNode(node, i, arg) :
                                        null;

                    var headMessage = Errors.Argument_of_type_0_is_not_assignable_to_parameter_of_type_1;
                    if (!CheckTypeRelatedTo(argType, paramType, relation, errorNode, headMessage))
                    {
                        return false;
                    }
                }
            }

            return true;
        }

        /// <summary>
        /// Returns the effective arguments for an expression that works like a function invocation.
        /// </summary>
        /// <remarks>
        /// If 'node' is a CallExpression or a NewExpression, then its argument list is returned.
        /// If 'node' is a TaggedTemplateExpression, a new argument list is constructed from the substitution
        ///    expressions, where the first element of the list is `undefined`.
        /// If 'node' is a Decorator, the argument list will be `undefined`, and its arguments and types
        ///    will be supplied from calls to `getEffectiveArgumentCount` and `getEffectiveArgumentType`.
        /// </remarks>
        private static IReadOnlyList<IExpression> GetEffectiveCallArguments(/*HINT: CallLikeExpression*/ INode node, List<IExpression> args)
        {
            if (node.Kind == SyntaxKind.TaggedTemplateExpression)
            {
                var template = node.Cast<ITaggedTemplateExpression>().TemplateExpression;

                args.Add(null);
                if (template.Kind == SyntaxKind.TemplateExpression)
                {
                    foreach (var span in template.Cast<ITemplateExpression>().TemplateSpans.AsStructEnumerable())
                    {
                        args.Add(span.Expression);
                    }
                }

                return null;
            }

            if (node.Kind == SyntaxKind.Decorator)
            {
                // For a decorator, we return undefined as we will determine
                // the number and types of arguments for a decorator using
                // `getEffectiveArgumentCount` and `getEffectiveArgumentType` below.
                return null;
            }

            return node.Cast<ICallExpression>().Arguments?.Elements ?? EmptyArray<IExpression>();
        }

        /// <summary>
        /// Returns the effective argument count for a node that works like a function invocation.
        /// </summary>
        /// <remarks>
        /// If 'node' is a Decorator, the number of arguments is derived from the decoration
        ///    target and the signature:
        ///    If 'node.Target' is a class declaration or class expression, the effective argument
        ///       count is 1.
        ///    If 'node.Target' is a parameter declaration, the effective argument count is 3.
        ///    If 'node.Target' is a property declaration, the effective argument count is 2.
        ///    If 'node.Target' is a method or accessor declaration, the effective argument count
        ///       is 3, although it can be 2 if the signature only accepts two arguments, allowing
        ///       us to match a property decorator.
        /// Otherwise, the argument count is the length of the 'args' array.
        /// </remarks>
        private static int? GetEffectiveArgumentCount(/*HINT:CallLikeExpression*/ INode node, IReadOnlyList<IExpression> args, ISignature signature, ScriptTarget langaugeVersion)
        {
            if (node.Kind == SyntaxKind.Decorator)
            {
                switch (node.Parent.Kind)
                {
                    case SyntaxKind.ClassDeclaration:
                    case SyntaxKind.ClassExpression:
                    // DS: DScript allows "decorators" on interface members and on the import declarations
                    case SyntaxKind.InterfaceDeclaration:
                    case SyntaxKind.ImportDeclaration:
                    case SyntaxKind.ImportClause:
                    case SyntaxKind.FunctionDeclaration:
                    case SyntaxKind.TypeAliasDeclaration:
                    case SyntaxKind.VariableStatement:
                    case SyntaxKind.ModuleDeclaration:
                    case SyntaxKind.ExportDeclaration:
                        // DS: DScript allows "decorators" on interface members, import declarations, type declarations, and functions
                        return 1;

                    // DS: DScript allows ambient decorators on interface properties
                    case SyntaxKind.PropertySignature:
                        return 1;
                        
                    // DS: DScript allows ambient decorators on literal types
                    case SyntaxKind.StringLiteralType:
                        return 1;

                    // DS: DScript allows ambient decorators on enums
                    case SyntaxKind.EnumDeclaration:
                    case SyntaxKind.EnumMember:
                        return 1;

                    case SyntaxKind.PropertyDeclaration:
                        // A property declaration decorator will have two arguments (see
                        // `PropertyDecorator` in core.d.ts)
                        return 2;

                    case SyntaxKind.MethodDeclaration:
                    case SyntaxKind.GetAccessor:
                    case SyntaxKind.SetAccessor:
                        // A method or accessor declaration decorator will have two or three arguments (see
                        // `PropertyDecorator` and `MethodDecorator` in core.d.ts)

                        // If we are emitting decorators for ES3, we will only pass two arguments.
                        if (langaugeVersion == ScriptTarget.Es3)
                        {
                            return 2;
                        }

                        // If the method decorator signature only accepts a target and a key, we will only
                        // type check those arguments.
                        return signature.Parameters.Count >= 3 ? 3 : 2;

                    case SyntaxKind.Parameter:
                        // A parameter declaration decorator will have three arguments (see
                        // `ParameterDecorator` in core.d.ts)
                        return 3;
                }
            }
            else
            {
                return args.Count;
            }

            return null;
        }

        /// <summary>
        /// Returns the effective type of the first argument to a decorator.
        /// </summary>
        /// <remarks>
        /// If 'node' is a class declaration or class expression, the effective argument type
        ///    is the type of the static side of the class.
        /// If 'node' is a parameter declaration, the effective argument type is either the type
        ///    of the static or instance side of the class for the parameter's parent method,
        ///    depending on whether the method is declared static.
        ///    For a constructor, the type is always the type of the static side of the class.
        /// If 'node' is a property, method, or accessor declaration, the effective argument
        ///    type is the type of the static or instance side of the parent class for class
        ///    element, depending on whether the element is declared static.
        /// </remarks>
        private IType GetEffectiveDecoratorFirstArgumentType(INode node)
        {
            // The first argument to a decorator is its `target`.
            if (node.Kind == SyntaxKind.ClassDeclaration)
            {
                // For a class decorator, the `target` is the type of the class (e.g. the
                // "static" or "constructor" side of the class)
                var classSymbol = GetSymbolOfNode(node);
                return GetTypeOfSymbol(classSymbol);
            }

            if (node.Kind == SyntaxKind.Parameter)
            {
                // For a parameter decorator, the `target` is the parent type of the
                // parameter's containing method.
                node = node.Parent;
                if (node.Kind == SyntaxKind.Constructor)
                {
                    var classSymbol = GetSymbolOfNode(node);
                    return GetTypeOfSymbol(classSymbol);
                }
            }

            if (node.Kind == SyntaxKind.PropertyDeclaration ||
                node.Kind == SyntaxKind.MethodDeclaration ||
                node.Kind == SyntaxKind.GetAccessor ||
                node.Kind == SyntaxKind.SetAccessor)
            {
                // For a property or method decorator, the `target` is the
                // "static"-side type of the parent of the member if the member is
                // declared "static"; otherwise, it is the "instance"-side type of the
                // parent of the member.
                return GetParentTypeOfClassElement(node.Cast<IClassElement>());
            }

            // DS: DScript supports ambient decorators on interfaces and interface members
            if (node.Kind == SyntaxKind.PropertySignature || node.Kind == SyntaxKind.InterfaceDeclaration || node.Kind == SyntaxKind.ImportDeclaration ||
                node.Kind == SyntaxKind.EnumDeclaration || node.Kind == SyntaxKind.EnumMember || node.Kind == SyntaxKind.FunctionDeclaration ||
                node.Kind == SyntaxKind.TypeAliasDeclaration || node.Kind == SyntaxKind.ImportClause ||
                node.Kind == SyntaxKind.ModuleDeclaration)
            {
                var classSymbol = GetSymbolOfNode(node);
                return GetTypeOfSymbol(classSymbol);
            }

            if (node.Kind == SyntaxKind.VariableStatement)
            {
                var classSymbol = GetSymbolOfNode(node.Cast<IVariableStatement>().DeclarationList?.Declarations.FirstOrDefault());
                return GetTypeOfSymbol(classSymbol);
            }

            // DS: DScript supports ambient decorators on string literal types and export {xx}.
            if (node.Kind == SyntaxKind.StringLiteralType || node.Kind == SyntaxKind.ExportDeclaration)
            {
                // The actual type is not relevant here.
                return m_unknownType;
            }

            Contract.Assert(false, "Unsupported decorator target.");
            return m_unknownType;
        }

        /// <summary>
        /// Returns the effective type for the second argument to a decorator.
        /// </summary>
        /// <remarks>
        /// If 'node' is a parameter, its effective argument type is one of the following:
        ///    If 'node.Parent' is a constructor, the effective argument type is 'any', as we
        ///       will emit `undefined`.
        ///    If 'node.Parent' is a member with an identifier, numeric, or string literal name,
        ///       the effective argument type will be a string literal type for the member name.
        ///    If 'node.Parent' is a computed property name, the effective argument type will
        ///       either be a symbol type or the string type.
        /// If 'node' is a member with an identifier, numeric, or string literal name, the
        ///    effective argument type will be a string literal type for the member name.
        /// If 'node' is a computed property name, the effective argument type will either
        ///    be a symbol type or the string type.
        /// A class decorator does not have a second argument type.
        /// </remarks>
        private IType GetEffectiveDecoratorSecondArgumentType(INode node)
        {
            // The second argument to a decorator is its `propertyKey`
            if (node.Kind == SyntaxKind.ClassDeclaration)
            {
                Contract.Assert(false, "Class decorators should not have a second synthetic argument.");
                return m_unknownType;
            }

            if (node.Kind == SyntaxKind.Parameter)
            {
                node = node.Parent;
                if (node.Kind == SyntaxKind.Constructor)
                {
                    // For a constructor parameter decorator, the `propertyKey` will be `undefined`.
                    return m_anyType;
                }

                // For a non-constructor parameter decorator, the `propertyKey` will be either
                // a string or a symbol, based on the name of the parameter's containing method.
            }

            if (node.Kind == SyntaxKind.PropertyDeclaration ||
                node.Kind == SyntaxKind.MethodDeclaration ||
                node.Kind == SyntaxKind.GetAccessor ||
                node.Kind == SyntaxKind.SetAccessor)
            {
                // The `propertyKey` for a property or method decorator will be a
                // string literal type if the member name is an identifier, number, or string;
                // otherwise, if the member name is a computed property name it will
                // be either string or symbol.
                var element = node.Cast<IClassElement>();
                switch (element.Name.Kind)
                {
                    case SyntaxKind.Identifier:
                        return GetStringLiteralTypeForText(element.Name.Cast<IIdentifier>().Text);

                    case SyntaxKind.NumericLiteral:
                    case SyntaxKind.StringLiteral:
                        return GetStringLiteralTypeForText(element.Name.Cast<ILiteralExpression>().Text);

                    case SyntaxKind.ComputedPropertyName:
                        var nameType = CheckComputedPropertyName(element.Name.Cast<IComputedPropertyName>());
                        if (IsTypeOfKind(nameType, TypeFlags.EsSymbol))
                        {
                            return nameType;
                        }
                        else
                        {
                            return m_stringType;
                        }

                    default:
                        Contract.Assert(false, "Unsupported property name.");
                        return m_unknownType;
                }
            }

            Contract.Assert(false, "Unsupported decorator target.");
            return m_unknownType;
        }

        /// <summary>
        /// Returns the effective argument type for the third argument to a decorator.
        /// </summary>
        /// <remarks>
        /// If 'node' is a parameter, the effective argument type is the number type.
        /// If 'node' is a method or accessor, the effective argument type is a
        ///    `TypedPropertyDescriptor&lt;T&gt;` instantiated with the type of the member.
        /// Class and property decorators do not have a third effective argument.
        /// </remarks>
        private IType GetEffectiveDecoratorThirdArgumentType(INode node)
        {
            // The third argument to a decorator is either its `descriptor` for a method decorator
            // or its `parameterIndex` for a paramter decorator
            if (node.Kind == SyntaxKind.ClassDeclaration)
            {
                Contract.Assert(false, "Class decorators should not have a third synthetic argument.");
                return m_unknownType;
            }

            if (node.Kind == SyntaxKind.Parameter)
            {
                // The `parameterIndex` for a parameter decorator is always a number
                return m_numberType;
            }

            if (node.Kind == SyntaxKind.PropertyDeclaration)
            {
                Contract.Assert(false, "Property decorators should not have a third synthetic argument.");
                return m_unknownType;
            }

            if (node.Kind == SyntaxKind.MethodDeclaration ||
                node.Kind == SyntaxKind.GetAccessor ||
                node.Kind == SyntaxKind.SetAccessor)
            {
                // The `descriptor` for a method decorator will be a `TypedPropertyDescriptor<T>`
                // for the type of the member.
                var propertyType = GetTypeOfNode(node);
                return CreateTypedPropertyDescriptorType(propertyType);
            }

            Contract.Assert(false, "Unsupported decorator target.");
            return m_unknownType;
        }

        /// <summary>
        /// Returns the effective argument type for the provided argument to a decorator.
        /// </summary>
        private IType GetEffectiveDecoratorArgumentType(IDecorator node, int argIndex)
        {
            if (argIndex == 0)
            {
                return GetEffectiveDecoratorFirstArgumentType(node.Parent);
            }

            if (argIndex == 1)
            {
                return GetEffectiveDecoratorSecondArgumentType(node.Parent);
            }

            if (argIndex == 2)
            {
                return GetEffectiveDecoratorThirdArgumentType(node.Parent);
            }

            Contract.Assert(false, "Decorators should not have a fourth synthetic argument.");
            return m_unknownType;
        }

        /// <summary>
        /// Gets the effective argument type for an argument in a call expression.
        /// </summary>
        private IType GetEffectiveArgumentType(/*HINT:CallLikeExpression*/ INode node, int argIndex, IExpression arg)
        {
            // Decorators provide special arguments, a tagged template expression provides
            // a special first argument, and string literals get string literal types
            // unless we're reporting errors
            if (node.Kind == SyntaxKind.Decorator)
            {
                return GetEffectiveDecoratorArgumentType(node.Cast<IDecorator>(), argIndex);
            }

            if (argIndex == 0 && node.Kind == SyntaxKind.TaggedTemplateExpression)
            {
                return m_globalTemplateStringsArrayType;
            }

            // This is not a synthetic argument, so we return 'undefined'
            // to signal that the caller needs to check the argument.
            return null;
        }

        /// <summary>
        /// Gets the effective argument expression for an argument in a call expression.
        /// </summary>
        private static IExpression GetEffectiveArgument(/*HINT:CallLikeExpression*/ INode node, IReadOnlyList<IExpression> args, int argIndex)
        {
            // For a decorator or the first argument of a tagged template expression we return undefined.
            if ((node.Kind == SyntaxKind.Decorator) ||
                (argIndex == 0 && node.Kind == SyntaxKind.TaggedTemplateExpression))
            {
                return null;
            }

            return args[argIndex];
        }

        /// <summary>
        /// Gets the error node to use when reporting errors for an effective argument.
        /// </summary>
        private static IExpression GetEffectiveArgumentErrorNode(/*HINT:CallLikeExpression*/ INode node, int argIndex, IExpression arg)
        {
            if (node.Kind == SyntaxKind.Decorator)
            {
                // For a decorator, we use the expression of the decorator for error reporting.
                return node.Cast<IDecorator>().Expression;
            }

            if (argIndex == 0 && node.Kind == SyntaxKind.TaggedTemplateExpression)
            {
                // For a the first argument of a tagged template expression, we use the template of the tag for error reporting.
                return node.Cast<ITaggedTemplateExpression>().TemplateExpression;
            }

            return arg;
        }

        private void ReportResolveCallError(INode node, IDiagnosticMessage headMessage, IDiagnosticMessage message)
        {
            var errorInfo = ChainDiagnosticMessages(/*details*/null, /*message*/ message, /*params*/ null);

            if (headMessage != null)
            {
                errorInfo = ChainDiagnosticMessages(errorInfo, headMessage);
            }

            m_diagnostics.Add(Diagnostic.CreateDiagnosticForNodeFromMessageChain(node, errorInfo));
        }

        private ISignature ChooseOverload(
            INode n,
            IReadOnlyList<IExpression> args,
            NodeArray<ITypeNode> typeArguments,
            IReadOnlyList<ISignature> candidateList,
            ConcurrentMap<RelationComparisonResult> relation,
            List<bool?> excludeArgument,
            out ISignature candidateForArgumentError,
            out ISignature candidateForTypeArgumentError,
            out IInferenceContext resultOfFailedInference)
        {
            candidateForArgumentError = null;
            candidateForTypeArgumentError = null;
            resultOfFailedInference = null;
            foreach (var originalCandidate in candidateList.AsStructEnumerable())
            {
                if (!HasCorrectArity(n, args, originalCandidate, m_languageVersion))
                {
                    continue;
                }

                ISignature candidate = null;
                bool typeArgumentsAreValid = false;
                var inferenceContext = originalCandidate.TypeParameters != null
                    ? CreateInferenceContext(originalCandidate.TypeParameters, /*inferUnionTypes*/ false)
                    : null;

                while (true)
                {
                    candidate = originalCandidate;
                    if (candidate.TypeParameters != null)
                    {
                        List<IType> typeArgumentTypes = null;
                        if (typeArguments != null)
                        {
                            typeArgumentTypes = typeArguments.Elements.Map(this, (t, @this) => @this.GetTypeFromTypeNode(t));
                            typeArgumentsAreValid = CheckTypeArguments(
                                candidate,
                                typeArguments,
                                typeArgumentTypes,
                                /*reportErrors*/ false);
                        }
                        else
                        {
                            InferTypeArguments(
                                n,
                                candidate,
                                args,
                                excludeArgument,
                                inferenceContext);

                            typeArgumentsAreValid = !inferenceContext.FailedTypeParameterIndex.HasValue;
                            typeArgumentTypes = inferenceContext.InferredTypes;
                        }

                        if (!typeArgumentsAreValid)
                        {
                            break;
                        }

                        candidate = GetSignatureInstantiation(candidate, typeArgumentTypes);
                    }

                    if (!CheckApplicableSignature(
                        n,
                        args,
                        candidate,
                        relation,
                        excludeArgument,
                        /*reportErrors*/ false))
                    {
                        break;
                    }

                    var index = excludeArgument != null ? excludeArgument.IndexOf(true) : -1;
                    if (index < 0)
                    {
                        return candidate;
                    }

                    excludeArgument[index] = false;
                }

                // A post-mortem of this iteration of the loop. The signature was not applicable,
                // so we want to track it as a candidate for reporting an error. If the candidate
                // had no type parameters, or had no issues related to type arguments, we can
                // report an error based on the arguments. If there was an issue with type
                // arguments, then we can only report an error based on the type arguments.
                if (originalCandidate.TypeParameters != null)
                {
                    var instantiatedCandidate = candidate;
                    if (typeArgumentsAreValid)
                    {
                        candidateForArgumentError = instantiatedCandidate;
                    }
                    else
                    {
                        candidateForTypeArgumentError = originalCandidate;
                        if (typeArguments == null)
                        {
                            resultOfFailedInference = inferenceContext;
                        }
                    }
                }
                else
                {
                    Contract.Assert(originalCandidate == candidate);
                    candidateForArgumentError = originalCandidate;
                }
            }

            return null;
        }

        private ISignature ResolveCall(
            /*HINT:CallLikeExpression*/ INode node,
            IReadOnlyList<ISignature> signatures,
            IDiagnosticMessage headMessage = null)
        {
            var isTaggedTemplate = node.Kind == SyntaxKind.TaggedTemplateExpression;
            var isDecorator = node.Kind == SyntaxKind.Decorator;

            NodeArray<ITypeNode> typeArguments = null;

            if (!isTaggedTemplate && !isDecorator)
            {
                typeArguments = node.Cast<ICallExpression>().TypeArguments;

                // We already performed type checking on the type arguments on the class declaration itself.
                if (node.Cast<ICallExpression>().Expression.Kind != SyntaxKind.SuperKeyword)
                {
                    ForEach(typeArguments, this, (elem, @this) =>
                    {
                        @this.CheckSourceElement(elem);
                    });
                }
            }

            var candidates = GetOrderedCandidates(signatures);

            // reorderCandidates fills up the candidates array directly
            if (candidates.Count == 0)
            {
                ReportResolveCallError(node, headMessage, Errors.Supplied_parameters_do_not_match_any_signature_of_call_target);
                return ResolveErrorCall(node);
            }

            // Using pooled array to avoid transient allocations.
            using (var pooledList = ObjectPools.ExpressionListPool.GetInstance())
            {
                var callArgs = pooledList.Instance;
                var args = GetEffectiveCallArguments(node, callArgs);
                args = args ?? callArgs;

                // The following applies to any value of 'excludeArgument[i]':
                //    - true:      the argument at 'i' is susceptible to a one-time permanent contextual typing.
                //    - undefined: the argument at 'i' is *not* susceptible to permanent contextual typing.
                //    - false:     the argument at 'i' *was* and *has been* permanently contextually typed.
                //
                // The idea is that we will perform type argument inference & assignability checking once
                // without using the susceptible parameters that are functions, and once more for each of those
                // parameters, contextually typing each as we go along.
                //
                // For a tagged template, then the first argument be 'undefined' if necessary
                // because it represents a TemplateStringsArray.
                //
                // For a decorator, no arguments are susceptible to contextual typing due to the fact
                // decorators are applied to a declaration by the emitter, and not to an expression.

                // TODO: Verify correctness! - should this be List<bool> or List<bool?>
                List<bool?> excludeArgument = null;

                if (!isDecorator)
                {
                    // We do not need to call `getEffectiveArgumentCount` here as it only
                    // applies when calculating the number of arguments for a decorator.
                    for (var i = isTaggedTemplate ? 1 : 0; i < args.Count; i++)
                    {
                        if (IsContextSensitive(args[i]))
                        {
                            if (excludeArgument == null)
                            {
                                // TODO: consider moving to excludeArgument = Enumerable.Repeat(new bool?(), args.Count).ToList();
                                excludeArgument = new List<bool?>(new bool?[args.Count]);
                            }

                            excludeArgument[i] = true;
                        }
                    }
                }

                // The following variables are captured and modified by calls to chooseOverload.
                // If overload resolution or type argument inference fails, we want to report the
                // best error possible. The best error is one which says that an argument was not
                // assignable to a parameter. This implies that everything else about the overload
                // was fine. So if there is any overload that is only incorrect because of an
                // argument, we will report an error on that one.
                //
                //     function foo(s: string) {}
                //     function foo(n: number) {} // Report argument error on this overload
                //     function foo() {}
                //     foo(true);
                //
                // If none of the overloads even made it that far, there are two possibilities.
                // There was a problem with type arguments for some overload, in which case
                // report an error on that. Or none of the overloads even had correct arity,
                // in which case give an arity error.
                //
                //     function foo<T>(x: T, y: T) {} // Report type argument inference error
                //     function foo() {}
                //     foo(0, true);
                ISignature candidateForArgumentError = null;
                ISignature candidateForTypeArgumentError = null;
                IInferenceContext resultOfFailedInference = null;
                ISignature result = null;

                // Section 4.12.1:
                // if the candidate list contains one or more signatures for which the type of each argument
                // expression is a subtype of each corresponding parameter type, the return type of the first
                // of those signatures becomes the return type of the function call.
                // Otherwise, the return type of the first signature in the candidate list becomes the return
                // type of the function call.
                //
                // Whether the call is an error is determined by assignability of the arguments. The subtype pass
                // is just important for choosing the best signature. So in the case where there is only one
                // signature, the subtype pass is useless. So skipping it is an optimization.
                if (candidates.Count > 1)
                {
                    result = ChooseOverload(
                        node,
                        args,
                        typeArguments,
                        candidates,
                        m_subtypeRelation,
                        excludeArgument,
                        out candidateForArgumentError,
                        out candidateForTypeArgumentError,
                        out resultOfFailedInference);
                }

                if (result == null)
                {
                    result = ChooseOverload(
                        node,
                        args,
                        typeArguments,
                        candidates,
                        m_assignableRelation,
                        excludeArgument,
                        out candidateForArgumentError,
                        out candidateForTypeArgumentError,
                        out resultOfFailedInference);
                }

                if (result != null)
                {
                    return result;
                }

                // No signatures were applicable. Now report errors based on the last applicable signature with
                // no arguments excluded from assignability checks.
                // If candidate is undefined, it means that no candidates had a suitable arity. In that case,
                // skip the checkApplicableSignature check.
                if (candidateForArgumentError != null)
                {
                    // excludeArgument is undefined, in this case also equivalent to [undefined, undefined, ...]
                    // The importance of excludeArgument is to prevent us from typing function expression parameters
                    // in arguments too early. If possible, we'd like to only type them once we know the correct
                    // overload. However, this matters for the case where the call is correct. When the call is
                    // an error, we don't need to exclude any arguments, although it would cause no harm to do so.
                    CheckApplicableSignature(
                        node,
                        args,
                        candidateForArgumentError,
                        m_assignableRelation,
                        /*excludeArgument*/ null,
                        /*reportErrors*/ true);
                }
                else if (candidateForTypeArgumentError != null)
                {
                    if (!isTaggedTemplate && !isDecorator && typeArguments != null)
                    {
                        CheckTypeArguments(
                            candidateForTypeArgumentError,
                            node.Cast<ICallExpression>().TypeArguments,
                            node.Cast<ICallExpression>().TypeArguments.Elements.Map(this, (t, @this) => @this.GetTypeFromTypeNode(t)),
                            /*reportErrors*/ true,
                            headMessage);
                    }
                    else
                    {
                        Contract.Assert(resultOfFailedInference.FailedTypeParameterIndex >= 0);

                        var failedTypeParameter = candidateForTypeArgumentError.TypeParameters[resultOfFailedInference.FailedTypeParameterIndex];
                        var inferenceCandidates = GetInferenceCandidates(
                            resultOfFailedInference,
                            resultOfFailedInference.FailedTypeParameterIndex);

                        var diagnosticChainHead = ChainDiagnosticMessages(
                            /*details*/ null,
                            Errors.The_type_argument_for_type_parameter_0_cannot_be_inferred_from_the_usage_Consider_specifying_the_type_arguments_explicitly,
                            TypeToString(failedTypeParameter));

                        if (headMessage != null)
                        {
                            diagnosticChainHead = ChainDiagnosticMessages(diagnosticChainHead, headMessage);
                        }

                        ReportNoCommonSupertypeError(
                            inferenceCandidates,
                            node.As<ICallExpression>()?.Expression ?? node.As<ITaggedTemplateExpression>()?.Tag,
                            diagnosticChainHead);
                    }
                }
                else
                {
                    ReportResolveCallError(node, headMessage, Errors.Supplied_parameters_do_not_match_any_signature_of_call_target);
                }

                // No signature was applicable. We have already reported the errors for the invalid signature.
                // If this is a type resolution session, e.g. Language Service, try to get better information that anySignature.
                // Pick the first candidate that matches the arity. This way we can get a contextual type for cases like:
                //  declare function f(a: { xa: number; xb: number; });
                //  f({ |
                // DScript extension: the same logic is applied for the interactive mode.
                if (!m_produceDiagnostics || m_interactiveMode)
                {
                    foreach (var candidate in candidates.AsStructEnumerable())
                    {
                        if (HasCorrectArity(node, args, candidate, m_languageVersion))
                        {
                            result = candidate;
                            if (candidate.TypeParameters != null && typeArguments != null)
                            {
                                result = GetSignatureInstantiation(
                                    candidate,
                                    typeArguments.Elements.Map(this, (t, @this) => @this.GetTypeFromTypeNode(t)));
                            }

                            return result;
                        }
                    }
                }
            }

            return ResolveErrorCall(node);
        }

        private ISignature ResolveCallExpression(ICallExpression node)
        {
            if (node.Expression.Kind == SyntaxKind.SuperKeyword)
            {
                var superType = CheckSuperExpression(node.Expression);
                if (superType != m_unknownType)
                {
                    // In super call, the candidate signatures are the matching arity signatures of the base constructor function instantiated
                    // with the type arguments specified in the extends clause.
                    var baseTypeNode = GetClassExtendsHeritageClauseElement(GetContainingClass(node));
                    var baseConstructors = GetInstantiatedConstructorsForTypeArguments(superType, baseTypeNode.TypeArguments);

                    return ResolveCall(node, baseConstructors);
                }

                return ResolveUntypedCall(node);
            }

            var funcType = CheckExpression(node.Expression);
            var apparentType = GetApparentType(funcType);

            if (apparentType == m_unknownType)
            {
                // Another error has already been reported
                return ResolveErrorCall(node);
            }

            // Technically, this signatures list may be incomplete. We are taking the apparent type,
            // but we are not including call signatures that may have been added to the Object or
            // Function interface, since they have none by default. This is a bit of a leap of faith
            // that the user will not add any.
            var callSignatures = GetSignaturesOfType(apparentType, SignatureKind.Call);
            var constructSignatures = GetSignaturesOfType(apparentType, SignatureKind.Construct);

            // TS 1.0 spec: 4.12
            // If FuncExpr is of type Any, or of an object type that has no call or construct signatures
            // but is a subtype of the Function interface, the call is an untyped function call. In an
            // untyped function call no TypeArgs are permitted, Args can be any argument list, no contextual
            // types are provided for the argument expressions, and the result is always of type Any.
            // We exclude union types because we may have a union of function types that happen to have
            // no common signatures.
            if (IsTypeAny(funcType) ||
                (callSignatures.Count == 0 && constructSignatures.Count == 0 &&
                 (funcType.Flags & TypeFlags.Union) == TypeFlags.None &&
                 IsTypeAssignableTo(funcType, m_globalFunctionType)))
            {
                // The m_unknownType indicates that an error already occurred (and was reported).  No
                // need to report another error in this case.
                if (funcType != m_unknownType && node.TypeArguments != null)
                {
                    Error(node, Errors.Untyped_function_calls_may_not_accept_type_arguments);
                }

                return ResolveUntypedCall(node);
            }

            // If FuncExpr's apparent type(section 3.8.1) is a function type, the call is a typed function call.
            // TypeScript employs overload resolution in typed function calls in order to support functions
            // with multiple call signatures.
            if (callSignatures.Count == 0)
            {
                if (constructSignatures.Count != 0)
                {
                    Error(
                        node,
                        Errors.Value_of_type_0_is_not_callable_Did_you_mean_to_include_new,
                        TypeToString(funcType));
                }
                else
                {
                    Error(node, Errors.Cannot_invoke_an_expression_whose_type_lacks_a_call_signature);
                }

                return ResolveErrorCall(node);
            }

            return ResolveCall(node, callSignatures);
        }

        private ISignature ResolveNewExpression(INewExpression node)
        {
            if (node.Arguments != null && m_languageVersion < ScriptTarget.Es5)
            {
                var spreadIndex = GetSpreadArgumentIndex(node.Arguments.Elements);
                if (spreadIndex >= 0)
                {
                    Error(
                        node.Arguments[spreadIndex],
                        Errors.Spread_operator_in_new_expressions_is_only_available_when_targeting_ECMAScript_5_and_higher);
                }
            }

            var expressionType = CheckExpression(node.Expression);

            // If expressionType's apparent type(section 3.8.1) is an object type with one or
            // more construct signatures, the expression is processed in the same manner as a
            // function call, but using the construct signatures as the initial set of candidate
            // signatures for overload resolution. The result type of the function call becomes
            // the result type of the operation.
            expressionType = GetApparentType(expressionType);
            if (expressionType == m_unknownType)
            {
                // Another error has already been reported
                return ResolveErrorCall(node);
            }

            // If the expression is a class of abstract type, then it cannot be instantiated.
            // Note, only class declarations can be declared abstract.
            // In the case of a merged class-module or class-interface declaration,
            // only the class declaration node will have the Abstract flag set.
            IDeclaration valueDecl = expressionType.Symbol != null ?
                                        GetClassLikeDeclarationOfSymbol(expressionType.Symbol) :
                                        null;

            if (valueDecl != null && (valueDecl.Flags & NodeFlags.Abstract) != NodeFlags.None)
            {
                Error(
                    node,
                    Errors.Cannot_create_an_instance_of_the_abstract_class_0,
                    DeclarationNameToString(valueDecl.Name));

                return ResolveErrorCall(node);
            }

            // TS 1.0 4 spec.11
            // If expressionType is of type Any, Args can be any argument
            // list and the result of the operation is of type Any.
            if (IsTypeAny(expressionType))
            {
                if (node.TypeArguments != null)
                {
                    Error(node, Errors.Untyped_function_calls_may_not_accept_type_arguments);
                }

                return ResolveUntypedCall(node);
            }

            // Technically, this signatures list may be incomplete. We are taking the apparent type,
            // but we are not including construct signatures that may have been added to the Object or
            // Function interface, since they have none by default. This is a bit of a leap of faith
            // that the user will not add any.
            var constructSignatures = GetSignaturesOfType(expressionType, SignatureKind.Construct);
            if (constructSignatures.Count != 0)
            {
                return ResolveCall(node, constructSignatures);
            }

            // If expressionType's apparent type is an object type with no construct signatures but
            // one or more call signatures, the expression is processed as a function call. A compile-time
            // error occurs if the result of the function call is not Void. The type of the result of the
            // operation is Any.
            var callSignatures = GetSignaturesOfType(expressionType, SignatureKind.Call);
            if (callSignatures.Count != 0)
            {
                var signature = ResolveCall(node, callSignatures);

                if (GetReturnTypeOfSignature(signature) != m_voidType)
                {
                    Error(node, Errors.Only_a_void_function_can_be_called_with_the_new_keyword);
                }

                return signature;
            }

            Error(node, Errors.Cannot_use_new_with_an_expression_whose_type_lacks_a_call_or_construct_signature);

            return ResolveErrorCall(node);
        }

        private ISignature ResolveTaggedTemplateExpression(ITaggedTemplateExpression node)
        {
            // Use additional cache for template expressions
            if (NodeExtensions.IsWellKnownTemplateExpression(node, out var name))
            {
                return ResolveWellKnownTemplateExpression(node, name);
            }

            return DoResolveTaggedTemplateExpression(node);
        }

        private ISignature DoResolveTaggedTemplateExpression(ITaggedTemplateExpression node)
        {
            var tagType = CheckExpression(node.Tag);
            var apparentType = GetApparentType(tagType);

            if (apparentType == m_unknownType)
            {
                // Another error has already been reported
                return ResolveErrorCall(node);
            }

            var callSignatures = GetSignaturesOfType(apparentType, SignatureKind.Call);

            if (IsTypeAny(tagType) ||
                (callSignatures.Count == 0 &&
                 (tagType.Flags & TypeFlags.Union) == TypeFlags.None &&
                 IsTypeAssignableTo(tagType, m_globalFunctionType)))
            {
                return ResolveUntypedCall(node);
            }

            if (callSignatures.Count == 0)
            {
                Error(node, Errors.Cannot_invoke_an_expression_whose_type_lacks_a_call_signature);

                return ResolveErrorCall(node);
            }

            return ResolveCall(node, callSignatures);
        }

        private ISignature ResolveWellKnownTemplateExpression(ITaggedTemplateExpression node, string name)
        {
            if (m_taggedSignatures.TryGetValue(name, out var result))
            {
                return result;
            }

            lock (m_taggedSignatures)
            {
                if (m_taggedSignatures.TryGetValue(name, out result))
                {
                    return result;
                }

                result = DoResolveTaggedTemplateExpression(node);
                m_taggedSignatures.TryAdd(name, result);
                return result;
            }
        }

        /// <summary>
        /// Gets the localized diagnostic head message to use for errors when resolving a decorator as a call expression.
        /// </summary>
        private static IDiagnosticMessage GetDiagnosticHeadMessageForDecoratorResolution(IDecorator node)
        {
            switch (node.Parent.Kind)
            {
                case SyntaxKind.ClassDeclaration:
                case SyntaxKind.ClassExpression:
                    return Errors.Unable_to_resolve_signature_of_class_decorator_when_called_as_an_expression;

                case SyntaxKind.Parameter:
                    return Errors.Unable_to_resolve_signature_of_parameter_decorator_when_called_as_an_expression;

                case SyntaxKind.PropertyDeclaration:
                    return Errors.Unable_to_resolve_signature_of_property_decorator_when_called_as_an_expression;

                case SyntaxKind.MethodDeclaration:
                case SyntaxKind.GetAccessor:
                case SyntaxKind.SetAccessor:
                    return Errors.Unable_to_resolve_signature_of_method_decorator_when_called_as_an_expression;
            }

            return Errors.Unable_to_resolve_signature_of_ambient_decorator_when_called_as_an_expression;
        }

        /// <summary>
        /// Resolves a decorator as if it were a call expression.
        /// </summary>
        private ISignature ResolveDecorator(IDecorator node)
        {
            var funcType = CheckExpression(node.Expression);
            var apparentType = GetApparentType(funcType);

            if (apparentType == m_unknownType)
            {
                return ResolveErrorCall(node);
            }

            var callSignatures = GetSignaturesOfType(apparentType, SignatureKind.Call);
            if (funcType == m_anyType ||
                (callSignatures.Count == 0 &&
                 (funcType.Flags & TypeFlags.Union) == TypeFlags.None &&
                 IsTypeAssignableTo(funcType, m_globalFunctionType)))
            {
                return ResolveUntypedCall(node);
            }

            var headMessage = GetDiagnosticHeadMessageForDecoratorResolution(node);

            if (callSignatures.Count == 0)
            {
                DiagnosticMessageChain errorInfo = null;
                errorInfo = ChainDiagnosticMessages(
                                errorInfo,
                                Errors.Cannot_invoke_an_expression_whose_type_lacks_a_call_signature);

                errorInfo = ChainDiagnosticMessages(errorInfo, headMessage);

                m_diagnostics.Add(Diagnostic.CreateDiagnosticForNodeFromMessageChain(node, errorInfo));

                return ResolveErrorCall(node);
            }

            return ResolveCall(
                    node,
                    callSignatures,
                    headMessage: headMessage);
        }

        /// <inheritdoc/>
        [NotNull]
        public ISignature GetResolvedSignature([NotNull]/*HINT: CallLikeExpression*/INode nodeArg)
        {
            Contract.Ensures(Contract.Result<ISignature>() != null);

            // To avoid StackOverflow, need to keep auxiliary thread-local data structure
            // that keeps information about node under resolution.
            if (m_resolvedSignatureSet.Value.Contains(nodeArg))
            {
                return m_anySignature;
            }

            return GetNodeLinks(nodeArg)
                .GetOrSetResolvedSignature(
                 (checker: this, nodeArg),
                (links, tuple) =>
                {
                    var @this = tuple.checker;
                    var node = tuple.nodeArg;

                    // Need to change change a signature to avoid stack overflow.
                    @this.m_resolvedSignatureSet.Value.Add(node);
                    try
                    {
                        // If getResolvedSignature has already been called, we will have cached the resolvedSignature.
                        // However, it is possible that either candidatesOutArray was not passed in the first time,
                        // or that a different candidatesOutArray was passed in. Therefore, we need to redo the work
                        // to correctly fill the candidatesOutArray.
                        if (node.Kind == SyntaxKind.CallExpression)
                        {
                            return @this.ResolveCallExpression(node.Cast<ICallExpression>());
                        }
                        if (node.Kind == SyntaxKind.NewExpression)
                        {
                            return @this.ResolveNewExpression(node.Cast<INewExpression>());
                        }
                        if (node.Kind == SyntaxKind.TaggedTemplateExpression)
                        {
                            return @this.ResolveTaggedTemplateExpression(node.Cast<ITaggedTemplateExpression>());
                        }
                        if (node.Kind == SyntaxKind.Decorator)
                        {
                            return @this.ResolveDecorator(node.Cast<IDecorator>());
                        }

                        Contract.Assert(false, "Branch in 'getResolvedSignature' should be unreachable.");
                        return @this.m_anySignature;
                    }
                    finally
                    {
                        @this.m_resolvedSignatureSet.Value.Remove(node);
                    }
                });
        }

        private IType GetInferredClassType(ISymbol symbolArg)
        {
            return GetSymbolLinks(symbolArg).GetOrSetInferredClassType(
                 (checker: this, symbolArg),
                (links, tuple) =>
                {
                    var @this = tuple.checker;
                    var symbol = tuple.symbolArg;
                    return CreateAnonymousType(
                        null,
                        symbol.Members,
                        s_emptySignatureEnumerable,
                        s_emptySignatureEnumerable,
                        /*stringIndexType*/ null,
                        /*intIndexType*/ null);
                });
        }

        /// <summary>
        /// Syntactically and semantically checks a call or new expression.
        /// </summary>
        /// <param name="node">The call/new expression to be checked.</param>
        /// <returns>
        /// On success, the expression's signature's return type. On failure, anyType.
        /// </returns>
        private IType CheckCallExpression(ICallExpression node)
        {
            // Grammar checking; stop grammar-checking if checkGrammarTypeArguments return true
            if (!CheckGrammarTypeArguments(node, node.TypeArguments))
            {
                CheckGrammarArguments(node, node.Arguments);
            }

            var signature = GetResolvedSignature(node);

            if (node.Expression.Kind == SyntaxKind.SuperKeyword)
            {
                return m_voidType;
            }

            if (node.Kind == SyntaxKind.NewExpression)
            {
                var declaration = signature.Declaration;

                if (declaration != null &&
                    declaration.Kind != SyntaxKind.Constructor &&
                    declaration.Kind != SyntaxKind.ConstructSignature &&
                    declaration.Kind != SyntaxKind.ConstructorType)
                {
                    // When resolved signature is a call signature (and not a construct signature) the result type is any, unless
                    // the declaring function had members created through 'x.prototype.y = expr' or 'this.y = expr' psuedodeclarations
                    // in a JS file
                    var funcSymbol = CheckExpression(node.Expression).Symbol;

                    if (funcSymbol?.Members != null &&
                        (funcSymbol.Flags & SymbolFlags.Function) != SymbolFlags.None)
                    {
                        return GetInferredClassType(funcSymbol);
                    }
                    else if (m_compilerOptions.NoImplicitAny.HasValue && m_compilerOptions.NoImplicitAny.Value)
                    {
                        Error(
                            node,
                            Errors.New_expression_whose_target_lacks_a_construct_signature_implicitly_has_an_any_type);
                    }

                    return m_anyType;
                }
            }

            if (DScriptImportUtilities.IsImportFrom(node, /*checkArgumentIsStringLIteral*/true))
            {
                return ResolveModuleByLiteral(node.Arguments[0].Cast<IStringLiteral>());
            }

            // In JavaScript files, calls to any identifier 'require' are treated as external module imports
            if (node.IsJavaScriptFile() && IsRequireCall(node) != null)
            {
                return ResolveExternalModuleTypeByLiteral(node.Arguments[0].Cast<IStringLiteral>());
            }

            return GetReturnTypeOfSignature(signature);
        }

        private IType CheckTaggedTemplateExpression(ITaggedTemplateExpression node)
        {
            // Use additional cache for template expressions
            if (NodeExtensions.IsWellKnownTemplateExpression(node, out var name))
            {
                return ResolveWellKnownTemplateType(node, name);
            }

            return DoCheckTaggedTemplateExpression(node);
        }

        private IType ResolveWellKnownTemplateType(ITaggedTemplateExpression node, string name)
        {
            if (m_taggedTypes.TryGetValue(name, out var result))
            {
                // Even when the type resolution is cached, we still need to check template expression
                // to validate that it is correct.
                var template = node.TemplateExpression.As<ITemplateExpression>();
                if (template != null)
                {
                    CheckExpression(template);
                }

                return result;
            }

            lock (m_taggedTypes)
            {
                if (m_taggedTypes.TryGetValue(name, out result))
                {
                    return result;
                }

                result = DoCheckTaggedTemplateExpression(node);
                m_taggedTypes.TryAdd(name, result);
                return result;
            }
        }

        private IType DoCheckTaggedTemplateExpression(ITaggedTemplateExpression node)
        {
            return GetReturnTypeOfSignature(GetResolvedSignature(node));
        }

        private IType CheckAssertion(/*HINT:AssertionExpression*/ IExpression node)
        {
            var exprType = GetRegularTypeOfObjectLiteral(
                            CheckExpression(node.Kind == SyntaxKind.TypeAssertionExpression ?
                                node.Cast<ITypeAssertion>().Expression :
                                node.Cast<IAsExpression>().Expression));

            var targetType = GetTypeFromTypeNode(node.Kind == SyntaxKind.TypeAssertionExpression ?
                                node.Cast<ITypeAssertion>().Type :
                                node.Cast<IAsExpression>().Type);

            if (m_produceDiagnostics && targetType != m_unknownType)
            {
                var widenedType = GetWidenedType(exprType);

                if (!IsTypeComparableTo(targetType, widenedType))
                {
                    CheckTypeComparableTo(exprType, targetType, node, Errors.Neither_type_0_nor_type_1_is_assignable_to_the_other);
                }
            }

            return targetType;
        }

        private IType GetTypeAtPosition(ISignature signature, int pos)
        {
            // TODO: This is ugly - simply using if-else
            return signature.HasRestParameter ?
                    pos < signature.Parameters.Count - 1 ?
                        GetTypeOfSymbol(signature.Parameters[pos]) :
                        GetRestTypeOfSignature(signature) :
                    pos < signature.Parameters.Count ?
                        GetTypeOfSymbol(signature.Parameters[pos]) :
                        m_anyType;
        }

        private void AssignContextualParameterTypes(ISignature signature, ISignature context, ITypeMapper mapper)
        {
            var len = signature.Parameters.Count - (signature.HasRestParameter ? 1 : 0);

            for (var i = 0; i < len; i++)
            {
                var parameter = signature.Parameters[i];
                var contextualParameterType = GetTypeAtPosition(context, i);

                AssignTypeToParameterAndFixTypeParameters(
                    parameter,
                    contextualParameterType,
                    mapper);
            }

            if (signature.HasRestParameter &&
                IsRestParameterIndex(context, signature.Parameters.Count - 1))
            {
                var parameter = signature.Parameters.LastOrUndefined();
                var contextualParameterType = GetTypeOfSymbol(context.Parameters.LastOrUndefined());

                AssignTypeToParameterAndFixTypeParameters(
                    parameter,
                    contextualParameterType,
                    mapper);
            }
        }

        // When contextual typing assigns a type to a parameter that contains a binding pattern, we also need to push
        // the destructured type into the contained binding elements.
        private void AssignBindingElementTypes(/*HINT:IVariableLikeDeclaration*/ IDeclaration node)
        {
            if (IsBindingPattern(node.Name) != null)
            {
                foreach (var element in node.Name.Cast<IBindingPattern>().Elements)
                {
                    if (element.Kind != SyntaxKind.OmittedExpression)
                    {
                        if (element.Name.Kind == SyntaxKind.Identifier)
                        {
                            GetSymbolLinks(GetSymbolOfNode(element)).Type = GetTypeForBindingElement(element);
                        }

                        AssignBindingElementTypes(element);
                    }
                }
            }
        }

        private void AssignTypeToParameterAndFixTypeParameters(ISymbol parameterArg, IType contextualTypeArg, ITypeMapper mapperArg)
        {
            var type = GetSymbolLinks(parameterArg).GetOrSetType(
                 (checker: this, parameterArg, contextualTypeArg, mapperArg),
                (links, tuple) =>
                {
                    var @this = tuple.checker;
                    var parameter = tuple.parameterArg;
                    var contextualType = tuple.contextualTypeArg;
                    var mapper = tuple.mapperArg;

                    // This check is left as is and should not cause issues when more than one type is resolved concurrently.
                    @this.AssignBindingElementTypes(
                        parameter.ValueDeclaration.Cast<IParameterDeclaration>());

                    return @this.InstantiateType(contextualType, mapper);
                });

            if (IsInferentialContext(mapperArg) != null)
            {
                // Even if the parameter already has a type, it might be because it was given a type while
                // processing the function as an argument to a prior signature during overload resolution.
                // If this was the case, it may have caused some type parameters to be fixed. So here,
                // we need to ensure that type parameters at the same positions get fixed again. This is
                // done by calling instantiateType to attach the mapper to the contextualType, and then
                // calling inferTypes to force a walk of contextualType so that all the correct fixing
                // happens. The choice to pass in links.type may seem kind of arbitrary, but it serves
                // to make sure that all the correct positions in contextualType are reached by the walk.
                // Here is an example:
                //
                //      interface Base {
                //          baseProp;
                //      }
                //      interface Derived extends Base {
                //          toBase(): Base;
                //      }
                //
                //      var derived: Derived;
                //
                //      declare function foo<T>(x: T, func: (p: T) => T): T;
                //      declare function foo<T>(x: T, func: (p: T) => T): T;
                //
                //      var result = foo(derived, d => d.toBase());
                //
                // We are typing d while checking the second overload. But we've already given d
                // a type (Derived) from the first overload. However, we still want to fix the
                // T in the second overload so that we do not infer Base as a candidate for T
                // (inferring Base would make type argument inference inconsistent between the two
                // overloads).
                InferTypes(
                    mapperArg.Context,
                    type,
                    InstantiateType(contextualTypeArg, mapperArg));
            }
        }

        private IType CreatePromiseType(IType promisedType)
        {
            // creates a `Promise<T>` type where `T` is the promisedType argument
            var globalPromiseType = m_getGlobalPromiseType();

            if (globalPromiseType != m_emptyGenericType)
            {
                // if the promised type is itself a promise, get the underlying type; otherwise, fallback to the promised type
                promisedType = GetAwaitedType(promisedType);

                return CreateTypeReference(
                        globalPromiseType.Cast<IGenericType>(),
                        new List<IType> { promisedType });
            }

            return m_emptyObjectType;
        }

        private IType GetReturnTypeFromBody(/*HINT:IFunctionLikeDeclaration*/ ISignatureDeclaration node, ITypeMapper contextualMapper = null)
        {
            var contextualSignature = GetContextualSignatureForFunctionLikeDeclaration(node);

            // HINT: This function is supposed to accept type IFunctionLikeDeclaration, but
            //       in some cases it may be just an ISignatureDeclaration. So first check if that's the case, and
            //       if so return m_unknown type.
            IFunctionLikeDeclaration func = node.As<IFunctionLikeDeclaration>();

            if (func == null || func.Body == null)
            {
                return m_unknownType;
            }

            var isAsync = IsAsyncFunctionLike(func);
            IType type = null;

            if (func.Body.Kind != SyntaxKind.Block)
            {
                type = CheckExpressionCached(func.Body.Cast<IExpression>(), contextualMapper);
                if (isAsync)
                {
                    // From within an async function you can return either a non-promise value or a promise. Any
                    // Promise/A+ compatible implementation will always assimilate any foreign promise, so the
                    // return type of the body should be unwrapped to its awaited type, which we will wrap in
                    // the native Promise<T> type later in this function.
                    type = CheckAwaitedType(
                            type,
                            func,
                            Errors.Return_expression_in_async_function_does_not_have_a_valid_callable_then_member);
                }
            }
            else
            {
                List<IType> types = null;
                var funcIsGenerator = func.AsteriskToken.HasValue;

                if (funcIsGenerator)
                {
                    types = CheckAndAggregateYieldOperandTypes(
                                func.Body.Cast<IBlock>(),
                                contextualMapper);

                    if (types.Count == 0)
                    {
                        var iterableIteratorAny = CreateIterableIteratorType(m_anyType);
                        if (m_compilerOptions.NoImplicitAny.HasValue && m_compilerOptions.NoImplicitAny.Value)
                        {
                            Error(
                                func.AsteriskToken.Value,
                                Errors.Generator_implicitly_has_type_0_because_it_does_not_yield_any_values_Consider_supplying_a_return_type,
                                TypeToString(iterableIteratorAny));
                        }

                        return iterableIteratorAny;
                    }
                }
                else
                {
                    types = CheckAndAggregateReturnExpressionTypes(
                                func.Body.Cast<IBlock>(),
                                contextualMapper,
                                isAsync);

                    if (types.Count == 0)
                    {
                        if (isAsync)
                        {
                            // For an async function, the return type will not be void, but rather a Promise for void.
                            var promiseType = CreatePromiseType(m_voidType);

                            if (promiseType == m_emptyObjectType)
                            {
                                Error(func, Errors.An_async_function_or_method_must_have_a_valid_awaitable_return_type);

                                return m_unknownType;
                            }

                            return promiseType;
                        }
                        else
                        {
                            return m_voidType;
                        }
                    }
                }

                // When yield/return statements are contextually typed we allow the return type to be a union type.
                // Otherwise we require the yield/return expressions to have a best common supertype.
                type = contextualSignature != null ?
                        GetUnionType(types) :
                        GetCommonSupertype(types);

                if (type == null)
                {
                    if (funcIsGenerator)
                    {
                        Error(func, Errors.No_best_common_type_exists_among_yield_expressions);
                        return CreateIterableIteratorType(m_unknownType);
                    }

                    Error(func, Errors.No_best_common_type_exists_among_return_expressions);
                    return m_unknownType;
                }

                if (funcIsGenerator)
                {
                    type = CreateIterableIteratorType(type);
                }
            }

            if (contextualSignature == null)
            {
                ReportErrorsFromWidening(func, type);
            }

            var widenedType = GetWidenedType(type);
            if (isAsync)
            {
                // From within an async function you can return either a non-promise value or a promise. Any
                // Promise/A+ compatible implementation will always assimilate any foreign promise, so the
                // return type of the body is awaited type of the body, wrapped in a native Promise<T> type.
                var promiseType = CreatePromiseType(widenedType);
                if (promiseType == m_emptyObjectType)
                {
                    Error(func, Errors.An_async_function_or_method_must_have_a_valid_awaitable_return_type);
                    return m_unknownType;
                }

                return promiseType;
            }

            return widenedType;
        }

        private List<IType> CheckAndAggregateYieldOperandTypes(IBlock body, ITypeMapper contextualMapper = null)
        {
            List<IType> aggregatedTypes = new List<IType>();

            ForEachYieldExpression(body, yieldExpression =>
            {
                var expr = yieldExpression.Expression;

                if (expr != null)
                {
                    var type = CheckExpressionCached(expr, contextualMapper);

                    if (yieldExpression.AsteriskToken != null)
                    {
                        // A yield* expression effectively yields everything that its operand yields
                        type = CheckElementTypeOfIterable(type, yieldExpression.Expression);
                    }

                    if (!aggregatedTypes.Contains(type))
                    {
                        aggregatedTypes.Add(type);
                    }
                }
            });

            return aggregatedTypes;
        }

        private List<IType> CheckAndAggregateReturnExpressionTypes(IBlock body, ITypeMapper contextualMapper = null, bool? isAsync = null)
        {
            List<IType> aggregatedTypes = new List<IType>();

            ForEachReturnStatement(body, returnStatement =>
            {
                var expr = returnStatement.Expression;

                if (expr != null)
                {
                    var type = CheckExpressionCached(expr, contextualMapper);

                    if (isAsync == true)
                    {
                        // From within an async function you can return either a non-promise value or a promise. Any
                        // Promise/A+ compatible implementation will always assimilate any foreign promise, so the
                        // return type of the body should be unwrapped to its awaited type, which should be wrapped in
                        // the native Promise<T> type by the caller.
                        type = CheckAwaitedType(
                                type,
                                body.Parent,
                                Errors.Return_expression_in_async_function_does_not_have_a_valid_callable_then_member);
                    }

                    if (!aggregatedTypes.Contains(type))
                    {
                        aggregatedTypes.Add(type);
                    }
                }

                return (object)null;
            });

            return aggregatedTypes;
        }

        /// <summary>
        /// TypeScript Specification 1.0 (6.3) - July 2014
        /// An explicitly typed function whose return type isn't the Void or the Any type
        /// must have at least one return statement somewhere in its body.
        /// An exception to this rule is if the function implementation consists of a single 'throw' statement.
        /// </summary>
        /// <param name="func">Function declaration node.</param>
        /// <param name="returnType">return type of the function, can be undefined if return type is not explicitly specified</param>
        private void CheckAllCodePathsInNonVoidFunctionReturnOrThrow(IFunctionLikeDeclaration func, IType returnType)
        {
            if (!m_produceDiagnostics)
            {
                return;
            }

            // Functions with with an explicitly specified 'void' or 'any' return type don't need any return expressions.
            if (returnType != null && MaybeTypeOfKind(returnType, TypeFlags.Any | TypeFlags.Void))
            {
                return;
            }

            // If all we have is a function signature, or an arrow function with an expression body, then there is nothing to check.
            // also if HasImplicitReturn flag is not set this means that all codepaths in function body end with return or throw
            if (NodeIsMissing(func.Body) ||
                func.Body.Kind != SyntaxKind.Block ||
                (func.Flags & NodeFlags.HasImplicitReturn) == NodeFlags.None)
            {
                return;
            }

            var hasExplicitReturn = (func.Flags & NodeFlags.HasExplicitReturn) != NodeFlags.None;

            if (returnType != null && !hasExplicitReturn)
            {
                // minimal check: function has syntactic return type annotation and no explicit return statements in the body
                // this function does not conform to the specification.
                // NOTE: having returnType != null is a precondition for entering this branch so func.Type will always be present
                Error(
                    func.Type,
                    Errors.A_function_whose_declared_type_is_neither_void_nor_any_must_return_a_value);
            }
            else if (m_compilerOptions.NoImplicitReturns.HasValue && m_compilerOptions.NoImplicitReturns.Value)
            {
                if (returnType == null)
                {
                    // If return type annotation is omitted check if function has any explicit return statements.
                    // If it does not have any - its inferred return type is void - don't do any checks.
                    // Otherwise get inferred return type from function body and report error only if it is not void / anytype
                    var inferredReturnType = hasExplicitReturn ?
                                                GetReturnTypeOfSignature(GetSignatureFromDeclaration(func)) :
                                                m_voidType;

                    if (inferredReturnType == m_voidType || IsTypeAny(inferredReturnType))
                    {
                        return;
                    }
                }

                Error((INode)func.Type ?? func, Errors.Not_all_code_paths_return_a_value);
            }
        }

        private IType CheckFunctionExpressionOrObjectLiteralMethod(/*HINT: FunctionExpression | MethodDeclaration*/ IFunctionLikeDeclaration node, ITypeMapper contextualMapper = null)
        {
            Contract.Requires(node.Kind != SyntaxKind.MethodDeclaration || IsObjectLiteralMethod(node) != null);

            // Grammar checking
            var hasGrammarError = CheckGrammarFunctionLikeDeclaration(node);

            if (!hasGrammarError && node.Kind == SyntaxKind.FunctionExpression)
            {
                CheckGrammarForGenerator(node);
            }

            // The identityMapper object is used to indicate that function expressions are wildcards
            if (contextualMapper == s_identityMapper && // TODO: Verify correctness
                IsContextSensitive(node))
            {
                return m_anyFunctionType;
            }

            var isAsync = IsAsyncFunctionLike(node);
            if (isAsync)
            {
                GetPerFileState(node).EmitAwaiter = true;
            }

            var links = GetNodeLinks(node);
            var type = GetTypeOfSymbol(node.Symbol);
            var contextSensitive = IsContextSensitive(node);
            IInferenceContext mightFixTypeParameters = contextSensitive ? IsInferentialContext(contextualMapper) : null;

            // Check if function expression is contextually typed and assign parameter types if so.
            // See the comment in assignTypeToParameterAndFixTypeParameters to understand why we need to
            // check mightFixTypeParameters.
            if (mightFixTypeParameters != null ||
                (links.Flags & NodeCheckFlags.ContextChecked) == NodeCheckFlags.None)
            {
                var contextualSignature = GetContextualSignature(node);

                // If a type check is started at a function expression that is an argument of a function call, obtaining the
                // contextual type may recursively get back to here during overload resolution of the call. If so, we will have
                // already assigned contextual types.
                var contextChecked = (links.Flags & NodeCheckFlags.ContextChecked) != NodeCheckFlags.None;

                if (mightFixTypeParameters != null || !contextChecked)
                {
                    links.Flags |= NodeCheckFlags.ContextChecked;

                    if (contextualSignature != null)
                    {
                        var signature = GetSignaturesOfType(type, SignatureKind.Call)[0];

                        if (contextSensitive)
                        {
                            AssignContextualParameterTypes(
                                signature,
                                contextualSignature,
                                contextualMapper ?? s_identityMapper);
                        }

                        if (mightFixTypeParameters != null || (node.Type == null && signature.ResolvedReturnType == null))
                        {
                            var returnType = GetReturnTypeFromBody(node, contextualMapper);

                            signature.GetOrSetResolvedReturnType(
                                returnType,
                                (s, localReturnType) => localReturnType);
                        }
                    }

                    if (!contextChecked)
                    {
                        CheckSignatureDeclaration(node);
                        CheckNodeDeferred(node);
                    }
                }
            }

            if (m_produceDiagnostics &&
                node.Kind != SyntaxKind.MethodDeclaration &&
                node.Kind != SyntaxKind.MethodSignature)
            {
                // HINT: it seems that TypeScript implementation has weird bug here:
                // One of the possible inputs to this function is ArrowFunction.
                // And ArrowFunction does not implements IFunctionExpression.
                // In typescript the cast works fine but name property would be undefined.
                // In the managed code similar behavior lead to runtime failure.
                CheckCollisionWithCapturedSuperVariable(node, node.As<IFunctionExpression>()?.Name);
                CheckCollisionWithCapturedThisVariable(node, node.As<IFunctionExpression>()?.Name);
            }

            return type;
        }

        private void CheckFunctionExpressionOrObjectLiteralMethodDeferred(IFunctionLikeDeclaration node)
        {
            Contract.Requires(node.Kind != SyntaxKind.MethodDeclaration || IsObjectLiteralMethod(node) != null);

            var isAsync = IsAsyncFunctionLike(node);
            if (isAsync)
            {
                GetPerFileState(node).EmitAwaiter = true;
            }

            var returnOrPromisedType = node.Type != null ?
                                        (isAsync ? CheckAsyncFunctionReturnType(node) : GetTypeFromTypeNode(node.Type)) :
                                        null;
            if (!node.AsteriskToken)
            {
                // return is not necessary in the body of generators
                CheckAllCodePathsInNonVoidFunctionReturnOrThrow(node, returnOrPromisedType);
            }

            if (node.Body != null)
            {
                if (node.Type == null)
                {
                    // There are some checks that are only performed in getReturnTypeFromBody, that may produce errors
                    // we need. An example is the noImplicitAny errors resulting from widening the return expression
                    // of a function. Because checking of function expression bodies is deferred, there was never an
                    // appropriate time to do this during the main walk of the file (see the comment at the top of
                    // checkFunctionExpressionBodies). So it must be done now.
                    GetReturnTypeOfSignature(GetSignatureFromDeclaration(node));
                }

                if (node.Body.Kind == SyntaxKind.Block)
                {
                    CheckSourceElement(node.Body);
                }
                else
                {
                    // From within an async function you can return either a non-promise value or a promise. Any
                    // Promise/A+ compatible implementation will always assimilate any foreign promise, so we
                    // should not be checking assignability of a promise to the return type. Instead, we need to
                    // check assignability of the awaited type of the expression body against the promised type of
                    // its return type annotation.
                    var exprType = CheckExpression(node.Body.Cast<IExpression>());

                    if (returnOrPromisedType != null)
                    {
                        if (isAsync)
                        {
                            var awaitedType = CheckAwaitedType(
                                                exprType,
                                                node.Body,
                                                Errors.Expression_body_for_async_arrow_function_does_not_have_a_valid_callable_then_member);

                            CheckTypeAssignableTo(
                                awaitedType,
                                returnOrPromisedType,
                                node.Body);
                        }
                        else
                        {
                            CheckTypeAssignableTo(
                                exprType,
                                returnOrPromisedType,
                                node.Body);
                        }
                    }
                }
            }
        }

        private bool CheckArithmeticOperandType(INode operand, IType type, IDiagnosticMessage diagnostic)
        {
            if (!IsTypeAnyOrAllConstituentTypesHaveKind(type, TypeFlags.NumberLike))
            {
                Error(operand, diagnostic);
                return false;
            }

            return true;
        }

        private bool CheckReferenceExpression(INode n, IDiagnosticMessage invalidReferenceMessage, IDiagnosticMessage constantVariableMessage)
        {
            if (!IsReferenceOrErrorExpression(n))
            {
                Error(n, invalidReferenceMessage);
                return false;
            }

            if (IsConstVariableReference(n))
            {
                Error(n, constantVariableMessage);
                return false;
            }

            return true;

            ISymbol FindSymbol(Checker checker, INode node)
            {
                var symbol = GetResolvedSymbol(node);

                // Because we got the symbol from the resolvedSymbol property, it might be of kind
                // SymbolFlags.ExportValue. In this case it is necessary to get the actual export
                // symbol, which will have the correct flags set on it.
                return symbol != null ?
                        checker.GetExportSymbolOfValueSymbolIfExported(symbol) :
                        null;
            }

            bool IsReferenceOrErrorExpression(INode node)
            {
                // TypeScript 1.0 spec (April 2014):
                // Expressions are classified as values or references.
                // References are the subset of expressions that are permitted as the target of an assignment.
                // Specifically, references are combinations of identifiers(section 4.3), parentheses(section 4.7),
                // and property accesses(section 4.10).
                // All other expression constructs described in this chapter are classified as values.
                ISymbol symbol = null;

                switch (node.Kind)
                {
                    case SyntaxKind.Identifier:
                        symbol = FindSymbol(this, node);

                        // TypeScript 1.0 spec (April 2014): 4.3
                        // An identifier expression that references a variable or parameter is classified as a reference.
                        // An identifier expression that references any other kind of entity is classified as a value(and therefore cannot be the target of an assignment).
                        return (symbol == null) ||
                               (symbol == m_unknownSymbol) ||
                               (symbol == m_argumentsSymbol) ||
                               (symbol.Flags & SymbolFlags.Variable) != SymbolFlags.None;

                    case SyntaxKind.PropertyAccessExpression:
                        symbol = FindSymbol(this, node);

                        // TypeScript 1.0 spec (April 2014): 4.10
                        // A property access expression is always classified as a reference.
                        // NOTE (not in spec): assignment to enum members should not be allowed
                        return (symbol == null) ||
                               (symbol == m_unknownSymbol) ||
                               (symbol.Flags & ~SymbolFlags.EnumMember) != SymbolFlags.None;

                    case SyntaxKind.ElementAccessExpression:
                        // old compiler doesn't check indexed access
                        return true;

                    case SyntaxKind.ParenthesizedExpression:
                        return IsReferenceOrErrorExpression(node.Cast<IParenthesizedExpression>().Expression);

                    default:
                        return false;
                }
            }

            bool IsConstVariableReference(INode node)
            {
                ISymbol symbol = null;

                switch (node.Kind)
                {
                    case SyntaxKind.Identifier:
                    case SyntaxKind.PropertyAccessExpression:
                        symbol = FindSymbol(this, node);

                        return (symbol != null) &&
                               (symbol.Flags & SymbolFlags.Variable) != SymbolFlags.None &&
                               (GetDeclarationFlagsFromSymbol(symbol) & NodeFlags.Const) != NodeFlags.None;

                    case SyntaxKind.ElementAccessExpression:
                        var index = node.Cast<IElementAccessExpression>().ArgumentExpression;
                        symbol = FindSymbol(this, node.Cast<IElementAccessExpression>().Expression);

                        if (symbol != null &&
                            index != null &&
                            index.Kind == SyntaxKind.StringLiteral)
                        {
                            var name = index.Cast<ILiteralExpression>().Text;
                            var prop = GetPropertyOfType(GetTypeOfSymbol(symbol), name);

                            return (prop != null) &&
                                   (prop.Flags & SymbolFlags.Variable) != SymbolFlags.None &&
                                   (GetDeclarationFlagsFromSymbol(prop) & NodeFlags.Const) != NodeFlags.None;
                        }

                        return false;

                    case SyntaxKind.ParenthesizedExpression:
                        return IsConstVariableReference(node.Cast<IParenthesizedExpression>().Expression);

                    default:
                        return false;
                }
            }
        }

        private IType CheckDeleteExpression(IDeleteExpression node)
        {
            CheckExpression(node.Expression);

            return m_booleanType;
        }

        private IType CheckTypeOfExpression(ITypeOfExpression node)
        {
            CheckExpression(node.Expression);

            return m_stringType;
        }

        private IType CheckVoidExpression(IVoidExpression node)
        {
            CheckExpression(node.Expression);

            return m_undefinedType;
        }

        private IType CheckAwaitExpression(IAwaitExpression node)
        {
            // Grammar checking
            if (m_produceDiagnostics)
            {
                if (!node.IsAwait())
                {
                    GrammarErrorOnFirstToken(node, Errors.Await_expression_is_only_allowed_within_an_async_function);
                }

                if (IsInParameterInitializerBeforeContainingFunction(node))
                {
                    Error(node, Errors.Await_expressions_cannot_be_used_in_a_parameter_initializer);
                }
            }

            var operandType = CheckExpression(node.Expression);

            return CheckAwaitedType(operandType, node);
        }

        private IType CheckPrefixUnaryExpression(IPrefixUnaryExpression node)
        {
            var operandType = CheckExpression(node.Operand);

            switch (node.Operator)
            {
                case SyntaxKind.PlusToken:
                case SyntaxKind.MinusToken:
                case SyntaxKind.TildeToken:
                    if (MaybeTypeOfKind(operandType, TypeFlags.EsSymbol))
                    {
                        Error(
                            node.Operand,
                            Errors.The_0_operator_cannot_be_applied_to_type_symbol,
                            TokenToString(node.Operator));
                    }

                    return m_numberType;

                case SyntaxKind.ExclamationToken:
                    return m_booleanType;

                case SyntaxKind.PlusPlusToken:
                case SyntaxKind.MinusMinusToken:
                    var ok = CheckArithmeticOperandType(
                                node.Operand,
                                operandType,
                                Errors.An_arithmetic_operand_must_be_of_type_any_number_or_an_enum_type);
                    if (ok)
                    {
                        // run check only if former checks succeeded to avoid reporting cascading errors
                        CheckReferenceExpression(
                            node.Operand,
                            Errors.The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_property_or_indexer,
                            Errors.The_operand_of_an_increment_or_decrement_operator_cannot_be_a_constant);
                    }

                    return m_numberType;
            }

            return m_unknownType;
        }

        private IType CheckPostfixUnaryExpression(IPostfixUnaryExpression node)
        {
            var operandType = CheckExpression(node.Operand);
            var ok = CheckArithmeticOperandType(
                        node.Operand,
                        operandType,
                        Errors.An_arithmetic_operand_must_be_of_type_any_number_or_an_enum_type);

            if (ok)
            {
                // run check only if former checks succeeded to avoid reporting cascading errors
                CheckReferenceExpression(
                    node.Operand,
                    Errors.The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_property_or_indexer,
                    Errors.The_operand_of_an_increment_or_decrement_operator_cannot_be_a_constant);
            }

            return m_numberType;
        }

        // Return true if type might be of the given kind. A union or intersection type might be of a given
        // kind if at least one constituent type is of the given kind.
        // Ported from commit e7aa7e49
        private bool MaybeTypeOfKind(IType type, TypeFlags kind)
        {
            if ((type.Flags & kind) != TypeFlags.None)
            {
                return true;
            }

            if ((type.Flags & TypeFlags.UnionOrIntersection) != TypeFlags.None)
            {
                var types = type.Cast<IUnionOrIntersectionType>().Types;

                foreach (var t in types)
                {
                    if (MaybeTypeOfKind(t, kind))
                    {
                        return true;
                    }
                }

                return false;
            }

            return false;
        }

        // Return true if type is of the given kind. A union type is of a given kind if all constituent types
        // are of the given kind. An intersection type is of a given kind if at least one constituent type is
        // of the given kind.
        // Ported from commit e7aa7e49
        private bool IsTypeOfKind(IType type, TypeFlags kind)
        {
            if ((type.Flags & kind) != TypeFlags.None)
            {
                return true;
            }

            if ((type.Flags & TypeFlags.Union) != TypeFlags.None)
            {
                var types = type.Cast<IUnionOrIntersectionType>().Types;

                foreach (var t in types)
                {
                    if (!IsTypeOfKind(t, kind))
                    {
                        return false;
                    }
                }

                return true;
            }

            if ((type.Flags & TypeFlags.Intersection) != TypeFlags.None)
            {
                var types = type.Cast<IUnionOrIntersectionType>().Types;
                foreach (var t in types)
                {
                    if (IsTypeOfKind(t, kind))
                    {
                        return true;
                    }
                }
            }

            return false;
        }

        private static bool IsConstEnumObjectType(IType type)
        {
            return (type.Flags & (TypeFlags.ObjectType | TypeFlags.Anonymous)) != TypeFlags.None &&
                   type.Symbol != null &&
                   IsConstEnumSymbol(type.Symbol);
        }

        private static bool IsConstEnumSymbol(ISymbol symbol)
        {
            return (symbol.Flags & SymbolFlags.ConstEnum) != SymbolFlags.None;
        }

        private IType CheckInstanceOfExpression(IExpression left, IExpression right, IType leftType, IType rightType)
        {
            // TypeScript 1.0 spec (April 2014): 4.15.4
            // The instanceof operator requires the left operand to be of type Any, an object type, or a type parameter type,
            // and the right operand to be of type Any or a subtype of the 'Function' interface type.
            // The result is always of the Boolean primitive type.
            // NOTE: do not raise error if leftType is unknown as related error was already reported
            if (IsTypeOfKind(leftType, TypeFlags.Primitive))
            {
                Error(
                    left,
                    Errors.The_left_hand_side_of_an_instanceof_expression_must_be_of_type_any_an_object_type_or_a_type_parameter);
            }

            // NOTE: do not raise error if right is unknown as related error was already reported
            if (!(IsTypeAny(rightType) || IsTypeSubtypeOf(rightType, m_globalFunctionType)))
            {
                Error(
                    right,
                    Errors.The_right_hand_side_of_an_instanceof_expression_must_be_of_type_any_or_of_a_type_assignable_to_the_Function_interface_type);
            }

            return m_booleanType;
        }

        private IType CheckInExpression(IExpression left, IExpression right, IType leftType, IType rightType)
        {
            // TypeScript 1.0 spec (April 2014): 4.15.5
            // The in operator requires the left operand to be of type Any, the String primitive type, or the Number primitive type,
            // and the right operand to be of type Any, an object type, or a type parameter type.
            // The result is always of the Boolean primitive type.
            if (!IsTypeAnyOrAllConstituentTypesHaveKind(leftType, TypeFlags.StringLike | TypeFlags.NumberLike | TypeFlags.EsSymbol))
            {
                Error(left, Errors.The_left_hand_side_of_an_in_expression_must_be_of_type_any_string_number_or_symbol);
            }

            if (!IsTypeAnyOrAllConstituentTypesHaveKind(rightType, TypeFlags.ObjectType | TypeFlags.TypeParameter))
            {
                Error(right, Errors.The_right_hand_side_of_an_in_expression_must_be_of_type_any_an_object_type_or_a_type_parameter);
            }

            return m_booleanType;
        }

        private IType CheckObjectLiteralAssignment(IObjectLiteralExpression node, IType sourceType, ITypeMapper contextualMapper = null)
        {
            var properties = node.Properties;

            foreach (var p in properties)
            {
                if (p.Kind == SyntaxKind.PropertyAssignment || p.Kind == SyntaxKind.ShorthandPropertyAssignment)
                {
                    var name = p.Name;

                    if (name.Kind == SyntaxKind.ComputedPropertyName)
                    {
                        CheckComputedPropertyName(name.Cast<IComputedPropertyName>());
                    }

                    if (IsComputedNonLiteralName(name))
                    {
                        continue;
                    }

                    var text = GetTextOfPropertyName(name);

                    var type = IsTypeAny(sourceType) ?
                                sourceType :
                                GetTypeOfPropertyOfType(sourceType, text) ??
                                (Number.IsNumericLiteralName(text) ? GetIndexTypeOfType(sourceType, IndexKind.Number) : null) ??
                                GetIndexTypeOfType(sourceType, IndexKind.String);

                    if (type != null)
                    {
                        if (p.Kind == SyntaxKind.ShorthandPropertyAssignment)
                        {
                            CheckDestructuringAssignment(p.Cast<IShorthandPropertyAssignment>(), type);
                        }
                        else
                        {
                            // non-shorthand property assignments should always have initializers
                            CheckDestructuringAssignment(p.Cast<IPropertyAssignment>().Initializer, type);
                        }
                    }
                    else
                    {
                        Error(
                            name,
                            Errors.Type_0_has_no_property_1_and_no_string_index_signature,
                            TypeToString(sourceType),
                            DeclarationNameToString(name));
                    }
                }
                else
                {
                    Error(p, Errors.Property_assignment_expected);
                }
            }

            return sourceType;
        }

        private IType CheckArrayLiteralAssignment(IArrayLiteralExpression node, IType sourceType, ITypeMapper contextualMapper = null)
        {
            // This elementType will be used if the specific property corresponding to this index is not
            // present (aka the tuple element property). This call also checks that the parentType is in
            // fact an iterable or array (depending on target language).
            var elementType = CheckIteratedTypeOrElementType(
                                sourceType,
                                node,
                                /*allowStringInput*/ false) ?? m_unknownType;
            var elements = node.Elements;

            for (var i = 0; i < elements.Length; i++)
            {
                var e = elements[i];

                if (e.Kind != SyntaxKind.OmittedExpression)
                {
                    if (e.Kind != SyntaxKind.SpreadElementExpression)
                    {
                        var propName = i.ToString();

                        var type = IsTypeAny(sourceType) ?
                                    sourceType :
                                    IsTupleLikeType(sourceType) ?
                                        GetTypeOfPropertyOfType(sourceType, propName) :
                                        elementType;

                        if (type != null)
                        {
                            CheckDestructuringAssignment(
                                e,
                                type,
                                contextualMapper);
                        }
                        else
                        {
                            if (IsTupleType(sourceType))
                            {
                                Error(
                                    e,
                                    Errors.Tuple_type_0_with_length_1_cannot_be_assigned_to_tuple_with_length_2,
                                    TypeToString(sourceType),
                                    sourceType.Cast<ITupleType>().ElementTypes.Count,
                                    elements.Length);
                            }
                            else
                            {
                                Error(
                                    e,
                                    Errors.Type_0_has_no_property_1,
                                    TypeToString(sourceType),
                                    propName);
                            }
                        }
                    }
                    else
                    {
                        if (i < elements.Length - 1)
                        {
                            Error(
                                e,
                                Errors.A_rest_element_must_be_last_in_an_array_destructuring_pattern);
                        }
                        else
                        {
                            var restExpression = e.Cast<ISpreadElementExpression>().Expression;

                            if (restExpression.Kind == SyntaxKind.BinaryExpression &&
                                restExpression.Cast<IBinaryExpression>().OperatorToken.Kind == SyntaxKind.EqualsToken)
                            {
                                Error(
                                    restExpression.Cast<IBinaryExpression>().OperatorToken,
                                    Errors.A_rest_element_cannot_have_an_initializer);
                            }
                            else
                            {
                                CheckDestructuringAssignment(
                                    restExpression,
                                    CreateArrayType(elementType),
                                    contextualMapper);
                            }
                        }
                    }
                }
            }

            return sourceType;
        }

        private IType CheckDestructuringAssignment(/*HINT:Expression | ShorthandPropertyAssignment*/ INode exprOrAssignment, IType sourceType, ITypeMapper contextualMapper = null)
        {
            IExpression target = null;

            if (exprOrAssignment.Kind == SyntaxKind.ShorthandPropertyAssignment)
            {
                var prop = exprOrAssignment.Cast<IShorthandPropertyAssignment>();
                if (prop.ObjectAssignmentInitializer != null)
                {
                    CheckBinaryLikeExpression(
                        prop.Name,
                        prop.EqualsToken.ValueOrDefault,
                        prop.ObjectAssignmentInitializer,
                        contextualMapper);
                }

                target = prop.Name;
            }
            else
            {
                target = exprOrAssignment.Cast<IExpression>();
            }

            if (target.Kind == SyntaxKind.BinaryExpression &&
                target.Cast<IBinaryExpression>().OperatorToken.Kind == SyntaxKind.EqualsToken)
            {
                CheckBinaryExpression(
                    target.Cast<IBinaryExpression>(),
                    contextualMapper);

                target = target.Cast<IBinaryExpression>().Left;
            }

            if (target.Kind == SyntaxKind.ObjectLiteralExpression)
            {
                return CheckObjectLiteralAssignment(
                        target.Cast<IObjectLiteralExpression>(),
                        sourceType,
                        contextualMapper);
            }

            if (target.Kind == SyntaxKind.ArrayLiteralExpression)
            {
                return CheckArrayLiteralAssignment(
                        target.Cast<IArrayLiteralExpression>(),
                        sourceType,
                        contextualMapper);
            }

            return CheckReferenceAssignment(
                    target,
                    sourceType,
                    contextualMapper);
        }

        private IType CheckReferenceAssignment(IExpression target, IType sourceType, ITypeMapper contextualMapper = null)
        {
            var targetType = CheckExpression(target, contextualMapper);

            if (CheckReferenceExpression(
                    target,
                    Errors.Invalid_left_hand_side_of_assignment_expression,
                    Errors.Left_hand_side_of_assignment_expression_cannot_be_a_constant))
            {
                CheckTypeAssignableTo(sourceType, targetType, target, /*headMessage*/ null);
            }

            return sourceType;
        }

        private IType CheckBinaryExpression(IBinaryExpression node, ITypeMapper contextualMapper = null)
        {
            return CheckBinaryLikeExpression(
                    node.Left,
                    node.OperatorToken,
                    node.Right,
                    contextualMapper,
                    node);
        }

        private IType CheckBinaryLikeExpression(IExpression left, INode operatorToken, IExpression right, ITypeMapper contextualMapper = null, INode errorNode = null)
        {
            var @operator = operatorToken.Kind;

            if (@operator == SyntaxKind.EqualsToken &&
                (left.Kind == SyntaxKind.ObjectLiteralExpression || left.Kind == SyntaxKind.ArrayLiteralExpression))
            {
                return CheckDestructuringAssignment(
                        left,
                        CheckExpression(right, contextualMapper),
                        contextualMapper);
            }

            var leftType = CheckExpression(left, contextualMapper);
            var rightType = CheckExpression(right, contextualMapper);

            switch (@operator)
            {
                case SyntaxKind.AsteriskToken:
                case SyntaxKind.AsteriskAsteriskToken:
                case SyntaxKind.AsteriskEqualsToken:
                case SyntaxKind.AsteriskAsteriskEqualsToken:
                case SyntaxKind.SlashToken:
                case SyntaxKind.SlashEqualsToken:
                case SyntaxKind.PercentToken:
                case SyntaxKind.PercentEqualsToken:
                case SyntaxKind.MinusToken:
                case SyntaxKind.MinusEqualsToken:
                case SyntaxKind.LessThanLessThanToken:
                case SyntaxKind.LessThanLessThanEqualsToken:
                case SyntaxKind.GreaterThanGreaterThanToken:
                case SyntaxKind.GreaterThanGreaterThanEqualsToken:
                case SyntaxKind.GreaterThanGreaterThanGreaterThanToken:
                case SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken:
                case SyntaxKind.BarToken:
                case SyntaxKind.BarEqualsToken:
                case SyntaxKind.CaretToken:
                case SyntaxKind.CaretEqualsToken:
                case SyntaxKind.AmpersandToken:
                case SyntaxKind.AmpersandEqualsToken:
                    // TypeScript 1.0 spec (April 2014): 4.19.1
                    // These operators require their operands to be of type Any, the Number primitive type,
                    // or an enum type. Operands of an enum type are treated
                    // as having the primitive type Number. If one operand is the null or undefined value,
                    // it is treated as having the type of the other operand.
                    // The result is always of the Number primitive type.
                    if ((leftType.Flags & (TypeFlags.Undefined | TypeFlags.Null)) != TypeFlags.None)
                    {
                        leftType = rightType;
                    }

                    if ((rightType.Flags & (TypeFlags.Undefined | TypeFlags.Null)) != TypeFlags.None)
                    {
                        rightType = leftType;
                    }

                    SyntaxKind? suggestedOperator = null;

                    // if a user tries to apply a bitwise operator to 2 bool operands
                    // try and return them a helpful suggestion
                    if ((leftType.Flags & TypeFlags.Boolean) != TypeFlags.None &&
                        (rightType.Flags & TypeFlags.Boolean) != TypeFlags.None &&
                        (suggestedOperator = GetSuggestedBooleanOperator(operatorToken.Kind)) != null)
                    {
                        Error(
                            errorNode ?? operatorToken,
                            Errors.The_0_operator_is_not_allowed_for_boolean_types_Consider_using_1_instead,
                            TokenToString(operatorToken.Kind),
                            TokenToString(suggestedOperator.Value));
                    }
                    else
                    {
                        // otherwise just check each operand separately and report errors as normal
                        var leftOk = CheckArithmeticOperandType(
                                        left,
                                        leftType,
                                        Errors.The_left_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_or_an_enum_type);

                        var rightOk = CheckArithmeticOperandType(
                                        right,
                                        rightType,
                                        Errors.The_right_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_or_an_enum_type);

                        if (leftOk && rightOk)
                        {
                            CheckAssignmentOperator(m_numberType);
                        }
                    }

                    return m_numberType;

                case SyntaxKind.PlusToken:
                case SyntaxKind.PlusEqualsToken:
                    // TypeScript 1.0 spec (April 2014): 4.19.2
                    // The binary + operator requires both operands to be of the Number primitive type or an enum type,
                    // or at least one of the operands to be of type Any or the String primitive type.

                    // If one operand is the null or undefined value, it is treated as having the type of the other operand.
                    if ((leftType.Flags & (TypeFlags.Undefined | TypeFlags.Null)) != TypeFlags.None)
                    {
                        leftType = rightType;
                    }

                    if ((rightType.Flags & (TypeFlags.Undefined | TypeFlags.Null)) != TypeFlags.None)
                    {
                        rightType = leftType;
                    }

                    IType resultType = null;

                    if (IsTypeOfKind(leftType, TypeFlags.NumberLike) &&
                        IsTypeOfKind(rightType, TypeFlags.NumberLike))
                    {
                        // Operands of an enum type are treated as having the primitive type Number.
                        // If both operands are of the Number primitive type, the result is of the Number primitive type.
                        resultType = m_numberType;
                    }
                    else
                    {
                        if (IsTypeOfKind(leftType, TypeFlags.StringLike) ||
                            IsTypeOfKind(rightType, TypeFlags.StringLike))
                        {
                            // If one or both operands are of the String primitive type, the result is of the String primitive type.
                            resultType = m_stringType;
                        }
                        else if (IsTypeAny(leftType) || IsTypeAny(rightType))
                        {
                            // Otherwise, the result is of type Any.
                            // NOTE: unknown type here denotes error type. Old compiler treated this case as any type so do we.
                            resultType = (leftType == m_unknownType) || (rightType == m_unknownType) ?
                                            m_unknownType :
                                            m_anyType;
                        }

                        // Symbols are not allowed at all in arithmetic expressions
                        if (resultType != null && !CheckForDisallowedEsSymbolOperand(@operator))
                        {
                            return resultType;
                        }
                    }

                    if (resultType == null)
                    {
                        ReportOperatorError();
                        return m_anyType;
                    }

                    if (@operator == SyntaxKind.PlusEqualsToken)
                    {
                        CheckAssignmentOperator(resultType);
                    }

                    return resultType;

                case SyntaxKind.LessThanToken:
                case SyntaxKind.GreaterThanToken:
                case SyntaxKind.LessThanEqualsToken:
                case SyntaxKind.GreaterThanEqualsToken:
                case SyntaxKind.EqualsEqualsToken:
                case SyntaxKind.ExclamationEqualsToken:
                case SyntaxKind.EqualsEqualsEqualsToken:
                case SyntaxKind.ExclamationEqualsEqualsToken:
                    if (@operator == SyntaxKind.LessThanToken ||
                        @operator == SyntaxKind.GreaterThanToken ||
                        @operator == SyntaxKind.LessThanEqualsToken ||
                        @operator == SyntaxKind.GreaterThanEqualsToken)
                    {
                        if (!CheckForDisallowedEsSymbolOperand(@operator))
                        {
                            return m_booleanType;
                        }
                    }

                    if (!IsTypeComparableTo(leftType, rightType) && !IsTypeComparableTo(rightType, leftType))
                    {
                        ReportOperatorError();
                    }

                    return m_booleanType;
                case SyntaxKind.InstanceOfKeyword:
                    return CheckInstanceOfExpression(
                            left,
                            right,
                            leftType,
                            rightType);

                case SyntaxKind.InKeyword:
                    return CheckInExpression(
                            left,
                            right,
                            leftType,
                            rightType);

                case SyntaxKind.AmpersandAmpersandToken:
                    return rightType;

                case SyntaxKind.BarBarToken:
                    return GetUnionType(new List<IType> { leftType, rightType });

                case SyntaxKind.EqualsToken:
                    CheckAssignmentOperator(rightType);
                    return GetRegularTypeOfObjectLiteral(rightType);

                case SyntaxKind.CommaToken:
                    return rightType;
            }

            // TODO: Debug.Assert?
            return null;

            // Return true if there was no error, false if there was an error.
            bool CheckForDisallowedEsSymbolOperand(SyntaxKind op)
            {
                var offendingSymbolOperand = MaybeTypeOfKind(leftType, TypeFlags.EsSymbol) ?
                                                left :
                                                    MaybeTypeOfKind(rightType, TypeFlags.EsSymbol) ?
                                                    right :
                                                    null;
                if (offendingSymbolOperand != null)
                {
                    Error(
                        offendingSymbolOperand,
                        Errors.The_0_operator_cannot_be_applied_to_type_symbol,
                        TokenToString(op));

                    return false;
                }

                return true;
            }

            SyntaxKind? GetSuggestedBooleanOperator(SyntaxKind op)
            {
                switch (op)
                {
                    case SyntaxKind.BarToken:
                    case SyntaxKind.BarEqualsToken:
                        return SyntaxKind.BarBarToken;

                    case SyntaxKind.CaretToken:
                    case SyntaxKind.CaretEqualsToken:
                        return SyntaxKind.ExclamationEqualsEqualsToken;

                    case SyntaxKind.AmpersandToken:
                    case SyntaxKind.AmpersandEqualsToken:
                        return SyntaxKind.AmpersandAmpersandToken;

                    default:
                        return null;
                }
            }

            void CheckAssignmentOperator(IType valueType)
            {
                if (m_produceDiagnostics &&
                    @operator >= SyntaxKind.FirstAssignment && @operator <= SyntaxKind.LastAssignment)
                {
                    // TypeScript 1.0 spec (April 2014): 4.17
                    // An assignment of the form
                    //    VarExpr = ValueExpr
                    // requires VarExpr to be classified as a reference
                    // A compound assignment furthermore requires VarExpr to be classified as a reference (section 4.1)
                    // and the type of the non - compound operation to be assignable to the type of VarExpr.
                    var ok = CheckReferenceExpression(
                                left,
                                Errors.Invalid_left_hand_side_of_assignment_expression,
                                Errors.Left_hand_side_of_assignment_expression_cannot_be_a_constant);

                    // Use default messages
                    if (ok)
                    {
                        // to avoid cascading errors check assignability only if 'isReference' check succeeded and no errors were reported
                        CheckTypeAssignableTo(
                            valueType,
                            leftType,
                            left,
                            /*headMessage*/ null);
                    }
                }
            }

            void ReportOperatorError()
            {
                Error(
                    errorNode ?? operatorToken,
                    Errors.Operator_0_cannot_be_applied_to_types_1_and_2,
                    TokenToString(operatorToken.Kind),
                    TypeToString(leftType),
                    TypeToString(rightType));
            }
        }

        private static bool IsYieldExpressionInClass(IYieldExpression node)
        {
            INode current = node;
            var parent = node.Parent;

            while (parent != null)
            {
                if (IsFunctionLike(parent) != null &&
                    current.ResolveUnionType() == parent.Cast<IFunctionLikeDeclaration>().Body.ResolveUnionType())
                {
                    return false;
                }

                if (IsClassLike(current) != null)
                {
                    return true;
                }

                current = parent;
                parent = parent.Parent;
            }

            return false;
        }

        private IType CheckYieldExpression(IYieldExpression node)
        {
            // Grammar checking
            if (m_produceDiagnostics)
            {
                if (!node.IsYield() || IsYieldExpressionInClass(node))
                {
                    GrammarErrorOnFirstToken(node, Errors.A_yield_expression_is_only_allowed_in_a_generator_body);
                }

                if (IsInParameterInitializerBeforeContainingFunction(node))
                {
                    Error(node, Errors.Yield_expressions_cannot_be_used_in_a_parameter_initializer);
                }
            }

            if (node.Expression != null)
            {
                var func = GetContainingFunction(node);

                // If the user's code is syntactically correct, the func should always have a star. After all,
                // we are in a yield context.
                if (func != null && func.AsteriskToken)
                {
                    var expressionType = CheckExpressionCached(node.Expression, /*contextualMapper*/ null);
                    IType expressionElementType = null;

                    var nodeIsYieldStar = node.AsteriskToken != null;

                    if (nodeIsYieldStar)
                    {
                        expressionElementType = CheckElementTypeOfIterable(expressionType, node.Expression);
                    }

                    // There is no point in doing an assignability check if the function
                    // has no explicit return type because the return type is directly computed
                    // from the yield expressions.
                    if (func.Type != null)
                    {
                        var signatureElementType = GetElementTypeOfIterableIterator(GetTypeFromTypeNode(func.Type)) ??
                                                   m_anyType;

                        if (nodeIsYieldStar)
                        {
                            CheckTypeAssignableTo(
                                expressionElementType,
                                signatureElementType,
                                node.Expression,
                                /*headMessage*/ null);
                        }
                        else
                        {
                            CheckTypeAssignableTo(
                                expressionType,
                                signatureElementType,
                                node.Expression,
                                /*headMessage*/ null);
                        }
                    }
                }
            }

            // Both yield and yield* expressions have type 'any'
            return m_anyType;
        }

        private IType CheckConditionalExpression(IConditionalExpression node, ITypeMapper contextualMapper = null)
        {
            CheckExpression(node.Condition);

            var type1 = CheckExpression(node.WhenTrue, contextualMapper);
            var type2 = CheckExpression(node.WhenFalse, contextualMapper);

            return GetUnionType(new List<IType> { type1, type2 });
        }

        private IType CheckStringLiteralExpression(IStringLiteral node)
        {
            if (ShouldAcquireLiteralType(node))
            {
                return GetStringLiteralTypeForText(node.Text);
            }

            return m_stringType;
        }

        private IType CheckTemplateExpression(ITemplateExpression node)
        {
            // We just want to check each expressions, but we are unconcerned with
            // the type of each expression, as any value may be coerced into a string.
            // It is worth asking whether this is what we really want though.
            // A place where we actually *are* concerned with the expressions' types are
            // in tagged templates.
            ForEach(node.Cast<ITemplateExpression>().TemplateSpans, this, (templateSpan, @this) =>
            {
                @this.CheckExpression(templateSpan.Expression);
            });

            return m_stringType;
        }

        private IType CheckExpressionWithContextualType(IExpression node, IType contextualType, ITypeMapper contextualMapper = null)
        {
            var savedContextualType = GetContextualTypeOrDefault(node);

            // If current contextual type and a given contextual type are both null, then nothing special needs to be done.
            if (contextualType == null && savedContextualType == null)
            {
                return CheckExpression(node, contextualMapper);
            }

            SaveContextualType(node, contextualType);

            var result = CheckExpression(node, contextualMapper);
            RestoreContextualType(node, savedContextualType);

            return result;
        }

        private void SaveContextualType(IExpression node, IType contextualType)
        {
            m_contextualTypes.Value[node] = contextualType;
        }

        private IType GetContextualTypeOrDefault(IExpression node)
        {
            IType result;
            m_contextualTypes.Value.TryGetValue(node, out result);
            return result;
        }

        private void RestoreContextualType(IExpression node, IType oldContextualType)
        {
            if (oldContextualType == null)
            {
                m_contextualTypes.Value.Remove(node);
            }
            else
            {
                m_contextualTypes.Value[node] = oldContextualType;
            }
        }

        private IType CheckExpressionCached(IExpression nodeArg, ITypeMapper contextualMapperArg = null)
        {
            return GetNodeLinks(nodeArg).GetOrSetResolvedType(
                (checker: this, nodeArg, contextualMapperArg),
                (links, tuple) =>
                {
                    var @this = tuple.checker;
                    var node = tuple.nodeArg;
                    var contextualMapper = tuple.contextualMapperArg;
                    return @this.CheckExpression(node, contextualMapper);
                });
        }

        private IType CheckPropertyAssignment(IPropertyAssignment node, ITypeMapper contextualMapper = null)
        {
            // Do not use hasDynamicName here, because that returns false for well known symbols.
            // We want to perform checkComputedPropertyName for all computed properties, including
            // well known symbols.
            if (node.Name.Kind == SyntaxKind.ComputedPropertyName)
            {
                CheckComputedPropertyName(node.Name.Cast<IComputedPropertyName>());
            }

            return CheckExpression(node.Initializer, contextualMapper);
        }

        private IType CheckObjectLiteralMethod(IMethodDeclaration node, ITypeMapper contextualMapper = null)
        {
            // Grammar checking
            CheckGrammarMethod(node);

            // Do not use hasDynamicName here, because that returns false for well known symbols.
            // We want to perform checkComputedPropertyName for all computed properties, including
            // well known symbols.
            if (node.Name.Kind == SyntaxKind.ComputedPropertyName)
            {
                CheckComputedPropertyName(node.Name.Cast<IComputedPropertyName>());
            }

            var uninstantiatedType = CheckFunctionExpressionOrObjectLiteralMethod(
                                        node,
                                        contextualMapper);

            return InstantiateTypeWithSingleGenericCallSignature(
                    node,
                    uninstantiatedType,
                    contextualMapper);
        }

        private IType InstantiateTypeWithSingleGenericCallSignature(/*HINT:Expression | MethodDeclaration*/ INode node, IType type, ITypeMapper contextualMapper = null)
        {
            if (IsInferentialContext(contextualMapper) != null)
            {
                var signature = GetSingleCallSignature(type);

                if (signature?.TypeParameters != null)
                {
                    // TODO: Verify correctness! Original TS code has unsafe cast in cast that node is MethodDeclaration
                    //       const contextualType = getApparentTypeOfContextualType(<Expression>node);
                    var contextualType = node.Kind != SyntaxKind.MethodDeclaration ?
                                            GetApparentTypeOfContextualType(node.Cast<IExpression>()) :
                                            null;

                    if (contextualType != null)
                    {
                        var contextualSignature = GetSingleCallSignature(contextualType);
                        if (contextualSignature != null && contextualSignature.TypeParameters == null)
                        {
                            return GetOrCreateTypeFromSignature(
                                    InstantiateSignatureInContextOf(
                                        signature,
                                        contextualSignature,
                                        contextualMapper));
                        }
                    }
                }
            }

            return type;
        }

        // Checks an expression and returns its type. The contextualMapper parameter serves two purposes: When
        // contextualMapper is not undefined and not equal to the identityMapper function object it indicates that the
        // expression is being inferentially typed (section 4.12.2 in spec) and provides the type mapper to use in
        // conjunction with the generic contextual type. When contextualMapper is equal to the identityMapper function
        // object, it serves as an indicator that all contained function and arrow expressions should be considered to
        // have the wildcard function type; this form of type check is used during overload resolution to exclude
        // contextually typed function and arrow expressions in the initial phase.
        private IType CheckExpression(/*HINT:Expression | QualifiedName*/ INode node, ITypeMapper contextualMapper = null)
        {
            IType type = null;

            if (node.Kind == SyntaxKind.QualifiedName)
            {
                type = CheckQualifiedName(node.Cast<IQualifiedName>());
            }
            else
            {
                var uninstantiatedType = CheckExpressionWorker(node.Cast<IExpression>(), contextualMapper);

                type = InstantiateTypeWithSingleGenericCallSignature(
                        node.Cast<IExpression>(),
                        uninstantiatedType,
                        contextualMapper);
            }

            if (IsConstEnumObjectType(type))
            {
                // enum object type for const enums are only permitted in:
                // - 'left' in property access
                // - 'object' in indexed access
                // - target in rhs of import statement
                var ok =
                    (node.Parent.Kind == SyntaxKind.PropertyAccessExpression && node.Parent.Cast<IPropertyAccessExpression>().Expression.ResolveUnionType() == node.ResolveUnionType()) ||
                    (node.Parent.Kind == SyntaxKind.ElementAccessExpression && node.Parent.Cast<IElementAccessExpression>().Expression.ResolveUnionType() == node.ResolveUnionType()) ||
                    ((node.Kind == SyntaxKind.Identifier || node.Kind == SyntaxKind.QualifiedName) && IsInRightSideOfImportOrExportAssignment(EntityName.FromNode(node)));

                if (!ok)
                {
                    Error(
                        node,
                        Errors.Const_enums_can_only_be_used_in_property_or_index_access_expressions_or_the_right_hand_side_of_an_import_declaration_or_export_assignment);
                }
            }

            return type;
        }

        private IType CheckNumericLiteral(ILiteralExpression node)
        {
            // Grammar checking
            CheckGrammarNumericLiteral(node);
            return m_numberType;
        }

        private IType CheckExpressionWorker(IExpression node, ITypeMapper contextualMapper)
        {
            switch (node.Kind)
            {
                case SyntaxKind.Identifier:
                    return CheckIdentifier(node.Cast<IIdentifier>());

                case SyntaxKind.ThisKeyword:
                    return CheckThisExpression(node);

                case SyntaxKind.SuperKeyword:
                    return CheckSuperExpression(node);

                case SyntaxKind.NullKeyword:
                    return m_nullType;

                case SyntaxKind.TrueKeyword:
                case SyntaxKind.FalseKeyword:
                    return m_booleanType;

                case SyntaxKind.NumericLiteral:
                    return CheckNumericLiteral(node.Cast<ILiteralExpression>());

                case SyntaxKind.TemplateExpression:
                    return CheckTemplateExpression(node.Cast<ITemplateExpression>());

                case SyntaxKind.StringLiteral:
                    return CheckStringLiteralExpression(node.Cast<IStringLiteral>());

                case SyntaxKind.NoSubstitutionTemplateLiteral:
                    return m_stringType;

                case SyntaxKind.RegularExpressionLiteral:
                    return m_globalRegExpType;

                case SyntaxKind.ArrayLiteralExpression:
                    return CheckArrayLiteral(
                            node.Cast<IArrayLiteralExpression>(),
                            contextualMapper);

                case SyntaxKind.ObjectLiteralExpression:
                    return CheckObjectLiteral(
                            node.Cast<IObjectLiteralExpression>(),
                            contextualMapper);

                case SyntaxKind.PropertyAccessExpression:
                    return CheckPropertyAccessExpression(node.Cast<IPropertyAccessExpression>());

                case SyntaxKind.ElementAccessExpression:
                    return CheckIndexedAccess(node.Cast<IElementAccessExpression>());

                case SyntaxKind.CallExpression:
                case SyntaxKind.NewExpression:
                    return CheckCallExpression(node.Cast<ICallExpression>());

                case SyntaxKind.TaggedTemplateExpression:
                    return CheckTaggedTemplateExpression(node.Cast<ITaggedTemplateExpression>());

                case SyntaxKind.ParenthesizedExpression:
                    return CheckExpression(
                            node.Cast<IParenthesizedExpression>().Expression,
                            contextualMapper);

                case SyntaxKind.ClassExpression:
                    return CheckClassExpression(node.Cast<IClassExpression>());

                case SyntaxKind.FunctionExpression:
                case SyntaxKind.ArrowFunction:
                    return CheckFunctionExpressionOrObjectLiteralMethod(
                            node.Cast<IFunctionLikeDeclaration>(),
                            contextualMapper);

                case SyntaxKind.TypeOfExpression:
                    return CheckTypeOfExpression(node.Cast<ITypeOfExpression>());

                case SyntaxKind.TypeAssertionExpression:
                case SyntaxKind.AsExpression:
                    return CheckAssertion(node.Cast<IExpression>());

                case SyntaxKind.DeleteExpression:
                    return CheckDeleteExpression(node.Cast<IDeleteExpression>());

                case SyntaxKind.VoidExpression:
                    return CheckVoidExpression(node.Cast<IVoidExpression>());

                case SyntaxKind.AwaitExpression:
                    return CheckAwaitExpression(node.Cast<IAwaitExpression>());

                case SyntaxKind.PrefixUnaryExpression:
                    return CheckPrefixUnaryExpression(node.Cast<IPrefixUnaryExpression>());

                case SyntaxKind.PostfixUnaryExpression:
                    return CheckPostfixUnaryExpression(node.Cast<IPostfixUnaryExpression>());

                case SyntaxKind.BinaryExpression:
                    return CheckBinaryExpression(
                            node.Cast<IBinaryExpression>(),
                            contextualMapper);

                case SyntaxKind.ConditionalExpression:
                    return CheckConditionalExpression(
                            node.Cast<IConditionalExpression>(),
                            contextualMapper);

                case SyntaxKind.SpreadElementExpression:
                    return CheckSpreadElementExpression(
                            node.Cast<ISpreadElementExpression>(),
                            contextualMapper);

                case SyntaxKind.OmittedExpression:
                    return m_undefinedType;

                case SyntaxKind.YieldExpression:
                    return CheckYieldExpression(node.Cast<IYieldExpression>());
            }

            return m_unknownType;
        }

        // DECLARATION AND STATEMENT TYPE CHECKING
        private void CheckTypeParameter(ITypeParameterDeclaration node)
        {
            // Grammar Checking
            if (node.Expression != null)
            {
                GrammarErrorOnFirstToken(node.Expression, Errors.Type_expected);
            }

            CheckSourceElement(node.Constraint);
            GetConstraintOfTypeParameter(
                GetDeclaredTypeOfTypeParameter(GetSymbolOfNode(node)));

            if (m_produceDiagnostics)
            {
                CheckTypeNameIsReserved(node.Name, Errors.Type_parameter_name_cannot_be_0);
            }
        }

        private void CheckParameter(IParameterDeclaration node)
        {
            // Grammar checking
            // It is a SyntaxError if the Identifier "eval" or the Identifier "arguments" occurs as the
            // Identifier in a PropertySetParameterList of a PropertyAssignment that is contained in strict code
            // or if its FunctionBody is strict code(11.1.5).

            // Grammar checking
            if (!CheckGrammarDecorators(node))
            {
                CheckGrammarModifiers(node);
            }

            // HINT: Cast only works because runtime class implementing IParameterDeclaration also implements IVariableLikeDeclaration
            CheckVariableLikeDeclaration(node.Cast<IVariableLikeDeclaration>());

            var func = GetContainingFunction(node);

            if ((node.Flags & NodeFlags.AccessibilityModifier) != NodeFlags.None)
            {
                func = GetContainingFunction(node);
                if (!(func.Kind == SyntaxKind.Constructor && NodeIsPresent(func.Body)))
                {
                    Error(node, Errors.A_parameter_property_is_only_allowed_in_a_constructor_implementation);
                }
            }

            if (node.QuestionToken &&
                IsBindingPattern(node.Name) != null &&
                func.Body != null)
            {
                Error(node, Errors.A_binding_pattern_parameter_cannot_be_optional_in_an_implementation_signature);
            }

            // Only check rest parameter type if it's not a binding pattern. Since binding patterns are
            // not allowed in a rest parameter, we already have an error from CheckGrammarParameterList.
            if (node.DotDotDotToken &&
                IsBindingPattern(node.Name) == null &&
                !IsArrayType(GetTypeOfSymbol(node.Symbol)))
            {
                Error(node, Errors.A_rest_parameter_must_be_of_an_array_type);
            }
        }

        private static bool IsSyntacticallyValidGenerator(IFunctionLikeDeclaration node)
        {
            if (!node.AsteriskToken ||
                node.Body == null)
            {
                return false;
            }

            return node.Kind == SyntaxKind.MethodDeclaration ||
                   node.Kind == SyntaxKind.FunctionDeclaration ||
                   node.Kind == SyntaxKind.FunctionExpression;
        }

        private static int GetTypePredicateParameterIndex(NodeArray<IParameterDeclaration> parameterList, IIdentifier parameter)
        {
            if (parameterList != null)
            {
                for (var i = 0; i < parameterList.Length; i++)
                {
                    var param = parameterList[i];

                    if (param.Name.Kind == SyntaxKind.Identifier &&
                        param.Name.Cast<IIdentifier>().Text == parameter.Text)
                    {
                        return i;
                    }
                }
            }

            return -1;
        }

        private static bool IsInLegalParameterTypePredicatePosition(INode node)
        {
            switch (node.Parent.Kind)
            {
                case SyntaxKind.ArrowFunction:
                case SyntaxKind.CallSignature:
                case SyntaxKind.FunctionDeclaration:
                case SyntaxKind.FunctionExpression:
                case SyntaxKind.FunctionType:
                case SyntaxKind.MethodDeclaration:
                case SyntaxKind.MethodSignature:
                    return node.ResolveUnionType() == node.Parent.Cast<ISignatureDeclaration>().Type.ResolveUnionType();
            }

            return false;
        }

        private static bool IsInLegalThisTypePredicatePosition(INode node)
        {
            if (IsInLegalParameterTypePredicatePosition(node))
            {
                return true;
            }

            switch (node.Parent.Kind)
            {
                case SyntaxKind.PropertyDeclaration:
                    return node == node.Parent.Cast<IPropertyDeclaration>().Type;
                case SyntaxKind.PropertySignature:
                    return node == node.Parent.Cast<IPropertySignature>().Type;
                case SyntaxKind.GetAccessor:
                    return node == node.Parent.Cast<IGetAccessorDeclaration>().Type;
            }

            return false;
        }

        private void CheckSignatureDeclaration(IFunctionLikeDeclaration node)
        {
            // Grammar checking
            if (node.Kind == SyntaxKind.IndexSignature)
            {
                CheckGrammarIndexSignature(node.Cast<ISignatureDeclaration>());
            }

            // TODO: Remove this check in else-if when SyntaxKind.Construct is moved and ambient context is handled
            else if (node.Kind == SyntaxKind.FunctionType ||
                     node.Kind == SyntaxKind.FunctionDeclaration ||
                     node.Kind == SyntaxKind.ConstructorType ||
                     node.Kind == SyntaxKind.CallSignature ||
                     node.Kind == SyntaxKind.Constructor ||
                     node.Kind == SyntaxKind.ConstructSignature)
            {
                CheckGrammarFunctionLikeDeclaration(node.Cast<IFunctionLikeDeclaration>());
            }

            CheckTypeParameters(node.TypeParameters);

            ForEach(node.Parameters, p =>
            {
                CheckParameter(p);
            });

            if (node.Type != null)
            {
                if (node.Type.Kind == SyntaxKind.TypePredicate)
                {
                    var returnType = GetReturnTypeOfSignature(GetSignatureFromDeclaration(node));

                    if (returnType == null ||
                        (returnType.Flags & TypeFlags.PredicateType) == TypeFlags.None)
                    {
                        return;
                    }

                    var typePredicate = returnType.Cast<IPredicateType>().Predicate;
                    var typePredicateNode = node.Type.Cast<ITypePredicateNode>();

                    CheckSourceElement(typePredicateNode);

                    IIdentifierTypePredicate identifierTypePredicate = IsIdentifierTypePredicate(typePredicate);
                    if (identifierTypePredicate != null)
                    {
                        if (identifierTypePredicate.ParameterIndex >= 0)
                        {
                            if (node.Parameters[identifierTypePredicate.ParameterIndex.Value].DotDotDotToken)
                            {
                                Error(
                                    typePredicateNode.ParameterName,
                                    Errors.A_type_predicate_cannot_reference_a_rest_parameter);
                            }
                            else
                            {
                                CheckTypeAssignableTo(
                                    identifierTypePredicate.Type,
                                    GetTypeOfNode(node.Parameters[identifierTypePredicate.ParameterIndex.Value]),
                                    typePredicateNode.Type);
                            }
                        }
                        else if (!string.IsNullOrEmpty(identifierTypePredicate.ParameterName))
                        {
                            var hasReportedError = false;
                            foreach (var param in node.Parameters)
                            {
                                if (hasReportedError)
                                {
                                    break;
                                }

                                if (param.Name.Kind == SyntaxKind.ObjectBindingPattern ||
                                    param.Name.Kind == SyntaxKind.ArrayBindingPattern)
                                {
                                    Action<IBindingPattern> checkBindingPattern = null;
                                    checkBindingPattern = (IBindingPattern pattern) =>
                                    {
                                        foreach (var element in pattern.Elements)
                                        {
                                            // TODO: use string.Equals for string comparison in if-clause
                                            if (element.Name.Kind == SyntaxKind.Identifier &&
                                                element.Name.Cast<IIdentifier>().Text == identifierTypePredicate.ParameterName)
                                            {
                                                Error(
                                                    typePredicateNode.ParameterName,
                                                    Errors.A_type_predicate_cannot_reference_element_0_in_a_binding_pattern,
                                                    identifierTypePredicate.ParameterName);

                                                hasReportedError = true;
                                                break;
                                            }
                                            else if (element.Name.Kind == SyntaxKind.ArrayBindingPattern ||
                                                     element.Name.Kind == SyntaxKind.ObjectBindingPattern)
                                            {
                                                checkBindingPattern(element.Name.Cast<IBindingPattern>());
                                            }
                                        }
                                    };

                                    checkBindingPattern(param.Name.Cast<IBindingPattern>());
                                }
                            }

                            if (!hasReportedError)
                            {
                                Error(
                                    typePredicateNode.ParameterName,
                                    Errors.Cannot_find_parameter_0,
                                    identifierTypePredicate.ParameterName);
                            }
                        }
                    }
                }
                else
                {
                    CheckSourceElement(node.Type);
                }
            }

            if (m_produceDiagnostics)
            {
                CheckCollisionWithArgumentsInGeneratedCode(node);

                if (m_compilerOptions.NoImplicitAny.HasValue && m_compilerOptions.NoImplicitAny.Value &&
                    node.Type == null)
                {
                    switch (node.Kind)
                    {
                        case SyntaxKind.ConstructSignature:
                            Error(
                                node,
                                Errors.Construct_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type);
                            break;

                        case SyntaxKind.CallSignature:
                            Error(
                                node,
                                Errors.Call_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type);
                            break;
                    }
                }

                if (node.Type != null)
                {
                    if (m_languageVersion >= ScriptTarget.Es6 &&
                        IsSyntacticallyValidGenerator(node))
                    {
                        var returnType = GetTypeFromTypeNode(node.Type);
                        if (returnType == m_voidType)
                        {
                            Error(
                                node.Type,
                                Errors.A_generator_cannot_have_a_void_type_annotation);
                        }
                        else
                        {
                            var generatorElementType = GetElementTypeOfIterableIterator(returnType) ?? m_anyType;
                            var iterableIteratorInstantiation = CreateIterableIteratorType(generatorElementType);

                            // Naively, one could check that IterableIterator<any> is assignable to the return type annotation.
                            // However, that would not catch the error in the following case.
                            //
                            //    interface BadGenerator extends Iterable<number>, Iterator<string> { }
                            //    function* g(): BadGenerator { } // Iterable and Iterator have different types!
                            CheckTypeAssignableTo(
                                iterableIteratorInstantiation,
                                returnType,
                                node.Type);
                        }
                    }
                }
            }

            CheckSpecializedSignatureDeclaration(node);
        }

        private void CheckTypeForDuplicateIndexSignatures(INode node)
        {
            if (node.Kind == SyntaxKind.InterfaceDeclaration)
            {
                var nodeSymbol = GetSymbolOfNode(node);

                // in case of merging interface declaration it is possible that we'll enter this check procedure several times for every declaration
                // to prevent this run check only for the first declaration of a given kind
                if (nodeSymbol.DeclarationList.Count > 0 &&
                    nodeSymbol.DeclarationList[0].ResolveUnionType() != node.ResolveUnionType())
                {
                    return;
                }
            }

            // TypeScript 1.0 spec (April 2014)
            // 3.7.4: An object type can contain at most one string index signature and one numeric index signature.
            // 8.5: A class declaration can have at most one string index member declaration and one numeric index member declaration
            var indexSymbol = GetIndexSymbol(GetSymbolOfNode(node));
            if (indexSymbol != null)
            {
                var seenNumericIndexer = false;
                var seenStringIndexer = false;

                foreach (var decl in indexSymbol.DeclarationList)
                {
                    // TODO: Verify cast! - can we guarantee that decl is an ISignatureDeclaration?
                    var declaration = decl.Cast<ISignatureDeclaration>();
                    if (declaration.Parameters.Length == 1 &&
                        declaration.Parameters[0].Type != null)
                    {
                        switch (declaration.Parameters[0].Type.Kind)
                        {
                            case SyntaxKind.StringKeyword:
                                if (!seenStringIndexer)
                                {
                                    seenStringIndexer = true;
                                }
                                else
                                {
                                    Error(declaration, Errors.Duplicate_string_index_signature);
                                }

                                break;

                            case SyntaxKind.NumberKeyword:
                                if (!seenNumericIndexer)
                                {
                                    seenNumericIndexer = true;
                                }
                                else
                                {
                                    Error(declaration, Errors.Duplicate_number_index_signature);
                                }

                                break;
                        }
                    }
                }
            }
        }

        private void CheckPropertyDeclaration(/*HINT: IPropertyDeclaration*/ IDeclaration node)
        {
            Contract.Assert(node.Kind == SyntaxKind.PropertyDeclaration || node.Kind == SyntaxKind.PropertySignature);

            // Grammar checking
            if (!CheckGrammarDecorators(node))
            {
                if (!CheckGrammarModifiers(node))
                {
                    if (!CheckGrammarProperty(node))
                    {
                        CheckGrammarComputedPropertyName(node.Name);
                    }
                }
            }

            // HINT: This cast works because runtime class that implements IPropertyDeclaration or IPropertySignature also implements IVariableLikeDeclaration
            CheckVariableLikeDeclaration(node.Cast<IVariableLikeDeclaration>());
        }

        private void CheckMethodDeclaration(/*HINT: IMethodDeclaration*/ IFunctionLikeDeclaration node)
        {
            Contract.Assert(node.Kind == SyntaxKind.MethodDeclaration || node.Kind == SyntaxKind.MethodSignature);

            // Grammar checking
            if (!CheckGrammarMethod(node))
            {
                CheckGrammarComputedPropertyName(node.Name);
            }

            // Grammar checking for modifiers is done inside the function CheckGrammarFunctionLikeDeclaration
            CheckFunctionOrMethodDeclaration(node);

            // Abstract methods cannot have an implementation.
            // Extra checks are to avoid reporting multiple errors relating to the "abstractness" of the node.
            if ((node.Flags & NodeFlags.Abstract) != NodeFlags.None &&
                node.Body != null)
            {
                Error(
                    node,
                    Errors.Method_0_cannot_have_an_implementation_because_it_is_marked_abstract,
                    DeclarationNameToString(node.Name));
            }
        }

        private void CheckConstructorDeclaration(IConstructorDeclaration node)
        {
            // Grammar check on signature of constructor and modifier of the constructor is done in checkSignatureDeclaration function.
            CheckSignatureDeclaration(node);

            // Grammar check for checking only related to constructorDeclaration
            if (!CheckGrammarConstructorTypeParameters(node))
            {
                CheckGrammarConstructorTypeAnnotation(node);
            }

            CheckSourceElement(node.Body);

            var symbol = GetSymbolOfNode(node);
            var firstDeclaration = GetDeclarationOfKind(symbol, node.Kind);

            // Only type check the symbol once
            if (node.ResolveUnionType() == firstDeclaration.ResolveUnionType())
            {
                CheckFunctionOrConstructorSymbol(symbol);
            }

            // exit early in the case of signature - super checks are not relevant to them
            if (NodeIsMissing(node.Body))
            {
                return;
            }

            if (!m_produceDiagnostics)
            {
                return;
            }

            bool ContainsSuperCallAsComputedPropertyName(Func<INode, bool> containsSuperCallFunction, IDeclaration n)
            {
                return n.Name != null && containsSuperCallFunction(n.Name);
            }

            bool ContainsSuperCall(INode n)
            {
                if (IsSuperCallExpression(n))
                {
                    return true;
                }

                if (IsFunctionLike(n) != null)
                {
                    return false;
                }

                if (IsClassLike(n) != null)
                {
                    return Any(n.Cast<IClassLikeDeclaration>().Members, m => ContainsSuperCallAsComputedPropertyName(ContainsSuperCall, m));
                }

                return NodeWalker.ForEachChild(n, r => ContainsSuperCall(r));
            }

            void MarkThisReferencesAsErrors(INode n)
            {
                if (n.Kind == SyntaxKind.ThisKeyword)
                {
                    Error(n, Errors.This_cannot_be_referenced_in_current_location);
                }
                else if (n.Kind != SyntaxKind.FunctionExpression &&
                         n.Kind != SyntaxKind.FunctionDeclaration)
                {
                    NodeWalker.ForEachChild(n, string.Empty, (r, s) => { MarkThisReferencesAsErrors(r); });
                }
            }

            bool IsInstancePropertyWithInitializer(INode n)
            {
                return (n.Kind == SyntaxKind.PropertyDeclaration) &&
                       (n.Flags & NodeFlags.Static) == NodeFlags.None &&
                       (n.Cast<IPropertyDeclaration>().Initializer != null);
            }

            // TS 1.0 spec (April 2014): 8.3.2
            // Constructors of classes with no extends clause may not contain super calls, whereas
            // constructors of derived classes must contain at least one super call somewhere in their function body.
            var containingClassDecl = node.Parent.Cast<IClassDeclaration>();

            if (GetClassExtendsHeritageClauseElement(containingClassDecl) != null)
            {
                var containingClassSymbol = GetSymbolOfNode(containingClassDecl);
                var containingClassInstanceType = GetDeclaredTypeOfSymbol(containingClassSymbol).Cast<IInterfaceType>();
                var baseConstructorType = GetBaseConstructorTypeOfClass(containingClassInstanceType);

                if (ContainsSuperCall(node.Body))
                {
                    if (baseConstructorType == m_nullType)
                    {
                        Error(node, Errors.A_constructor_cannot_contain_a_super_call_when_its_class_extends_null);
                    }

                    // The first statement in the body of a constructor (excluding prologue directives) must be a super call
                    // if both of the following are true:
                    // - The containing class is a derived class.
                    // - The constructor declares parameter properties
                    //   or the containing class declares instance member variables with initializers.
                    var superCallShouldBeFirst =
                        ForEachUntil(node.Parent.Cast<IClassDeclaration>().Members, e => IsInstancePropertyWithInitializer(e)) ||
                        ForEachUntil(node.Parameters, p => (p.Flags & (NodeFlags.Public | NodeFlags.Private | NodeFlags.Protected)) != NodeFlags.None);

                    // Skip past any prologue directives to find the first statement
                    // to ensure that it was a super call.
                    if (superCallShouldBeFirst)
                    {
                        var statements = node.Body.Cast<IBlock>().Statements;
                        IExpressionStatement superCallStatement = null;

                        foreach (var statement in statements)
                        {
                            if (statement.Kind == SyntaxKind.ExpressionStatement &&
                                IsSuperCallExpression(statement.Cast<IExpressionStatement>().Expression))
                            {
                                superCallStatement = statement.Cast<IExpressionStatement>();
                                break;
                            }

                            if (!IsPrologueDirective(statement))
                            {
                                break;
                            }
                        }

                        if (superCallStatement == null)
                        {
                            Error(
                                node,
                                Errors.A_super_call_must_be_the_first_statement_in_the_constructor_when_a_class_contains_initialized_properties_or_has_parameter_properties);
                        }
                        else
                        {
                            // In such a required super call, it is a compile-time error for argument expressions to reference this.
                            MarkThisReferencesAsErrors(superCallStatement.Expression);
                        }
                    }
                }
                else if (baseConstructorType != m_nullType)
                {
                    Error(node, Errors.Constructors_for_derived_classes_must_contain_a_super_call);
                }
            }
        }

        private static bool IsSuperCallExpression(INode n)
        {
            return n.Kind == SyntaxKind.CallExpression &&
                   n.Cast<ICallExpression>().Expression.Kind == SyntaxKind.SuperKeyword;
        }

        private void CheckAccessorDeclaration(IAccessorDeclaration node)
        {
            if (m_produceDiagnostics)
            {
                // Grammar checking accessors
                if (!CheckGrammarFunctionLikeDeclaration(node))
                {
                    if (!CheckGrammarAccessor(node))
                    {
                        CheckGrammarComputedPropertyName(node.Name);
                    }
                }

                CheckDecorators(node);
                CheckSignatureDeclaration(node);

                if (node.Kind == SyntaxKind.GetAccessor)
                {
                    if (!IsInAmbientContext(node) &&
                        NodeIsPresent(node.Body) &&
                        (node.Flags & NodeFlags.HasImplicitReturn) != NodeFlags.None)
                    {
                        if ((node.Flags & NodeFlags.HasExplicitReturn) != NodeFlags.None)
                        {
                            if (m_compilerOptions.NoImplicitReturns.HasValue && m_compilerOptions.NoImplicitReturns.Value)
                            {
                                Error(node.Name, Errors.Not_all_code_paths_return_a_value);
                            }
                        }
                        else
                        {
                            Error(node.Name, Errors.A_get_accessor_must_return_a_value);
                        }
                    }
                }

                // Do not use hasDynamicName here, because that returns false for well known symbols.
                // We want to perform checkComputedPropertyName for all computed properties, including
                // well known symbols.
                if (node.Name.Kind == SyntaxKind.ComputedPropertyName)
                {
                    CheckComputedPropertyName(node.Name.Cast<IComputedPropertyName>());
                }

                if (!HasDynamicName(node))
                {
                    // TypeScript 1.0 spec (April 2014): 8.4.3
                    // Accessors for the same member name must specify the same accessibility.
                    var otherKind = node.Kind == SyntaxKind.GetAccessor ?
                                        SyntaxKind.SetAccessor :
                                        SyntaxKind.GetAccessor;

                    var otherAccessor = GetDeclarationOfKind(node.Symbol, otherKind).As<IAccessorDeclaration>();
                    if (otherAccessor != null)
                    {
                        if ((node.Flags & NodeFlags.AccessibilityModifier) != (otherAccessor.Flags & NodeFlags.AccessibilityModifier))
                        {
                            Error(node.Name, Errors.Getter_and_setter_accessors_do_not_agree_in_visibility);
                        }

                        var currentAccessorType = GetAnnotatedAccessorType(node);
                        var otherAccessorType = GetAnnotatedAccessorType(otherAccessor);

                        // TypeScript 1.0 spec (April 2014): 4.5
                        // If both accessors include type annotations, the specified types must be identical.
                        if (currentAccessorType != null && otherAccessorType != null)
                        {
                            if (!IsTypeIdenticalTo(currentAccessorType, otherAccessorType))
                            {
                                Error(node, Errors.Get_and_set_accessor_must_have_the_same_type);
                            }
                        }
                    }
                }

                GetTypeOfAccessors(GetSymbolOfNode(node));
            }

            if (node.Parent.Kind != SyntaxKind.ObjectLiteralExpression)
            {
                CheckSourceElement(node.Body);
            }
            else
            {
                CheckNodeDeferred(node);
            }
        }

        private void CheckAccessorDeferred(IAccessorDeclaration node)
        {
            CheckSourceElement(node.Body);
        }

        private void CheckMissingDeclaration(INode node)
        {
            CheckDecorators(node);
        }

        private bool CheckTypeArgumentConstraints(IReadOnlyList<ITypeParameter> typeParameters, NodeArray<ITypeNode> typeArgumentNodes)
        {
            List<IType> typeArguments = null;
            ITypeMapper mapper = null;
            var result = true;

            for (var i = 0; i < typeParameters.Count; i++)
            {
                var constraint = GetConstraintOfTypeParameter(typeParameters[i]);
                if (constraint != null)
                {
                    if (typeArguments == null)
                    {
                        typeArguments = Map(typeArgumentNodes, GetTypeFromTypeNode);
                        mapper = CreateTypeMapper(typeParameters, typeArguments);
                    }

                    var typeArgument = typeArguments[i];

                    result = result &&
                             CheckTypeAssignableTo(
                                typeArgument,
                                GetTypeWithThisArgument(InstantiateType(constraint, mapper), typeArgument),
                                typeArgumentNodes[i],
                                Errors.Type_0_does_not_satisfy_the_constraint_1);
                }
            }

            return result;
        }

        private void CheckTypeReferenceNode(/*HINT:TypeReferenceNode | ExpressionWithTypeArguments*/ ITypeNode node)
        {
            var typeArguments = node.Kind == SyntaxKind.TypeReference ?
                                    node.Cast<ITypeReferenceNode>().TypeArguments :
                                    node.Cast<IExpressionWithTypeArguments>().TypeArguments;

            CheckGrammarTypeArguments(node, typeArguments);

            var type = GetTypeFromTypeReference(node);

            if (type != m_unknownType && typeArguments != null)
            {
                // Do type argument local checks only if referenced type is successfully resolved
                ForEach(typeArguments, this, (e, @this) => { @this.CheckSourceElement(e); });

                if (m_produceDiagnostics)
                {
                    var symbol = GetResolvedSymbol(node);
                    var typeParameters =
                        (symbol.Flags & SymbolFlags.TypeAlias) != SymbolFlags.None
                        ? GetSymbolLinks(symbol).TypeParameters
                        : type.Cast<ITypeReference>().Target.LocalTypeParameters; // TODO: Verify cast

                    CheckTypeArgumentConstraints(typeParameters, typeArguments);
                }
            }

            // When the type is resolved (after the call to the GetTypeFromTypeReference)
            // We can check the location of the type and record file2file relation.
            RecordFile2FileRelationships(node, GetResolvedSymbol(node));
        }

        private void CheckTypeQuery(ITypeQueryNode node)
        {
            GetTypeFromTypeQueryNode(node);
        }

        private void CheckTypeLiteral(ITypeLiteralNode node)
        {
            ForEach(node.Members, this, (e, @this) => { @this.CheckSourceElement(e); });

            if (m_produceDiagnostics)
            {
                var type = GetTypeFromTypeLiteralOrFunctionOrConstructorTypeNode(node);

                CheckIndexConstraints(type);
                CheckTypeForDuplicateIndexSignatures(node);
            }
        }

        private void CheckArrayType(IArrayTypeNode node)
        {
            CheckSourceElement(node.ElementType);
        }

        private void CheckTupleType(ITupleTypeNode node)
        {
            // Grammar checking
            var hasErrorFromDisallowedTrailingComma = CheckGrammarForDisallowedTrailingComma(node.ElementTypes);

            if (!hasErrorFromDisallowedTrailingComma && node.ElementTypes.Length == 0)
            {
                GrammarErrorOnNode(node, Errors.A_tuple_type_element_list_cannot_be_empty);
            }

            ForEach(node.ElementTypes, this, (e, @this) =>
            {
                @this.CheckSourceElement(e);
            });
        }

        private void CheckUnionOrIntersectionType(IUnionOrIntersectionTypeNode node)
        {
            ForEach(node.Types, this, (e, @this) =>
            {
                @this.CheckSourceElement(e);
            });
        }

        private static bool IsPrivateWithinAmbient(INode node)
        {
            return (node.Flags & NodeFlags.Private) != NodeFlags.None &&
                   IsInAmbientContext(node);
        }

        private void CheckSpecializedSignatureDeclaration(/*HINT:ISignatureDeclaration*/IFunctionLikeDeclaration signatureDeclarationNode)
        {
            if (!m_produceDiagnostics)
            {
                return;
            }

            var signature = GetSignatureFromDeclaration(signatureDeclarationNode);
            if (!signature.HasStringLiterals)
            {
                return;
            }

            // TypeScript 1.0 spec (April 2014): 3.7.2.2
            // Specialized signatures are not permitted in conjunction with a function body
            if (NodeIsPresent(signatureDeclarationNode.Body))
            {
                Error(
                    signatureDeclarationNode,
                    Errors.A_signature_with_an_implementation_cannot_use_a_string_literal_type);

                return;
            }

            // TypeScript 1.0 spec (April 2014): 3.7.2.4
            // Every specialized call or construct signature in an object type must be assignable
            // to at least one non-specialized call or construct signature in the same object type
            IReadOnlyList<ISignature> signaturesToCheck = null;

            // Unnamed (call\construct) signatures in interfaces are inherited and not shadowed so examining just node symbol won't give complete answer.
            // Use declaring type to obtain full list of signatures.
            if (signatureDeclarationNode.Name == null &&
                signatureDeclarationNode.Parent != null &&
                signatureDeclarationNode.Parent.Kind == SyntaxKind.InterfaceDeclaration)
            {
                Contract.Assert(
                    signatureDeclarationNode.Kind == SyntaxKind.CallSignature ||
                                signatureDeclarationNode.Kind == SyntaxKind.ConstructSignature, null);

                var signatureKind = signatureDeclarationNode.Kind == SyntaxKind.CallSignature ?
                                        SignatureKind.Call :
                                        SignatureKind.Construct;

                var containingSymbol = GetSymbolOfNode(signatureDeclarationNode.Parent);
                var containingType = GetDeclaredTypeOfSymbol(containingSymbol);

                signaturesToCheck = GetSignaturesOfType(containingType, signatureKind);
            }
            else
            {
                signaturesToCheck = GetSignaturesOfSymbol(GetSymbolOfNode(signatureDeclarationNode));
            }

            foreach (var otherSignature in signaturesToCheck.AsStructEnumerable())
            {
                if (!otherSignature.HasStringLiterals &&
                    IsSignatureAssignableTo(
                        signature,
                        otherSignature,
                        /*ignoreReturnTypes*/ false))
                {
                    return;
                }
            }

            Error(
                signatureDeclarationNode,
                Errors.Specialized_overload_signature_is_not_assignable_to_any_non_specialized_signature);
        }

        private static NodeFlags GetEffectiveDeclarationFlags(INode n, NodeFlags flagsToCheck)
        {
            var flags = GetCombinedNodeFlags(n);

            // children of classes (even ambient classes) should not be marked as ambient or export
            // because those flags have no useful semantics there.
            if (n.Parent.Kind != SyntaxKind.InterfaceDeclaration &&
                n.Parent.Kind != SyntaxKind.ClassDeclaration &&
                n.Parent.Kind != SyntaxKind.ClassExpression &&
                IsInAmbientContext(n))
            {
                if ((flags & NodeFlags.Ambient) == NodeFlags.None)
                {
                    // It is nested in an ambient context, which means it is automatically exported
                    flags |= NodeFlags.Export;
                }

                flags |= NodeFlags.Ambient;
            }

            return flags & flagsToCheck;
        }

        // Nested function for CheckFunctionOrConstructorSymbol below
        private static IDeclaration GetCanonicalOverload(IReadOnlyList<IDeclaration> overloads, IFunctionLikeDeclaration implementation)
        {
            // Consider the canonical set of flags to be the flags of the bodyDeclaration or the first declaration
            // Error on all deviations from this canonical set of flags
            // The caveat is that if some overloads are defined in lib.D.ts, we don't want to
            // report the errors on those. To achieve this, we will say that the implementation is
            // the canonical signature only if it is in the same container as the first overload
            var implementationSharesContainerWithFirstOverload = implementation != null && implementation.Parent.ResolveUnionType() == overloads[0].Parent.ResolveUnionType();
            return implementationSharesContainerWithFirstOverload ? implementation : overloads[0];
        }

        // Nested function for CheckFunctionOrConstructorSymbol below
        private void CheckFlagAgreementBetweenOverloads(IReadOnlyList<IDeclaration> overloads, IFunctionLikeDeclaration implementation, NodeFlags flagsToCheck, NodeFlags someOverloadFlags, NodeFlags allOverloadFlags)
        {
            // Error if some overloads have a flag that is not shared by all overloads. To find the
            // deviations, we XOR someOverloadFlags with allOverloadFlags
            var someButNotAllOverloadFlags = someOverloadFlags ^ allOverloadFlags;
            if (someButNotAllOverloadFlags != NodeFlags.None)
            {
                var canonicalFlags = GetEffectiveDeclarationFlags(GetCanonicalOverload(overloads, implementation), flagsToCheck);

                ForEach(overloads, o =>
                {
                    var deviation = GetEffectiveDeclarationFlags(o, flagsToCheck) ^ canonicalFlags;
                    if ((deviation & NodeFlags.Export) != NodeFlags.None)
                    {
                        Error(o.Name, Errors.Overload_signatures_must_all_be_exported_or_not_exported);
                    }
                    else if ((deviation & NodeFlags.Ambient) != NodeFlags.None)
                    {
                        Error(o.Name, Errors.Overload_signatures_must_all_be_ambient_or_non_ambient);
                    }
                    else if ((deviation & (NodeFlags.Private | NodeFlags.Protected)) != NodeFlags.None)
                    {
                        Error(o.Name, Errors.Overload_signatures_must_all_be_public_private_or_protected);
                    }
                    else if ((deviation & NodeFlags.Abstract) != NodeFlags.None)
                    {
                        Error(o.Name, Errors.Overload_signatures_must_all_be_abstract_or_not_abstract);
                    }
                });
            }
        }

        // Nested function for CheckFunctionOrConstructorSymbol below
        private void CheckQuestionTokenAgreementBetweenOverloads(IReadOnlyList<IDeclaration> overloads, IFunctionLikeDeclaration implementation, bool someHaveQuestionToken, bool allHaveQuestionToken)
        {
            if (someHaveQuestionToken != allHaveQuestionToken)
            {
                var canonicalHasQuestionToken = HasQuestionToken(GetCanonicalOverload(overloads, implementation));
                ForEach(overloads, o =>
                {
                    var deviation = HasQuestionToken(o) != canonicalHasQuestionToken;
                    if (deviation)
                    {
                        Error(o.Name, Errors.Overload_signatures_must_all_be_optional_or_required);
                    }
                });
            }
        }

        // Nested function for CheckFunctionOrConstructorSymbol below
        private void ReportImplementationExpectedError(IFunctionLikeDeclaration node, bool isConstructor)
        {
            if (node.Name != null && NodeIsMissing(node.Name))
            {
                return;
            }

            var seen = false;
            var subsequentNode = NodeWalker.ForEachChild(node.Parent, c =>
            {
                if (seen)
                {
                    return c;
                }

                seen = c.ResolveUnionType() == node.ResolveUnionType();
                return null;
            });

            INode errorNode;

            // We may be here because of some extra junk between overloads that could not be parsed into a valid node.
            // In this case the subsequent node is not really consecutive (.pos != node.End), and we must ignore it here.
            if (subsequentNode != null && subsequentNode.Pos == node.End)
            {
                if (subsequentNode.Kind == node.Kind)
                {
                    errorNode = subsequentNode.Cast<IFunctionLikeDeclaration>().Name ?? subsequentNode;

                    // TODO: These are methods, so handle computed name case
                    if (node.Name != null &&
                        subsequentNode.Cast<IFunctionLikeDeclaration>().Name != null &&
                        node.Name.Cast<IIdentifier>().Text == subsequentNode.Cast<IFunctionLikeDeclaration>().Name.Text)
                    {
                        var reportError =
                            (node.Kind == SyntaxKind.MethodDeclaration || node.Kind == SyntaxKind.MethodSignature) &&
                            (node.Flags & NodeFlags.Static) != (subsequentNode.Flags & NodeFlags.Static);

                        // we can get here in two cases
                        // 1. mixed static and instance class members
                        // 2. something with the same name was defined before the set of overloads that prevents them from merging
                        // here we'll report error only for the first case since for second we should already report error in binder
                        if (reportError)
                        {
                            var diagnostic = (node.Flags & NodeFlags.Static) != NodeFlags.None ? Errors.Function_overload_must_be_static : Errors.Function_overload_must_not_be_static;
                            Error(errorNode, diagnostic);
                        }

                        return;
                    }
                    else if (NodeIsPresent(subsequentNode.Cast<IFunctionLikeDeclaration>().Body))
                    {
                        Error(errorNode, Errors.Function_implementation_name_must_be_0, DeclarationNameToString(node.Name));
                        return;
                    }
                }
            }

            errorNode = node.Name;
            errorNode = errorNode ?? node;

            if (isConstructor)
            {
                Error(errorNode, Errors.Constructor_implementation_is_missing);
            }
            else
            {
                // Report different errors regarding non-consecutive blocks of declarations depending on whether
                // the node in question is abstract.
                if ((node.Flags & NodeFlags.Abstract) != NodeFlags.None)
                {
                    Error(errorNode, Errors.All_declarations_of_an_abstract_method_must_be_consecutive);
                }
                else
                {
                    Error(errorNode, Errors.Function_implementation_is_missing_or_not_immediately_following_the_declaration);
                }
            }
        }

        private void CheckFunctionOrConstructorSymbol(ISymbol symbol)
        {
            if (!m_produceDiagnostics)
            {
                return;
            }

            NodeFlags flagsToCheck = NodeFlags.Export | NodeFlags.Ambient | NodeFlags.Private | NodeFlags.Protected | NodeFlags.Abstract;
            var someNodeFlags = NodeFlags.None;
            var allNodeFlags = flagsToCheck;
            var someHaveQuestionToken = false;
            var allHaveQuestionToken = true;
            var hasOverloads = false;
            IFunctionLikeDeclaration bodyDeclaration = null;
            IFunctionLikeDeclaration lastSeenNonAmbientDeclaration = null;
            IFunctionLikeDeclaration previousDeclaration = null;

            var declarations = symbol.DeclarationList;
            var isConstructor = (symbol.Flags & SymbolFlags.Constructor) != SymbolFlags.None;

            // when checking exported function declarations across modules check only duplicate implementations
            // names and consistency of modifiers are verified when we check local symbol
            var isExportSymbolInsideModule = symbol.Parent != null && (symbol.Parent.Flags & SymbolFlags.Module) != SymbolFlags.None;
            var duplicateFunctionDeclaration = false;
            var multipleConstructorImplementation = false;
            foreach (var current in declarations)
            {
                var node = current;
                var inAmbientContext = IsInAmbientContext(node);
                var inAmbientContextOrInterface = node.Parent.Kind == SyntaxKind.InterfaceDeclaration || node.Parent.Kind == SyntaxKind.TypeLiteral || inAmbientContext;
                if (inAmbientContextOrInterface)
                {
                    // check if declarations are consecutive only if they are non-ambient
                    // 1. ambient declarations can be interleaved
                    // i.e., this is legal
                    //     declare function foo();
                    //     declare function bar();
                    //     declare function foo();
                    // 2. mixing ambient and non-ambient declarations is a separate error that will be reported - do not want to report an extra one
                    previousDeclaration = null;
                }

                if (node.Kind == SyntaxKind.FunctionDeclaration || node.Kind == SyntaxKind.MethodDeclaration || node.Kind == SyntaxKind.MethodSignature || node.Kind == SyntaxKind.Constructor)
                {
                    var currentNodeFlags = GetEffectiveDeclarationFlags(node, flagsToCheck);
                    someNodeFlags |= currentNodeFlags;
                    allNodeFlags &= currentNodeFlags;
                    someHaveQuestionToken = someHaveQuestionToken || HasQuestionToken(node);
                    allHaveQuestionToken = allHaveQuestionToken && HasQuestionToken(node);

                    if (NodeIsPresent(node.Cast<IFunctionLikeDeclaration>().Body) && bodyDeclaration != null)
                    {
                        if (isConstructor)
                        {
                            multipleConstructorImplementation = true;
                        }
                        else
                        {
                            duplicateFunctionDeclaration = true;
                        }
                    }
                    else if (!isExportSymbolInsideModule && previousDeclaration != null && previousDeclaration.Parent.ResolveUnionType() == node.Parent.ResolveUnionType() && previousDeclaration.End != node.Pos)
                    {
                        ReportImplementationExpectedError(previousDeclaration, isConstructor);
                    }

                    if (NodeIsPresent(node.Cast<IFunctionLikeDeclaration>().Body))
                    {
                        if (bodyDeclaration == null)
                        {
                            bodyDeclaration = node.Cast<IFunctionLikeDeclaration>();
                        }
                    }
                    else
                    {
                        hasOverloads = true;
                    }

                    previousDeclaration = node.Cast<IFunctionLikeDeclaration>();

                    if (!inAmbientContextOrInterface)
                    {
                        lastSeenNonAmbientDeclaration = node.Cast<IFunctionLikeDeclaration>();
                    }
                }
            }

            if (multipleConstructorImplementation)
            {
                ForEach(declarations, this, (declaration, @this) =>
                {
                    @this.Error(declaration, Errors.Multiple_constructor_implementations_are_not_allowed);
                });
            }

            if (duplicateFunctionDeclaration)
            {
                ForEach(declarations, this, (declaration, @this) =>
                {
                    @this.Error(declaration.Name, Errors.Duplicate_function_implementation);
                });
            }

            // Abstract methods can't have an implementation -- in particular, they don't need one.
            if (!isExportSymbolInsideModule &&
                lastSeenNonAmbientDeclaration != null &&
                lastSeenNonAmbientDeclaration.Body == null &&
                (lastSeenNonAmbientDeclaration.Flags & NodeFlags.Abstract) == NodeFlags.None)
            {
                ReportImplementationExpectedError(lastSeenNonAmbientDeclaration, isConstructor);
            }

            if (hasOverloads)
            {
                CheckFlagAgreementBetweenOverloads(declarations, bodyDeclaration, flagsToCheck, someNodeFlags, allNodeFlags);
                CheckQuestionTokenAgreementBetweenOverloads(declarations, bodyDeclaration, someHaveQuestionToken, allHaveQuestionToken);

                if (bodyDeclaration != null)
                {
                    var signatures = GetSignaturesOfSymbol(symbol);
                    var bodySignature = GetSignatureFromDeclaration(bodyDeclaration);

                    // If the implementation signature has string literals, we will have reported an error in
                    // checkSpecializedSignatureDeclaration
                    if (!bodySignature.HasStringLiterals)
                    {
                        // TypeScript 1.0 spec (April 2014): 6.1
                        // If a function declaration includes overloads, the overloads determine the call
                        // signatures of the type given to the function object
                        // and the function implementation signature must be assignable to that type
                        //
                        // TypeScript 1.0 spec (April 2014): 3.8.4
                        // Note that specialized call and construct signatures (section 3.7.2.4) are not significant when determining assignment compatibility
                        // Consider checking against specialized signatures too. Not doing so creates a type hole:
                        //
                        // function g(x: "hi", y: boolean);
                        // function g(x: string, y: {});
                        // function g(x: string, y: string) { }
                        //
                        // The implementation is completely unrelated to the specialized signature, yet we do not check this.
                        foreach (var signature in signatures)
                        {
                            if (!signature.HasStringLiterals && !IsImplementationCompatibleWithOverload(bodySignature, signature))
                            {
                                Error(signature.Declaration, Errors.Overload_signature_is_not_compatible_with_function_implementation);
                                break;
                            }
                        }
                    }
                }
            }
        }

        private void CheckExportsOnMergedDeclarations(INode node)
        {
            if (!m_produceDiagnostics)
            {
                return;
            }

            if (node.Kind == SyntaxKind.ModuleDeclaration && m_isScriptFile)
            {
                // Skipping the check for namespaces for DScript files.
                // DScript has its own rules around namespace visibility:
                // visibility of the namespace can be explicit but could be inferred based on a content.
                // I.e. if a namepsace has export const x = 42;
                // the namespace visibility is 'exported' (i.e. internal).
                // If the namesapce has a public value, then the visbility is public.
                // This function checks that the visbility for all definition is consistent.
                // But because a namespace visibility can be implicit this check could be very confusing.
                return;
            }

            // if localISymbol is defined on node then node itself is exported - check is required
            var symbol = node.LocalSymbol;
            if (symbol == null)
            {
                // local symbol is null => this declaration is non-exported.
                // however symbol might contain other declarations that are exported
                symbol = GetSymbolOfNode(node);
                if ((symbol.Flags & SymbolFlagsHelper.Export()) == SymbolFlags.None)
                {
                    // this is a pure local symbol (all declarations are non-exported) - no need to check anything
                    return;
                }
            }

            // run the check only for the first declaration in the list
            if (GetDeclarationOfKind(symbol, node.Kind).ResolveUnionType() != node.ResolveUnionType())
            {
                return;
            }

            // TODO:ST: consider changing the following logic based on explicit domain concepts (like by adding explicit visibility enum and use it)
            // instead on relying on the flags.

            // DScript specific. Since merging for internal values can happen across files, we want to check the declarations
            // that the merged symbol contains together with the local ones.
            var declarations = new HashSet<IDeclaration>(symbol.DeclarationList);
            declarations.UnionWith(GetSymbolOfNode(node).DeclarationList);

            // we use SymbolFlags.ExportValue, SymbolFlags.ExportType and SymbolFlags.ExportNamespace
            // to denote disjoint declarationSpaces (without making new enum type).
            // DScript-specific. We have another category of exported public declarations, which is a subset of exported declarations
            var exportedPublicDeclarationSpaces = SymbolFlags.None;
            var exportedNonPublicDeclarationSpaces = SymbolFlags.None;
            var exportedDeclarationSpaces = SymbolFlags.None;
            var nonExportedDeclarationSpaces = SymbolFlags.None;
            var defaultExportedDeclarationSpaces = SymbolFlags.None;
            foreach (var d in declarations)
            {
                var declarationSpaces = GetDeclarationSpaces(d);
                var effectiveDeclarationFlags = GetEffectiveDeclarationFlags(d, NodeFlags.Export | NodeFlags.Default | NodeFlags.ScriptPublic);

                if ((effectiveDeclarationFlags & NodeFlags.Export) != NodeFlags.None)
                {
                    if ((effectiveDeclarationFlags & NodeFlags.Default) != NodeFlags.None)
                    {
                        defaultExportedDeclarationSpaces |= declarationSpaces;
                    }
                    else
                    {
                        // DScript: a public value is always exported, so we check it here.
                        if ((effectiveDeclarationFlags & NodeFlags.ScriptPublic) != NodeFlags.None)
                        {
                            exportedPublicDeclarationSpaces |= declarationSpaces;
                        }
                        else
                        {
                            exportedNonPublicDeclarationSpaces |= declarationSpaces;
                        }

                        exportedDeclarationSpaces |= declarationSpaces;
                    }
                }
                else
                {
                    nonExportedDeclarationSpaces |= declarationSpaces;
                }
            }

            // Spaces for anything not declared a 'default export'.
            var nonDefaultExportedDeclarationSpaces = exportedDeclarationSpaces | nonExportedDeclarationSpaces;
            var commonDeclarationSpacesForExportsAndLocals = exportedDeclarationSpaces & nonExportedDeclarationSpaces;
            var commonDeclarationSpacesForDefaultAndNonDefault = defaultExportedDeclarationSpaces & nonDefaultExportedDeclarationSpaces;
            var commonDeclarationSpacesForExportedPublicAndExportedNonPublic = exportedNonPublicDeclarationSpaces & exportedPublicDeclarationSpaces;

            if (commonDeclarationSpacesForExportsAndLocals != SymbolFlags.None ||
                commonDeclarationSpacesForDefaultAndNonDefault != SymbolFlags.None ||
                commonDeclarationSpacesForExportedPublicAndExportedNonPublic != SymbolFlags.None)
            {
                // declaration spaces for exported and non-exported declarations intersect
                foreach (var d in symbol.DeclarationList)
                {
                    var declarationSpaces = GetDeclarationSpaces(d);

                    // Only error on the declarations that contributed to the intersecting spaces.
                    if ((declarationSpaces & commonDeclarationSpacesForDefaultAndNonDefault) != SymbolFlags.None)
                    {
                        Error(d.Name, Errors.Merged_declaration_0_cannot_include_a_default_export_declaration_Consider_adding_a_separate_export_default_0_declaration_instead, DeclarationNameToString(d.Name));
                    }
                    else if ((declarationSpaces & commonDeclarationSpacesForExportsAndLocals) != SymbolFlags.None)
                    {
                        Error(d.Name, Errors.Individual_declarations_in_merged_declaration_0_must_be_all_exported_or_all_local, DeclarationNameToString(d.Name));
                    }
                    else if ((declarationSpaces & commonDeclarationSpacesForExportedPublicAndExportedNonPublic) != SymbolFlags.None)
                    {
                        Error(d.Name, Errors.Individual_exported_declarations_in_merged_declaration_0_must_be_all_public_or_all_non_public, DeclarationNameToString(d.Name));
                    }
                }
            }
        }

        private SymbolFlags GetDeclarationSpaces(IDeclaration decl)
        {
            switch (decl.Kind)
            {
                case SyntaxKind.InterfaceDeclaration:
                    return SymbolFlags.ExportType;
                case SyntaxKind.ModuleDeclaration:
                    return decl.Cast<IModuleDeclaration>().Name.Kind == SyntaxKind.StringLiteral || Binder.GetModuleInstanceState(decl) != ModuleInstanceState.NonInstantiated
                        ? SymbolFlags.ExportNamespace | SymbolFlags.ExportValue
                        : SymbolFlags.ExportNamespace;
                case SyntaxKind.ClassDeclaration:
                case SyntaxKind.EnumDeclaration:
                    return SymbolFlags.ExportType | SymbolFlags.ExportValue;
                case SyntaxKind.ImportEqualsDeclaration:
                    var result = SymbolFlags.None;
                    var target = ResolveAlias(GetSymbolOfNode(decl));
                    foreach (var d in target.DeclarationList)
                    {
                        result |= GetDeclarationSpaces(d);
                    }

                    return result;
                default:
                    return SymbolFlags.ExportValue;
            }
        }

        private IType CheckNonThenableType(IType type, INode location, IDiagnosticMessage message)
        {
            type = GetWidenedType(type);
            if (!IsTypeAny(type) && IsTypeAssignableTo(type, m_getGlobalThenableType()))
            {
                if (location != null)
                {
                    if (message == null)
                    {
                        message = Errors.Operand_for_await_does_not_have_a_valid_callable_then_member;
                    }

                    Error(location, message);
                }

                return m_unknownType;
            }

            return type;
        }

        /// <summary>
        /// Gets the "promised type" of a promise.
        /// @param type The type of the promise.
        /// @remarks The "promised type" of a type is the type of the "value" parameter of the "onfulfilled" callback.
        /// </summary>
        private IType GetPromisedType(IType promise)
        {
            // { // promise
            //      then( // thenFunction
            //          onfulfilled: ( // onfulfilledParameterType
            //              value: T // valueParameterType
            //          ) => any
            //      ): any;
            //  }
            if ((promise.Flags & TypeFlags.Any) != TypeFlags.None)
            {
                return null;
            }

            if ((promise.Flags & TypeFlags.Reference) != TypeFlags.None &&
                promise.As<ITypeReference>()?.Target == m_tryGetGlobalPromiseType())
            {
                return promise.Cast<ITypeReference>().TypeArguments[0];
            }

            var globalPromiseLikeType = m_getInstantiatedGlobalPromiseLikeType();
            if (globalPromiseLikeType == m_emptyObjectType || !IsTypeAssignableTo(promise, globalPromiseLikeType))
            {
                return null;
            }

            var thenFunction = GetTypeOfPropertyOfType(promise, "then");
            if (thenFunction != null && (thenFunction.Flags & TypeFlags.Any) != TypeFlags.None)
            {
                return null;
            }

            var thenSignatures = thenFunction != null ? GetSignaturesOfType(thenFunction, SignatureKind.Call) : s_emptySignatureList;
            if (thenSignatures.Count == 0)
            {
                return null;
            }

            var onfulfilledParameterType = GetUnionType(thenSignatures.Map(this, (s, @this) => @this.GetTypeOfFirstParameterOfSignature(s)));
            if ((onfulfilledParameterType.Flags & TypeFlags.Any) != TypeFlags.None)
            {
                return null;
            }

            var onfulfilledParameterSignatures = GetSignaturesOfType(onfulfilledParameterType, SignatureKind.Call);
            if (onfulfilledParameterSignatures.Count == 0)
            {
                return null;
            }

            var valueParameterType = GetUnionType(onfulfilledParameterSignatures.Map(this, (s, @this) => @this.GetTypeOfFirstParameterOfSignature(s)));
            return valueParameterType;
        }

        private IType GetTypeOfFirstParameterOfSignature(ISignature signature)
        {
            return GetTypeAtPosition(signature, 0);
        }

        /// <summary>
        /// Gets the "awaited type" of a type.
        /// @param type The type to await.
        /// @remarks The "awaited type" of an expression is its "promised type" if the expression is a
        /// Promise-like type; otherwise, it is the type of the expression. This is used to reflect
        /// The runtime behavior of the `await` keyword.
        /// </summary>
        private IType GetAwaitedType(IType type)
        {
            return CheckAwaitedType(type, /*location*/ null, /*message*/ null);
        }

        private sealed class CheckAwaitedTypeClosure
        {
            private readonly Checker m_checker;
            private readonly INode m_location;
            private readonly IDiagnosticMessage m_message;

            public CheckAwaitedTypeClosure(Checker checker, INode location, IDiagnosticMessage message)
            {
                m_checker = checker;
                m_location = location;
                m_message = message;
            }

            public IType CheckAwaitedTypeWorker(IType type)
            {
                if ((type.Flags & TypeFlags.Union) != TypeFlags.None)
                {
                    List<IType> types = new List<IType>();
                    foreach (var constituentType in type.Cast<IUnionType>().Types)
                    {
                        types.Add(CheckAwaitedTypeWorker(constituentType));
                    }

                    return m_checker.GetUnionType(types);
                }
                else
                {
                    var promisedType = m_checker.GetPromisedType(type);
                    if (promisedType == null)
                    {
                        // The type was not a PromiseLike, so it could not be unwrapped any further.
                        // As long as the type does not have a callable "then" property, it is
                        // safe to return the type; otherwise, an error will have been reported in
                        // the call to checkNonThenableType and we will return m_unknownType.
                        //
                        // An example of a non-promise "thenable" might be:
                        //
                        //  await { then(): void {} }
                        //
                        // The "thenable" does not match the minimal definition for a PromiseLike. When
                        // a Promise/A+-compatible or ES6 promise tries to adopt this value, the promise
                        // will never settle. We treat this as an error to help flag an early indicator
                        // of a runtime problem. If the user wants to return this value from an async
                        // function, they would need to wrap it in some other value. If they want it to
                        // be treated as a promise, they can cast to <any>.
                        return m_checker.CheckNonThenableType(type, m_location, m_message);
                    }
                    else
                    {
                        if (type.Id == promisedType.Id || m_checker.m_awaitedTypeStack.IndexOf(promisedType.Id) >= 0)
                        {
                            // We have a bad actor in the form of a promise whose promised type is
                            // the same promise type, or a mutually recursive promise. Return the
                            // unknown type as we cannot guess the shape. If this were the actual
                            // case in the JavaScript, this Promise would never resolve.
                            //
                            // An example of a bad actor with a singly-recursive promise type might
                            // be:
                            //
                            //  interface BadPromise {
                            //      then(
                            //          onfulfilled: (value: BadPromise) => any,
                            //          onrejected: (error: any) => any): BadPromise;
                            //  }
                            //
                            // The above interface will pass the PromiseLike check, and return a
                            // promised type of `BadPromise`. Since this is a self reference, we
                            // don't want to keep recursing ad infinitum.
                            //
                            // An example of a bad actor in the form of a mutually-recursive
                            // promise type might be:
                            //
                            //  interface BadPromiseA {
                            //      then(
                            //          onfulfilled: (value: BadPromiseB) => any,
                            //          onrejected: (error: any) => any): BadPromiseB;
                            //  }
                            //
                            //  interface BadPromiseB {
                            //      then(
                            //          onfulfilled: (value: BadPromiseA) => any,
                            //          onrejected: (error: any) => any): BadPromiseA;
                            //  }
                            if (m_location != null)
                            {
                                m_checker.Error(
                                    m_location,
                                    Errors.Zero_is_referenced_directly_or_indirectly_in_the_fulfillment_callback_of_its_own_then_method,
                                    m_checker.SymbolToString(type.Symbol));
                            }

                            return m_checker.m_unknownType;
                        }

                        // Keep track of the type we're about to unwrap to avoid bad recursive promise types.
                        // See the comments above for more information.
                        m_checker.m_awaitedTypeStack.Add(type.Id);
                        var awaitedType = CheckAwaitedTypeWorker(promisedType);
                        m_checker.m_awaitedTypeStack.Pop();
                        return awaitedType;
                    }
                }
            }
        }

        private IType CheckAwaitedType(IType type, INode location = null, IDiagnosticMessage message = null)
        {
            var closure = new CheckAwaitedTypeClosure(this, location, message);
            return closure.CheckAwaitedTypeWorker(type);
        }

        /// <summary>
        /// Checks the return type of an async function to ensure it is a compatible
        /// Promise implementation.
        /// </summary>
        /// <param name="node">The signature to check</param>
        /// <returns>The return type for the function</returns>
        /// <remarks>
        /// This checks that an async function has a valid Promise-compatible return type,
        /// and returns the *awaited type* of the promise. An async function has a valid
        /// Promise-compatible return type if the resolved value of the return type has a
        /// construct signature that takes in an `initializer` function that in turn supplies
        /// a `resolve` function as one of its arguments and results in an object with a
        /// callable `then` signature.
        /// </remarks>
        private IType CheckAsyncFunctionReturnType(IFunctionLikeDeclaration node)
        {
            var globalPromiseConstructorLikeType = m_getGlobalPromiseConstructorLikeType();
            if (globalPromiseConstructorLikeType == m_emptyObjectType)
            {
                // If we couldn't resolve the global PromiseConstructorLike type we cannot verify
                // compatibility with __awaiter.
                return m_unknownType;
            }

            // As part of our emit for an async function, we will need to emit the entity name of
            // the return type annotation as an expression. To meet the necessary runtime semantics
            // for __awaiter, we must also check that the type of the declaration (e.g. the static
            // side or "constructor" of the promise type) is compatible `PromiseConstructorLike`.
            //
            // An example might be (from lib.es6.d.ts):
            //
            //  interface Promise<T> { ... }
            //  interface PromiseConstructor {
            //      new <T>(...): Promise<T>;
            //  }
            //  declare var Promise: PromiseConstructor;
            //
            // When an async function declares a return type annotation of `Promise<T>`, we
            // need to get the type of the `Promise` variable declaration above, which would
            // be `PromiseConstructor`.
            //
            // The same case applies to a class:
            //
            //  declare class Promise<T> {
            //      constructor(...);
            //      then<U>(...): Promise<U>;
            //  }
            //
            // When we get the type of the `Promise` symbol here, we get the type of the static
            // side of the `Promise` class, which would be `{ new <T>(...): Promise<T> }`.
            var promiseType = GetTypeFromTypeNode(node.Type);
            if (promiseType == m_unknownType && m_compilerOptions.IsolatedModules.HasValue && m_compilerOptions.IsolatedModules.Value)
            {
                // If we are compiling with isolatedModules, we may not be able to resolve the
                // type as a value. As such, we will just return m_unknownType;
                return m_unknownType;
            }

            var promiseConstructor = GetResolvedSymbol(node.Type);
            if (promiseConstructor == null || !SymbolIsValue(promiseConstructor))
            {
                var typeName = promiseConstructor != null
                    ? SymbolToString(promiseConstructor)
                    : TypeToString(promiseType);
                Error(node, Errors.Type_0_is_not_a_valid_async_function_return_type, typeName);
                return m_unknownType;
            }

            // If the Promise constructor, resolved locally, is an alias symbol we should mark it as referenced.
            CheckReturnTypeAnnotationAsExpression(node);

            // Validate the promise constructor type.
            var promiseConstructorType = GetTypeOfSymbol(promiseConstructor);
            if (!CheckTypeAssignableTo(promiseConstructorType, globalPromiseConstructorLikeType, node, Errors.Type_0_is_not_a_valid_async_function_return_type))
            {
                return m_unknownType;
            }

            // Verify there is no local declaration that could collide with the promise constructor.
            var promiseName = GetEntityNameFromTypeNode(node.Type);
            var promiseNameOrNamespaceRoot = GetFirstIdentifier(promiseName);
            var rootSymbol = GetSymbol(node.Locals, promiseNameOrNamespaceRoot.Text, SymbolFlags.Value);
            if (rootSymbol != null)
            {
                Error(
                    rootSymbol.ValueDeclaration,
                    Errors.Duplicate_identifier_0_Compiler_uses_declaration_1_to_support_async_functions,
                    promiseNameOrNamespaceRoot.Text,
                    GetFullyQualifiedName(promiseConstructor));

                return m_unknownType;
            }

            // Get and return the awaited type of the return type.
            return CheckAwaitedType(promiseType, node, Errors.An_async_function_or_method_must_have_a_valid_awaitable_return_type);
        }

        private void CheckScriptPublicDecorator(IDecorator decorator)
        {
            var decoratee = decorator.Parent;

            if (!m_host.IsOwnedByImplicitReferenceModule(decorator.GetSourceFile().FileName))
            {
                Error(decorator, Errors.Public_declarations_are_only_allowed_in_modules_with_implicit_reference_semantics);
            }

            if (!decoratee.IsTopLevelOrNamespaceLevelDeclaration())
            {
                Error(decorator, Errors.Only_top_level_declarations_can_be_made_public);
            }

            if (decoratee.Kind != SyntaxKind.ExportDeclaration && (decoratee.Flags & NodeFlags.Export) == NodeFlags.None)
            {
                Error(decorator, Errors.Public_declarations_have_to_be_exported);
            }

            // Public decorators are valid just in a few places, the list is smaller than the set of nodes that supports ambient decorators.
            switch (decoratee.Kind)
            {
                case SyntaxKind.InterfaceDeclaration:
                case SyntaxKind.VariableStatement:
                case SyntaxKind.FunctionDeclaration:
                case SyntaxKind.EnumDeclaration:
                case SyntaxKind.TypeAliasDeclaration:
                case SyntaxKind.ExportDeclaration:
                    break;
                default:
                    {
                        Error(decorator, Errors.A_public_decorator_is_not_allowed_here);
                        break;
                    }
            }
        }

        /// <summary>
        /// Check a decorator
        /// </summary>
        private void CheckDecorator(IDecorator node)
        {
            if (node.IsScriptPublicDecorator())
            {
                CheckScriptPublicDecorator(node);
                return;
            }

            var signature = GetResolvedSignature(node);
            var returnType = GetReturnTypeOfSignature(signature);
            if ((returnType.Flags & TypeFlags.Any) != TypeFlags.None)
            {
                return;
            }

            IType expectedReturnType = null;
            var headMessage = GetDiagnosticHeadMessageForDecoratorResolution(node);
            DiagnosticMessageChain errorInfo = null;
            switch (node.Parent.Kind)
            {
                case SyntaxKind.ClassDeclaration:
                    var classSymbol = GetSymbolOfNode(node.Parent);
                    var classConstructorType = GetTypeOfSymbol(classSymbol);
                    expectedReturnType = GetUnionType(new List<IType>() { classConstructorType, m_voidType });
                    break;

                case SyntaxKind.Parameter:
                    expectedReturnType = m_voidType;
                    errorInfo = ChainDiagnosticMessages(
                        errorInfo,
                        Errors.The_return_type_of_a_parameter_decorator_function_must_be_either_void_or_any);
                    break;

                case SyntaxKind.PropertyDeclaration:
                    expectedReturnType = m_voidType;
                    errorInfo = ChainDiagnosticMessages(
                        errorInfo,
                        Errors.The_return_type_of_a_property_decorator_function_must_be_either_void_or_any);
                    break;

                case SyntaxKind.MethodDeclaration:
                case SyntaxKind.GetAccessor:
                case SyntaxKind.SetAccessor:
                    var methodType = GetTypeOfNode(node.Parent);
                    var descriptorType = CreateTypedPropertyDescriptorType(methodType);
                    expectedReturnType = GetUnionType(new List<IType>() { descriptorType, m_voidType });
                    break;
            }

            // DS: for DScript expectedReturn type could be null! In this case, skipping the other checks!
            if (expectedReturnType != null)
            {
                CheckTypeAssignableTo(
                    returnType,
                    expectedReturnType,
                    node,
                    headMessage,
                    errorInfo);
            }
        }

        /// <summary>
        /// Checks a type reference node as an expression.
        /// </summary>
        private void CheckTypeNodeAsExpression(ITypeNode node)
        {
            // When we are emitting type metadata for decorators, we need to try to check the type
            // as if it were an expression so that we can emit the type in a value position when we
            // serialize the type metadata.
            if (node != null && node.Kind == SyntaxKind.TypeReference)
            {
                var root = GetFirstIdentifier(node.Cast<ITypeReferenceNode>().TypeName);
                var meaning = root.Parent.Kind == SyntaxKind.TypeReference ? SymbolFlags.Type : SymbolFlags.Namespace;

                // Resolve type so we know which symbol is referenced
                var rootSymbol = ResolveName(root, root.Text, meaning | SymbolFlags.Alias, /*nameNotFoundMessage*/ null, /*nameArg*/ (string)null);

                // Resolved symbol is alias
                if (rootSymbol != null && (rootSymbol.Flags & SymbolFlags.Alias) != SymbolFlags.None)
                {
                    var aliasTarget = ResolveAlias(rootSymbol);

                    // If alias has value symbol - mark alias as referenced
                    if ((aliasTarget.Flags & SymbolFlags.Value) != SymbolFlags.None && !IsConstEnumOrConstEnumOnlyModule(ResolveAlias(rootSymbol)))
                    {
                        MarkAliasSymbolAsReferenced(rootSymbol);
                    }
                }
            }
        }

        /// <summary>
        /// Checks the type annotation of an accessor declaration or property declaration as
        /// an expression if it is a type reference to a type with a value declaration.
        /// </summary>
        private void CheckTypeAnnotationAsExpression(IVariableLikeDeclaration node)
        {
            // HINT: This cast only works because the runtime class that implements IVariableLikeDeclaration also implements IPropertyDeclaration
            CheckTypeNodeAsExpression(node.Cast<IPropertyDeclaration>().Type);
        }

        private void CheckReturnTypeAnnotationAsExpression(IFunctionLikeDeclaration node)
        {
            CheckTypeNodeAsExpression(node.Type);
        }

        /// <summary>
        /// Checks the type annotation of the parameters of a function/method or the constructor of a class as expressions
        /// </summary>
        private void CheckParameterTypeAnnotationsAsExpressions(IFunctionLikeDeclaration node)
        {
            // ensure all type annotations with a value declaration are checked as an expression
            foreach (var parameter in node.Parameters)
            {
                // HINT: This cast only works because the runtime class that implements IVariableLikeDeclaration also implements IParameterDeclaration
                CheckTypeAnnotationAsExpression(parameter.Cast<IVariableLikeDeclaration>());
            }
        }

        /// <summary>
        /// Check the decorators of a node
        /// </summary>
        private void CheckDecorators(INode node)
        {
            if (node.Decorators == null)
            {
                return;
            }

            // skip this check for nodes that cannot have decorators. These should have already had an error reported by
            // CheckGrammarDecorators.
            if (!NodeCanBeDecorated(node, m_isScriptFile))
            {
                return;
            }

            // DS: Decorators are supported for all DScript files all the time!
            if (!m_isScriptFile && (!m_compilerOptions.ExperimentalDecorators.HasValue || !m_compilerOptions.ExperimentalDecorators.Value))
            {
                Error(node, Errors.Experimental_support_for_decorators_is_a_feature_that_is_subject_to_change_in_a_future_release_Specify_experimentalDecorators_to_remove_this_warning);
            }

            if (m_compilerOptions.EmitDecoratorMetadata.HasValue && m_compilerOptions.EmitDecoratorMetadata.Value)
            {
                // we only need to perform these checks if we are emitting serialized type metadata for the target of a decorator.
                switch (node.Kind)
                {
                    case SyntaxKind.ClassDeclaration:
                        var constructor = GetFirstConstructorWithBody(node.Cast<IClassDeclaration>());
                        if (constructor != null)
                        {
                            CheckParameterTypeAnnotationsAsExpressions(constructor);
                        }

                        break;

                    case SyntaxKind.MethodDeclaration:
                    case SyntaxKind.GetAccessor:
                    case SyntaxKind.SetAccessor:
                        CheckParameterTypeAnnotationsAsExpressions(node.Cast<IFunctionLikeDeclaration>());
                        CheckReturnTypeAnnotationAsExpression(node.Cast<IFunctionLikeDeclaration>());
                        break;

                    case SyntaxKind.PropertyDeclaration:
                    case SyntaxKind.Parameter:
                        // HINT: This cast only works because the runtime class that implements IVariableLikeDeclaration also implements IPropertyDeclaration/IParameterDeclaration
                        CheckTypeAnnotationAsExpression(node.Cast<IVariableLikeDeclaration>());
                        break;
                }
            }

            var perFileState = GetPerFileState(node);

            perFileState.EmitDecorate = true;
            if (node.Kind == SyntaxKind.Parameter)
            {
                perFileState.EmitParam = true;
            }

            ForEach(node.Decorators, this, (d, @this) =>
            {
                @this.CheckDecorator(d);
            });
        }

        private void CheckFunctionDeclaration(IFunctionDeclaration node)
        {
            if (m_produceDiagnostics)
            {
                CheckFunctionOrMethodDeclaration(node);
                CheckGrammarForGenerator(node);

                CheckCollisionWithCapturedSuperVariable(node, node.Name);
                CheckCollisionWithCapturedThisVariable(node, node.Name);
                CheckCollisionWithRequireExportsInGeneratedCode(node, node.Name);
            }
        }

        private void CheckFunctionOrMethodDeclaration(/*HINT:FunctionDeclaration | MethodDeclaration*/ IFunctionLikeDeclaration node)
        {
            CheckDecorators(node);
            CheckSignatureDeclaration(node);
            var isAsync = IsAsyncFunctionLike(node);
            if (isAsync)
            {
                GetPerFileState(node).EmitAwaiter = true;
            }

            // Do not use hasDynamicName here, because that returns false for well known symbols.
            // We want to perform CheckComputedPropertyName for all computed properties, including
            // well known symbols.
            if (node.Name != null && node.Name.Kind == SyntaxKind.ComputedPropertyName)
            {
                // This check will account for methods in class/interface declarations,
                // as well as accessors in classes/object literals
                CheckComputedPropertyName(node.Name.Cast<IComputedPropertyName>());
            }

            if (!HasDynamicName(node))
            {
                // first we want to check the local symbol that contain this declaration
                // - if node.LocalSymbol != null - this is current declaration is exported and localSymbol points to the local symbol
                // - if node.LocalSymbol == null - this node is non-exported so we can just pick the result of GetSymbolOfNode
                var symbol = GetSymbolOfNode(node);
                var localSymbol = node.LocalSymbol ?? symbol;

                // Since the javascript won't do semantic analysis like typescript,
                // if the javascript file comes before the typescript file and both contain same name functions,
                // checkFunctionOrConstructorISymbol wouldn't be called if we didnt ignore javascript function.
                var firstDeclaration = ForEachUntil(
                    localSymbol.DeclarationList,
                    this,
                    (declaration, @this) => // Get first non javascript  declaration
                    {
                        return
                            declaration.Kind == node.Kind && !declaration.IsJavaScriptFile()
                            ? declaration
                            : null;
                    });

                // Only type check the symbol once
                if (node.ResolveUnionType() == firstDeclaration.ResolveUnionType())
                {
                    CheckFunctionOrConstructorSymbol(localSymbol);
                }

                if (symbol.Parent != null)
                {
                    // run check once for the first declaration
                    if (GetDeclarationOfKind(symbol, node.Kind) == node)
                    {
                        // run check on export symbol to check that modifiers agree across all exported declarations
                        CheckFunctionOrConstructorSymbol(symbol);
                    }
                }
            }

            CheckSourceElement(node.Body);
            if (!node.AsteriskToken)
            {
                IType returnOrPromisedType = null;
                if (node.Type != null)
                {
                    returnOrPromisedType = isAsync ? CheckAsyncFunctionReturnType(node) : GetTypeFromTypeNode(node.Type);
                }

                CheckAllCodePathsInNonVoidFunctionReturnOrThrow(node, returnOrPromisedType);
            }

            if (m_produceDiagnostics && node.Type == null)
            {
                // Report an implicit any error if there is no body, no explicit return type, and node is not a private method
                // in an ambient context
                if (m_compilerOptions.NoImplicitAny.HasValue &&
                    m_compilerOptions.NoImplicitAny.Value &&
                    NodeIsMissing(node.Body) &&
                    !IsPrivateWithinAmbient(node))
                {
                    ReportImplicitAnyError(node, m_anyType);
                }

                if (node.AsteriskToken && NodeIsPresent(node.Body))
                {
                    // A generator with a body and no type annotation can still cause errors. It can error if the
                    // yielded values have no common supertype, or it can give an implicit any error if it has no
                    // yielded values. The only way to trigger these errors is to try checking its return type.
                    GetReturnTypeOfSignature(GetSignatureFromDeclaration(node));
                }
            }
        }

        private void CheckBlock(IStatement node)
        {
            NodeArray<IStatement> statements;

            // Grammar checking for SyntaxKind.Block
            if (node.Kind == SyntaxKind.Block)
            {
                CheckGrammarStatementInAmbientContext(node);
                statements = node.Cast<IBlock>().Statements;
            }
            else
            {
                Contract.Assert(node.Kind == SyntaxKind.ModuleBlock);
                statements = node.Cast<IModuleBlock>().Statements;
            }

            ForEach(statements, this, (s, @this) =>
            {
                @this.CheckSourceElement(s);
            });
        }

        private void CheckCollisionWithArgumentsInGeneratedCode(ISignatureDeclaration node)
        {
            // no rest parameters \ declaration context \ overload - no codegen impact
            if (!HasRestParameter(node) || IsInAmbientContext(node) || NodeIsMissing(node.As<IFunctionLikeDeclaration>()?.Body))
            {
                return;
            }

            ForEach(node.Parameters, this, (p, @this) =>
            {
                if (p.Name != null && IsBindingPattern(p.Name) == null && p.Name.Cast<IIdentifier>().Text == @this.m_argumentsSymbol.Name)
                {
                    @this.Error(p, Errors.Duplicate_identifier_arguments_Compiler_uses_arguments_to_initialize_rest_parameters);
                }
            });
        }

        private bool NeedCollisionCheckForIdentifier(INode node, IIdentifier identifier, string name)
        {
            // There is no code gen for DScript,
            // so it make no sense to make any checks.
            if (m_isScriptFile)
            {
                return false;
            }

            return NeedCollisionCheckForIdentifier();

            bool NeedCollisionCheckForIdentifier()
            {
                if (!(identifier != null && identifier.Text == name))
                {
                    return false;
                }

                if (node.Kind == SyntaxKind.PropertyDeclaration ||
                    node.Kind == SyntaxKind.PropertySignature ||
                    node.Kind == SyntaxKind.MethodDeclaration ||
                    node.Kind == SyntaxKind.MethodSignature ||
                    node.Kind == SyntaxKind.GetAccessor ||
                    node.Kind == SyntaxKind.SetAccessor)
                {
                    // it is ok to have member named '_super' or '_this' - member access is always qualified
                    return false;
                }

                if (IsInAmbientContext(node))
                {
                    // ambient context - no codegen impact
                    return false;
                }

                var root = GetRootDeclaration(node);
                if (root.Kind == SyntaxKind.Parameter && NodeIsMissing(root.Parent.As<IFunctionLikeDeclaration>()?.Body))
                {
                    // just an overload - no codegen impact
                    return false;
                }

                return true;
            }
        }

        private void CheckCollisionWithCapturedThisVariable(INode node, IIdentifier name)
        {
            if (NeedCollisionCheckForIdentifier(node, name, "_this"))
            {
                GetPerFileState(node).PotentialThisCollisions.Enqueue(node);
            }
        }

        // this function will run after checking the source file so 'CaptureThis' is correct for all nodes
        private void CheckIfThisIsCapturedInEnclosingScope(INode node)
        {
            var current = node;
            while (current != null)
            {
                if ((GetNodeCheckFlags(current) & NodeCheckFlags.CaptureThis) != NodeCheckFlags.None)
                {
                    var isDeclaration = node.Kind != SyntaxKind.Identifier;
                    if (isDeclaration)
                    {
                        Error(node.Cast<IDeclaration>().Name, Errors.Duplicate_identifier_this_Compiler_uses_variable_declaration_this_to_capture_this_reference);
                    }
                    else
                    {
                        Error(node, Errors.Expression_resolves_to_variable_declaration_this_that_compiler_uses_to_capture_this_reference);
                    }

                    return;
                }

                current = current.Parent;
            }
        }

        private void CheckCollisionWithCapturedSuperVariable(INode node, IIdentifier name)
        {
            if (!NeedCollisionCheckForIdentifier(node, name, "_super"))
            {
                return;
            }

            // bubble up and find containing type
            var enclosingClass = GetContainingClass(node);

            // if containing type was not found or it is ambient - exit (no codegen)
            if (enclosingClass == null || IsInAmbientContext(enclosingClass))
            {
                return;
            }

            if (GetClassExtendsHeritageClauseElement(enclosingClass) != null)
            {
                var isDeclaration = node.Kind != SyntaxKind.Identifier;
                if (isDeclaration)
                {
                    Error(node, Errors.Duplicate_identifier_super_Compiler_uses_super_to_capture_base_class_reference);
                }
                else
                {
                    Error(node, Errors.Expression_resolves_to_super_that_compiler_uses_to_capture_base_class_reference);
                }
            }
        }

        private void CheckCollisionWithRequireExportsInGeneratedCode(INode node, IIdentifier name)
        {
            if (!NeedCollisionCheckForIdentifier(node, name, "require") && !NeedCollisionCheckForIdentifier(node, name, "exports"))
            {
                return;
            }

            // Uninstantiated modules shouldn't do this check
            if (node.Kind == SyntaxKind.ModuleDeclaration && Binder.GetModuleInstanceState(node) != ModuleInstanceState.Instantiated)
            {
                return;
            }

            // In case of variable declaration, node.Parent is variable statement so look at the variable statement's parent
            var parent = GetDeclarationContainer(node);
            if (parent.Kind == SyntaxKind.SourceFile && IsExternalOrCommonJsModule(parent.Cast<ISourceFile>()))
            {
                // If the declaration happens to be in external module, report error that require and exports are reserved keywords
                Error(name, Errors.Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_a_module,
                    DeclarationNameToString(name), DeclarationNameToString(name));
            }
        }

        private void CheckVarDeclaredNamesNotShadowed(IVariableLikeDeclaration node)
        {
            // - ScriptBody : StatementList
            // It is a Syntax Error if any element of the LexicallyDeclaredNames of StatementList
            // also occurs in the VarDeclaredNames of StatementList.

            // - Block : { StatementList }
            // It is a Syntax Error if any element of the LexicallyDeclaredNames of StatementList
            // also occurs in the VarDeclaredNames of StatementList.

            // Variable declarations are hoisted to the top of their function scope. They can shadow
            // block scoped declarations, which bind tighter. this will not be flagged as duplicate definition
            // by the binder as the declaration scope is different.
            // A non-initialized declaration is a no-op as the block declaration will resolve before the var
            // declaration. the problem is if the declaration has an initializer. this will act as a write to the
            // block declared value. this is fine for let, but not const.
            // Only consider declarations with initializers, uninitialized const declarations will not
            // step on a let/const variable.
            // Do not consider const and const declarations, as duplicate block-scoped declarations
            // are handled by the binder.
            // We are only looking for const declarations that step on let\const declarations from a
            // different scope. e.g.:
            //      {
            //          const x = 0; // localDeclarationSymbol obtained after name resolution will correspond to this declaration
            //          const x = 0; // symbol for this declaration will be 'symbol'
            //      }

            // skip block-scoped variables and parameters
            if ((GetCombinedNodeFlags(node) & NodeFlags.BlockScoped) != NodeFlags.None || IsParameterDeclaration(node))
            {
                return;
            }

            // skip variable declarations that don't have initializers
            // in NOTE ES6 spec initializer is required in variable declarations where name is binding pattern
            // so we'll always treat binding elements as initialized
            if (node.Kind == SyntaxKind.VariableDeclaration && node.Initializer == null)
            {
                return;
            }

            var symbol = GetSymbolOfNode(node);
            if ((symbol.Flags & SymbolFlags.FunctionScopedVariable) != SymbolFlags.None)
            {
                var localDeclarationSymbol = ResolveName(node, node.Name.Cast<IIdentifier>().Text, SymbolFlags.Variable, /*nodeNotFoundErrorMessage*/ null, /*nameArg*/ (string)null);
                if (localDeclarationSymbol != null &&
                    localDeclarationSymbol != symbol &&
                    (localDeclarationSymbol.Flags & SymbolFlags.BlockScopedVariable) != SymbolFlags.None)
                {
                    if ((GetDeclarationFlagsFromSymbol(localDeclarationSymbol) & NodeFlags.BlockScoped) != NodeFlags.None)
                    {
                        var varDeclList = GetAncestor(localDeclarationSymbol.ValueDeclaration, SyntaxKind.VariableDeclarationList);
                        var container =
                            varDeclList.Parent.Kind == SyntaxKind.VariableStatement && varDeclList.Parent.Parent != null
                                ? varDeclList.Parent.Parent
                                : null;

                        // names of block-scoped and  scoped variables can collide only
                        // if block scoped variable is defined in the function\module\source file scope (because of variable hoisting)
                        var namesShareScope =
                            container != null &&
                            ((container.Kind == SyntaxKind.Block && (IsFunctionLike(container.Parent) != null)) ||
                                container.Kind == SyntaxKind.ModuleBlock ||
                                container.Kind == SyntaxKind.ModuleDeclaration ||
                                container.Kind == SyntaxKind.SourceFile);

                        // here we know that  scoped variable is shadowed by block scoped one
                        // if they are defined in the same scope - binder has already reported redeclaration error
                        // otherwise if variable has an initializer - show error that initialization will fail
                        // since LHS will be block scoped name instead of  scoped
                        if (!namesShareScope)
                        {
                            var name = SymbolToString(localDeclarationSymbol);
                            Error(node, Errors.Cannot_initialize_outer_scoped_variable_0_in_the_same_scope_as_block_scoped_declaration_1, name, name);
                        }
                    }
                }
            }
        }

        private Bool CheckParameterInitializerVisitor(IFunctionLikeDeclaration func, IVariableLikeDeclaration node, INode visitee)
        {
            if (visitee.Kind == SyntaxKind.Identifier)
            {
                var referencedSymbol = GetResolvedSymbol(visitee);

                // check FunctionLikeDeclaration.Locals (stores parameters\ local variable)
                // if it contains entry with a specified name and if this entry matches the resolved symbol
                if (referencedSymbol != null && referencedSymbol != m_unknownSymbol &&
                    GetSymbol(func.Locals, referencedSymbol.Name, SymbolFlags.Value) == referencedSymbol)
                {
                    if (referencedSymbol.ValueDeclaration.Kind == SyntaxKind.Parameter)
                    {
                        if (referencedSymbol.ValueDeclaration.ResolveUnionType() == node.ResolveUnionType())
                        {
                            Error(visitee, Errors.Parameter_0_cannot_be_referenced_in_its_initializer, DeclarationNameToString(node.Name));
                            return false;
                        }

                        if (referencedSymbol.ValueDeclaration.Pos < node.Pos)
                        {
                            // legal case - parameter initializer references some parameter strictly on left of current parameter declaration
                            return false;
                        }

                        // fall through to error reporting
                    }

                    Error(
                        visitee,
                        Errors.Initializer_of_parameter_0_cannot_reference_identifier_1_declared_after_it,
                        DeclarationNameToString(node.Name),
                        DeclarationNameToString(visitee.Cast<IIdentifier>()));
                }
            }
            else
            {
                NodeWalker.ForEachChild(visitee, n => CheckParameterInitializerVisitor(func, node, n));
            }

            return false;
        }

        // Check that a parameter initializer contains no references to parameters declared to the right of itself
        private void CheckParameterInitializer(IVariableLikeDeclaration node)
        {
            if (GetRootDeclaration(node).Kind != SyntaxKind.Parameter)
            {
                return;
            }

            var func = GetContainingFunction(node);
            CheckParameterInitializerVisitor(func, node, node.Initializer);
        }

        // Check variable, parameter, or property declaration
        private void CheckVariableLikeDeclaration(IVariableLikeDeclaration node)
        {
            CheckDecorators(node);
            CheckSourceElement(node.Type);

            // For a computed property, just check the initializer and exit
            // Do not use hasDynamicName here, because that returns false for well known symbols.
            // We want to perform checkComputedPropertyName for all computed properties, including
            // well known symbols.
            var name = node.Name;
            if (name.Kind == SyntaxKind.ComputedPropertyName)
            {
                CheckComputedPropertyName(name.Cast<IComputedPropertyName>());
                if (node.Initializer != null)
                {
                    CheckExpressionCached(node.Initializer);
                }
            }

            if (node.Kind == SyntaxKind.BindingElement)
            {
                // check computed properties inside property names of binding elements
                if (node.PropertyName != null && node.PropertyName.Kind == SyntaxKind.ComputedPropertyName)
                {
                    CheckComputedPropertyName(node.PropertyName.Cast<IComputedPropertyName>());
                }
            }

            // For a binding pattern, check contained binding elements
            if (IsBindingPattern(name) != null)
            {
                ForEach(name.Cast<IBindingPattern>().Elements, this, (e, @this) =>
                {
                    @this.CheckSourceElement(e);
                });
            }

            // For a parameter declaration with an initializer, error and exit if the containing  doesn't have a body
            if (node.Initializer != null &&
                GetRootDeclaration(node).Kind == SyntaxKind.Parameter &&
                NodeIsMissing(GetContainingFunction(node).Body))
            {
                Error(node, Errors.A_parameter_initializer_is_only_allowed_in_a_function_or_constructor_implementation);
                return;
            }

            // For a binding pattern, validate the initializer and exit
            if (IsBindingPattern(name) != null)
            {
                if (node.Initializer != null)
                {
                    CheckTypeAssignableTo(
                        CheckExpressionCached(node.Initializer),
                        GetWidenedTypeForVariableLikeDeclaration(node),
                        node,
                        /*headMessage*/ null);
                    CheckParameterInitializer(node);
                }

                return;
            }

            var symbol = GetSymbolOfNode(node);
            var type = GetTypeOfVariableOrParameterOrProperty(symbol);
            if (symbol.ValueDeclaration != null && node.ResolveUnionType() == symbol.ValueDeclaration.ResolveUnionType())
            {
                // Node is the primary declaration of the symbol, just validate the initializer
                if (node.Initializer != null)
                {
                    CheckTypeAssignableTo(CheckExpressionCached(node.Initializer), type, node, /*headMessage*/ null);
                    CheckParameterInitializer(node);
                }
            }
            else
            {
                // Node is a secondary declaration, check that type is identical to primary declaration and check that
                // initializer is consistent with type associated with the node
                var declarationType = GetWidenedTypeForVariableLikeDeclaration(node);
                if (type != m_unknownType && declarationType != m_unknownType && !IsTypeIdenticalTo(type, declarationType))
                {
                    Error(
                        name,
                        Errors.Subsequent_variable_declarations_must_have_the_same_type_Variable_0_must_be_of_type_1_but_here_has_type_2,
                        DeclarationNameToString(name),
                        TypeToString(type),
                        TypeToString(declarationType));
                }

                if (node.Initializer != null)
                {
                    CheckTypeAssignableTo(CheckExpressionCached(node.Initializer), declarationType, node, /*headMessage*/ null);
                }
            }

            if (node.Kind != SyntaxKind.PropertyDeclaration && node.Kind != SyntaxKind.PropertySignature)
            {
                // We know we don't have a binding pattern or computed name here
                CheckExportsOnMergedDeclarations(node);
                if (node.Kind == SyntaxKind.VariableDeclaration || node.Kind == SyntaxKind.BindingElement)
                {
                    CheckVarDeclaredNamesNotShadowed(node);
                }

                var identifierName = name.Cast<IIdentifier>();
                CheckCollisionWithCapturedSuperVariable(node, identifierName);
                CheckCollisionWithCapturedThisVariable(node, identifierName);
                CheckCollisionWithRequireExportsInGeneratedCode(node, identifierName);
            }
        }

        private void CheckVariableDeclaration(IVariableDeclaration node)
        {
            CheckGrammarVariableDeclaration(node);

            // HINT: This cast only works because the runtime class that implements IVariableDeclaration also implements IVariableLikeDeclaration
            CheckVariableLikeDeclaration(node.Cast<IVariableLikeDeclaration>());
        }

        private void CheckBindingElement(IBindingElement node)
        {
            CheckGrammarBindingElement(node);

            // HINT: This cast only works because the runtime class that implements IBindingElement also implements IVariableLikeDeclaration
            CheckVariableLikeDeclaration(node.Cast<IVariableLikeDeclaration>());
        }

        private void CheckVariableStatement(IVariableStatement node)
        {
            // Grammar checking
            var grammarCheck = CheckGrammarDecorators(node) ||
                               CheckGrammarModifiers(node) ||
                               CheckGrammarVariableDeclarationList(node.DeclarationList) ||
                               CheckGrammarForDisallowedLetOrConstStatement(node);

            // DScript-specific. Variable statements can have decorators.
            CheckDecorators(node);

            ForEach(node.DeclarationList.Declarations, this, (n, @this) =>
            {
                @this.CheckSourceElement(n);
            });
        }

        private bool CheckGrammarDisallowedModifiersOnObjectLiteralExpressionMethod(INode node)
        {
            // We only disallow modifier on a method declaration if it is a property of object-literal-expression
            if (node.Modifiers != null && node.Parent.Kind == SyntaxKind.ObjectLiteralExpression)
            {
                if (IsAsyncFunctionLike(node))
                {
                    if (node.Modifiers.Length > 1)
                    {
                        return GrammarErrorOnFirstToken(node, Errors.Modifiers_cannot_appear_here);
                    }
                }
                else
                {
                    return GrammarErrorOnFirstToken(node, Errors.Modifiers_cannot_appear_here);
                }
            }

            return false;
        }

        private void CheckExpressionStatement(IExpressionStatement node)
        {
            // Grammar checking
            CheckGrammarStatementInAmbientContext(node);

            CheckExpression(node.Expression);
        }

        private void CheckIfStatement(IIfStatement node)
        {
            // Grammar checking
            CheckGrammarStatementInAmbientContext(node);

            CheckExpression(node.Expression);
            CheckSourceElement(node.ThenStatement);

            if (node.ThenStatement.Kind == SyntaxKind.EmptyStatement)
            {
                Error(node.ThenStatement, Errors.The_body_of_an_if_statement_cannot_be_the_empty_statement);
            }

            CheckSourceElement(node.ElseStatement.ValueOrDefault);
        }

        private void CheckDoStatement(IDoStatement node)
        {
            // Grammar checking
            CheckGrammarStatementInAmbientContext(node);

            CheckSourceElement(node.Statement);
            CheckExpression(node.Expression);
        }

        private void CheckWhileStatement(IWhileStatement node)
        {
            // Grammar checking
            CheckGrammarStatementInAmbientContext(node);

            CheckExpression(node.Expression);
            CheckSourceElement(node.Statement);
        }

        private void CheckForStatement(IForStatement node)
        {
            // Grammar checking
            if (!CheckGrammarStatementInAmbientContext(node))
            {
                if (node.Initializer?.Kind == SyntaxKind.VariableDeclarationList)
                {
                    CheckGrammarVariableDeclarationList(node.Initializer.Cast<IVariableDeclarationList>());
                }
            }

            if (node.Initializer != null)
            {
                if (node.Initializer.Kind == SyntaxKind.VariableDeclarationList)
                {
                    ForEach(node.Initializer.Cast<IVariableDeclarationList>().Declarations, this, (d, @this) =>
                    {
                        @this.CheckVariableDeclaration(d);
                    });
                }
                else
                {
                    CheckExpression(node.Initializer.Cast<IExpression>());
                }
            }

            if (node.Condition != null)
            {
                CheckExpression(node.Condition);
            }

            if (node.Incrementor != null)
            {
                CheckExpression(node.Incrementor);
            }

            CheckSourceElement(node.Statement);
        }

        private void CheckForOfStatement(IForOfStatement node)
        {
            CheckGrammarForInOrForOfStatement(node);

            // Check the LHS and RHS
            // If the LHS is a declaration, just check it as a variable declaration, which will in turn check the RHS
            // via checkRightHandSideOfForOf.
            // If the LHS is an expression, check the LHS, as a destructuring assignment or as a reference.
            // Then check that the RHS is assignable to it.
            if (node.Initializer.Kind == SyntaxKind.VariableDeclarationList)
            {
                CheckForInOrForOfVariableDeclaration(node);
            }
            else
            {
                var varExpr = node.Initializer.Cast<IExpression>();
                var iteratedType = CheckRightHandSideOfForOf(node.Expression);

                // There may be a destructuring assignment on the left side
                if (varExpr.Kind == SyntaxKind.ArrayLiteralExpression || varExpr.Kind == SyntaxKind.ObjectLiteralExpression)
                {
                    // iteratedType may be null. In this case, we still want to check the structure of
                    // varExpr, in particular making sure it's a valid LeftHandSideExpression. But we'd like
                    // to short circuit the type relation checking as much as possible, so we pass the m_unknownType.
                    CheckDestructuringAssignment(
                        varExpr,
                        iteratedType ?? m_unknownType);
                }
                else
                {
                    var leftType = CheckExpression(varExpr);
                    CheckReferenceExpression(
                        varExpr,
                        /*invalidReferenceMessage*/ Errors.Invalid_left_hand_side_in_for_of_statement,
                        /*varantVariableMessage*/ Errors.The_left_hand_side_of_a_for_of_statement_cannot_be_a_previously_defined_constant);

                    // iteratedType will be null if the rightType was missing properties/signatures
                    // required to get its iteratedType (like [Symbol.Iterator] or next). This may be
                    // because we accessed properties from anyType, or it may have led to an error inside
                    // getElementTypeOfIterable.
                    if (iteratedType != null)
                    {
                        CheckTypeAssignableTo(iteratedType, leftType, varExpr, /*headMessage*/ null);
                    }
                }
            }

            CheckSourceElement(node.Statement);
        }

        private void CheckForInStatement(IForInStatement node)
        {
            // Grammar checking
            CheckGrammarForInOrForOfStatement(node);

            // TypeScript 1.0 spec  (April 2014): 5.4
            // In a 'for-in' statement of the form
            // for (var VarDecl in Expr) Statement
            //   VarDecl must be a variable declaration without a type annotation that declares a variable of type Any,
            //   and Expr must be an expression of type Any, an object type, or a type parameter type.
            if (node.Initializer.Kind == SyntaxKind.VariableDeclarationList)
            {
                var variable = node.Initializer.Cast<IVariableDeclarationList>().Declarations.FirstOrDefault();
                if (variable != null && IsBindingPattern(variable.Name) != null)
                {
                    Error(variable.Name, Errors.The_left_hand_side_of_a_for_in_statement_cannot_be_a_destructuring_pattern);
                }

                CheckForInOrForOfVariableDeclaration(node);
            }
            else
            {
                // In a 'for-in' statement of the form
                // for (Var in Expr) Statement
                //   Var must be an expression classified as a reference of type Any or the String primitive type,
                //   and Expr must be an expression of type Any, an object type, or a type parameter type.
                var varExpr = node.Initializer.Cast<IExpression>();
                var leftType = CheckExpression(varExpr);
                if (varExpr.Kind == SyntaxKind.ArrayLiteralExpression || varExpr.Kind == SyntaxKind.ObjectLiteralExpression)
                {
                    Error(varExpr, Errors.The_left_hand_side_of_a_for_in_statement_cannot_be_a_destructuring_pattern);
                }
                else if (!IsTypeAnyOrAllConstituentTypesHaveKind(leftType, TypeFlags.StringLike))
                {
                    Error(varExpr, Errors.The_left_hand_side_of_a_for_in_statement_must_be_of_type_string_or_any);
                }
                else
                {
                    // run check only former check succeeded to avoid cascading errors
                    CheckReferenceExpression(varExpr, Errors.Invalid_left_hand_side_in_for_in_statement, Errors.The_left_hand_side_of_a_for_in_statement_cannot_be_a_previously_defined_constant);
                }
            }

            var rightType = CheckExpression(node.Expression);

            // unknownType is returned i.e., if node.expression is identifier whose name cannot be resolved
            // in this case error about missing name is already reported - do not report extra one
            if (!IsTypeAnyOrAllConstituentTypesHaveKind(rightType, TypeFlags.ObjectType | TypeFlags.TypeParameter))
            {
                Error(node.Expression, Errors.The_right_hand_side_of_a_for_in_statement_must_be_of_type_any_an_object_type_or_a_type_parameter);
            }

            CheckSourceElement(node.Statement);
        }

        private void CheckForInOrForOfVariableDeclaration(IIterationStatement iterationStatement)
        {
            var initializer = iterationStatement.Kind == SyntaxKind.ForOfStatement ?
                                iterationStatement.Cast<IForOfStatement>().Initializer :
                                iterationStatement.Cast<IForInStatement>().Initializer;

            // HINT: This cast works because callers of this function guarantee node.Initializer.Kind == VariableDelcarationList
            var variableDeclarationList = initializer.Cast<IVariableDeclarationList>();

            // checkGrammarForInOrForOfStatement will check that there is exactly one declaration.
            if (variableDeclarationList.Declarations.Length >= 1)
            {
                var decl = variableDeclarationList.Declarations[0];
                CheckVariableDeclaration(decl);
            }
        }

        private IType CheckRightHandSideOfForOf(IExpression rhsExpression)
        {
            var expressionType = GetTypeOfExpression(rhsExpression);
            return CheckIteratedTypeOrElementType(expressionType, rhsExpression, /*allowStringInput*/ true);
        }

        private IType CheckIteratedTypeOrElementType(IType inputType, INode errorNode, bool allowStringInput)
        {
            if (IsTypeAny(inputType))
            {
                return inputType;
            }

            if (m_languageVersion >= ScriptTarget.Es6)
            {
                return CheckElementTypeOfIterable(inputType, errorNode);
            }

            if (allowStringInput)
            {
                return CheckElementTypeOfArrayOrString(inputType, errorNode);
            }

            if (IsArrayLikeType(inputType))
            {
                var indexType = GetIndexTypeOfType(inputType, IndexKind.Number);
                if (indexType != null)
                {
                    return indexType;
                }
            }

            Error(errorNode, Errors.Type_0_is_not_an_array_type, TypeToString(inputType));
            return m_unknownType;
        }

        /// <summary>
        /// When errorNode is null, it means we should not report any errors.
        /// </summary>
        private IType CheckElementTypeOfIterable(IType iterable, INode errorNode)
        {
            var elementType = GetElementTypeOfIterable(iterable, errorNode);

            // Now even though we have extracted the iteratedType, we will have to validate that the type
            // passed in is actually an Iterable.
            if (errorNode != null && elementType != null)
            {
                CheckTypeAssignableTo(iterable, CreateIterableType(elementType), errorNode);
            }

            return elementType ?? m_anyType;
        }

        /**
         * We want to treat type as an iterable, and get the type it is an iterable of. The iterable
         * must have the following structure (annotated with the names of the variables below):
         *
         * { // iterable
         * [Symbol.iterator]: { // iteratorFunction
         * (): Iterator&lt;T&gt;
         * }
         * }
         *
         * T is the type we are after. At every level that involves analyzing return types
         * of signatures, we union the return types of all the signatures.
         *
         * Another thing to note is that at any step of this process, we could run into a dead end,
         * meaning either the property is missing, or we run into the anyType. If either of these things
         * happens, we return undefined to signal that we could not find the iterated type. If a property
         * is missing, and the previous step did not result in 'any', then we also give an error if the
         * caller requested it. Then the caller can decide what to do in the case where there is no iterated
         * type. This is different from returning anyType, because that would signify that we have matched the
         * whole pattern and that T (above) is 'any'.
         */
        private IType GetElementTypeOfIterable(IType type, INode errorNode)
        {
            if (IsTypeAny(type))
            {
                return null;
            }

            // TODO: Verify correctness. The code below is a faithful conversion of the TS (I think!), however
            //       Sarmad notes that either the IterableOrIteratorType cast or the IGenericType cast below
            //       will fail. If that's the case, then one of the derefs below is going to throw a
            //       NullReferenceException on us. (See also GetElementTypeOfIterator)
            var typeAsIterable = type.As<IIterableOrIteratorType>();

            if (typeAsIterable != null && typeAsIterable.IterableElementType == null)
            {
                // As an optimization, if the type is instantiated directly using the globalIterableType (Iterable<number>),
                // then just grab its type argument.
                if ((type.Flags & TypeFlags.Reference) != TypeFlags.None && type.Cast<ITypeReference>().Target == m_globalIterableType)
                {
                    typeAsIterable.IterableElementType = type.Cast<ITypeReference>().TypeArguments[0];
                }
                else
                {
                    var iteratorFunction = GetTypeOfPropertyOfType(type, GetPropertyNameForKnownSymbolName("iterator"));

                    if (IsTypeAny(iteratorFunction))
                    {
                        return null;
                    }

                    var iteratorFunctionSignatures = iteratorFunction != null ? GetSignaturesOfType(iteratorFunction, SignatureKind.Call) : s_emptySignatureList;

                    if (iteratorFunctionSignatures.Count == 0)
                    {
                        if (errorNode != null)
                        {
                            Error(errorNode, Errors.Type_must_have_a_Symbol_iterator_method_that_returns_an_iterator);
                        }

                        return null;
                    }

                    typeAsIterable.IterableElementType = GetElementTypeOfIterator(
                            GetUnionType(iteratorFunctionSignatures.Map(this, (s, @this) => @this.GetReturnTypeOfSignature(s))),
                            errorNode);
                }
            }

            return typeAsIterable?.IterableElementType;
        }

        /// <summary>
        /// This function has very similar logic as getElementTypeOfIterable, except that it operates on
        /// Iterators instead of Iterables.
        /// </summary>
        /// <remarks>
        /// Here is the structure:
        /// { // iterator
        ///     next: { // iteratorNextFunction
        ///         (): { // iteratorNextResult
        ///             value: T // iteratorNextValue
        ///         }
        ///     }
        /// }
        /// </remarks>
        private IType GetElementTypeOfIterator(IType type, INode errorNode)
        {
            if (IsTypeAny(type))
            {
                return null;
            }

            // TODO: Verify correctness. Same comment as the one above in GetElementTypeOfIterable
            var typeAsIterator = type.As<IIterableOrIteratorType>();
            if (typeAsIterator != null && typeAsIterator.IteratorElementType == null)
            {
                // As an optimization, if the type is instantiated directly using the globalIteratorType (Iterator<int>),
                // then just grab its type argument.
                if ((type.Flags & TypeFlags.Reference) != TypeFlags.None && type.Cast<ITypeReference>().Target == m_globalIteratorType)
                {
                    typeAsIterator.IteratorElementType = type.Cast<ITypeReference>().TypeArguments[0];
                }
                else
                {
                    var iteratorNextFunction = GetTypeOfPropertyOfType(type, "next");

                    if (IsTypeAny(iteratorNextFunction))
                    {
                        return null;
                    }

                    var iteratorNextFunctionSignatures = iteratorNextFunction != null ? GetSignaturesOfType(iteratorNextFunction, SignatureKind.Call) : s_emptySignatureList;
                    if (iteratorNextFunctionSignatures.Count == 0)
                    {
                        if (errorNode != null)
                        {
                            Error(errorNode, Errors.An_iterator_must_have_a_next_method);
                        }

                        return null;
                    }

                    var iteratorNextResult = GetUnionType(iteratorNextFunctionSignatures.Map(this, (s, @this) => @this.GetReturnTypeOfSignature(s)));

                    if (IsTypeAny(iteratorNextResult))
                    {
                        return null;
                    }

                    var iteratorNextValue = GetTypeOfPropertyOfType(iteratorNextResult, "value");

                    if (iteratorNextValue != null)
                    {
                        if (errorNode != null)
                        {
                            Error(errorNode, Errors.The_type_returned_by_the_next_method_of_an_iterator_must_have_a_value_property);
                        }

                        return null;
                    }

                    typeAsIterator.IteratorElementType = iteratorNextValue;
                }
            }

            return typeAsIterator?.IteratorElementType;
        }

        private IType GetElementTypeOfIterableIterator(IType type)
        {
            if (IsTypeAny(type))
            {
                return null;
            }

            // As an optimization, if the type is instantiated directly using the globalIterableIteratorType (IterableIterator<int>),
            // then just grab its type argument.
            if ((type.Flags & TypeFlags.Reference) != TypeFlags.None && type.Cast<ITypeReference>().Target == m_globalIterableIteratorType)
            {
                return type.Cast<ITypeReference>().TypeArguments[0];
            }

            return GetElementTypeOfIterable(type, /*errorNode*/ null) ?? GetElementTypeOfIterator(type, /*errorNode*/ null);
        }

        /// <summary>
        /// This function does the following steps:
        ///   1. Break up arrayOrStringType (possibly a union) into its string constituents and array constituents.
        ///   2. Take the element types of the array constituents.
        ///   3. Return the union of the element types, and string if there was a string constitutent.
        ///
        /// For example:
        ///     string -> string
        ///     number[] -> number
        ///     string[] | number[] -> string | number
        ///     string | number[] -> string | number
        ///     string | string[] | number[] -> string | number
        ///
        /// It also errors if:
        ///   1. Some constituent is neither a string nor an array.
        ///   2. Some constituent is a string and target is less than ES5 (because in ES3 string is not indexable).
        /// </summary>
        private IType CheckElementTypeOfArrayOrString(IType arrayOrStringType, INode errorNode)
        {
            Contract.Assert(m_languageVersion < ScriptTarget.Es6);

            // After we remove all types that are StringLike, we will know if there was a string constituent
            // based on whether the remaining type is the same as the initial type.
            var arrayType = arrayOrStringType;
            if ((arrayOrStringType.Flags & TypeFlags.Union) != TypeFlags.None)
            {
                arrayType = GetUnionType(
                                arrayOrStringType.Cast<IUnionType>().Types.Filter(
                                    t => (t.Flags & TypeFlags.StringLike) == TypeFlags.None));
            }
            else if ((arrayOrStringType.Flags & TypeFlags.StringLike) != TypeFlags.None)
            {
                arrayType = m_emptyUnionType;
            }

            var hasStringConstituent = arrayOrStringType != arrayType;
            var reportedError = false;
            if (hasStringConstituent)
            {
                if (m_languageVersion < ScriptTarget.Es5)
                {
                    Error(errorNode, Errors.Using_a_string_in_a_for_of_statement_is_only_supported_in_ECMAScript_5_and_higher);
                    reportedError = true;
                }

                // Now that we've removed all the StringLike types, if no constituents remain, then the entire
                // arrayOrStringType was a string.
                if (arrayType == m_emptyObjectType)
                {
                    return m_stringType;
                }
            }

            if (!IsArrayLikeType(arrayType))
            {
                if (!reportedError)
                {
                    // Which error we report depends on whether there was a string constituent. For example,
                    // if the input type is int | string, we want to say that int is not an array type.
                    // But if the input was just int, we want to say that int is not an array type
                    // or a string type.
                    var diagnostic = hasStringConstituent
                        ? Errors.Type_0_is_not_an_array_type
                        : Errors.Type_0_is_not_an_array_type_or_a_string_type;

                    Error(errorNode, diagnostic, TypeToString(arrayType));
                }

                return hasStringConstituent ? m_stringType : m_unknownType;
            }

            var arrayElementType = GetIndexTypeOfType(arrayType, IndexKind.Number) ?? m_unknownType;

            if (hasStringConstituent)
            {
                // This is just an optimization for the case where arrayOrStringType is string | string[]
                if ((arrayElementType.Flags & TypeFlags.StringLike) != TypeFlags.None)
                {
                    return m_stringType;
                }

                return GetUnionType(new List<IType>() { arrayElementType, m_stringType });
            }

            return arrayElementType;
        }

        private void CheckBreakOrContinueStatement(IBreakOrContinueStatement node)
        {
            // Grammar checking
            if (!CheckGrammarStatementInAmbientContext(node))
            {
                CheckGrammarBreakOrContinueStatement(node);
            }

            // TODO: Check that target label is valid
        }

        private static bool IsGetAccessorWithAnnotatatedSetAccessor(IFunctionLikeDeclaration node)
        {
            return node.Kind == SyntaxKind.GetAccessor &&
                   GetSetAccessorTypeAnnotationNode(GetDeclarationOfKind(node.Symbol, SyntaxKind.SetAccessor)?.Cast<IAccessorDeclaration>()) != null;
        }

        private void CheckReturnStatement(IReturnStatement node)
        {
            // Grammar checking
            if (!CheckGrammarStatementInAmbientContext(node))
            {
                var functionBlock = GetContainingFunction(node);
                if (functionBlock == null)
                {
                    GrammarErrorOnFirstToken(node, Errors.A_return_statement_can_only_be_used_within_a_function_body);
                }
            }

            if (node.Expression != null)
            {
                var func = GetContainingFunction(node);
                if (func != null)
                {
                    var signature = GetSignatureFromDeclaration(func);
                    var returnType = GetReturnTypeOfSignature(signature);
                    var exprType = CheckExpressionCached(node.Expression);

                    if (func.AsteriskToken)
                    {
                        // A generator does not need its return expressions checked against its return type.
                        // Instead, the yield expressions are checked against the element type.
                        // TODO: Check return expressions of generators when return type tracking is added
                        // for generators.
                        return;
                    }

                    if (func.Kind == SyntaxKind.SetAccessor)
                    {
                        Error(node.Expression, Errors.Setters_cannot_return_a_value);
                    }
                    else if (func.Kind == SyntaxKind.Constructor)
                    {
                        if (!CheckTypeAssignableTo(exprType, returnType, node.Expression))
                        {
                            Error(node.Expression, Errors.Return_type_of_constructor_signature_must_be_assignable_to_the_instance_type_of_the_class);
                        }
                    }
                    else if (func.Type != null || IsGetAccessorWithAnnotatatedSetAccessor(func) || (returnType.Flags & TypeFlags.PredicateType) != TypeFlags.None)
                    {
                        if (IsAsyncFunctionLike(func))
                        {
                            var promisedType = GetPromisedType(returnType);
                            var awaitedType = CheckAwaitedType(
                                                exprType,
                                                node.Expression,
                                                Errors.Return_expression_in_async_function_does_not_have_a_valid_callable_then_member);

                            if (promisedType != null)
                            {
                                // If the has a return type, but promisedType is
                                // null, an error will be reported in checkAsyncFunctionReturnType
                                // so we don't need to report one here.
                                CheckTypeAssignableTo(awaitedType, promisedType, node.Expression);
                            }
                        }
                        else
                        {
                            CheckTypeAssignableTo(exprType, returnType, node.Expression);
                        }
                    }
                }
            }
        }

        private void CheckWithStatement(IWithStatement node)
        {
            // Grammar checking for withStatement
            if (!CheckGrammarStatementInAmbientContext(node))
            {
                if (node.IsAwait())
                {
                    GrammarErrorOnFirstToken(node, Errors.With_statements_are_not_allowed_in_an_async_function_block);
                }
            }

            CheckExpression(node.Expression);
            Error(node.Expression, Errors.All_symbols_within_a_with_block_will_be_resolved_to_any);
        }

        private void CheckSwitchStatement(ISwitchStatement node)
        {
            // Grammar checking
            CheckGrammarStatementInAmbientContext(node);

            CaseClauseOrDefaultClause firstDefaultClause = null;
            var hasDuplicateDefaultClause = false;

            var expressionType = CheckExpression(node.Expression);
            var expressionTypeIsStringLike = MaybeTypeOfKind(expressionType, TypeFlags.StringLike);

            ForEach(node.CaseBlock.Clauses, clause =>
            {
                // Grammar check for duplicate default clauses, skip if we already report duplicate default clause
                if (clause.Kind == SyntaxKind.DefaultClause && !hasDuplicateDefaultClause)
                {
                    if (firstDefaultClause == null)
                    {
                        firstDefaultClause = clause;
                    }
                    else
                    {
                        var sourceFile = NodeStructureExtensions.GetSourceFile(node);
                        var start = SkipTrivia(sourceFile.Text, clause.Pos);
                        var end = clause.Statements.Length > 0 ? clause.Statements[0].Pos : clause.End;

                        GrammarErrorAtPos(sourceFile, start, end - start, Errors.A_default_clause_cannot_appear_more_than_once_in_a_switch_statement);
                        hasDuplicateDefaultClause = true;
                    }
                }

                if (m_produceDiagnostics && clause.Kind == SyntaxKind.CaseClause)
                {
                    var caseClause = clause.Cast<ICaseClause>();

                    // TypeScript 1.0 spec (April 2014):5.9
                    // In a 'switch' statement, each 'case' expression must be of a type that is comparable to or from the type of the 'switch' expression.
                    var caseType = CheckExpression(caseClause.Expression);
                    if (!IsTypeComparableTo(expressionType, caseType))
                    {
                        // expressionType is not comparable to caseType, try the reversed check and report errors if it fails
                        CheckTypeComparableTo(caseType, expressionType, caseClause.Expression, /*headMessage*/ null);
                    }
                }

                ForEach(clause.Statements, this, (s, @this) =>
                {
                    @this.CheckSourceElement(s);
                });
            });
        }

        private void CheckLabeledStatement(ILabeledStatement node)
        {
            // Grammar checking
            if (!CheckGrammarStatementInAmbientContext(node))
            {
                var current = node.Parent;
                while (current != null)
                {
                    if (IsFunctionLike(current) != null)
                    {
                        break;
                    }

                    if (current.Kind == SyntaxKind.LabeledStatement &&
                        current.Cast<ILabeledStatement>().Label.Text == node.Label.Text)
                    {
                        var sourceFile = NodeStructureExtensions.GetSourceFile(node);
                        GrammarErrorOnNode(node.Label, Errors.Duplicate_label_0, Utils.GetTextOfNodeFromSourceText(sourceFile.Text, node.Label));
                        break;
                    }

                    current = current.Parent;
                }
            }

            // ensure that label is unique
            CheckSourceElement(node.Statement);
        }

        private void CheckThrowStatement(IThrowStatement node)
        {
            // Grammar checking
            if (!CheckGrammarStatementInAmbientContext(node))
            {
                if (node.Expression == null)
                {
                    GrammarErrorAfterFirstToken(node, Errors.Line_break_not_permitted_here);
                }
            }

            if (node.Expression != null)
            {
                CheckExpression(node.Expression);
            }
        }

        private void CheckTryStatement(ITryStatement node)
        {
            // Grammar checking
            CheckGrammarStatementInAmbientContext(node);

            CheckBlock(node.TryBlock);
            var catchClause = node.CatchClause;
            if (catchClause != null)
            {
                // Grammar checking
                if (catchClause.VariableDeclaration != null)
                {
                    if (catchClause.VariableDeclaration.Name.Kind != SyntaxKind.Identifier)
                    {
                        GrammarErrorOnFirstToken(catchClause.VariableDeclaration.Name, Errors.Catch_clause_variable_name_must_be_an_identifier);
                    }
                    else if (catchClause.VariableDeclaration.Type != null)
                    {
                        GrammarErrorOnFirstToken(catchClause.VariableDeclaration.Type, Errors.Catch_clause_variable_cannot_have_a_type_annotation);
                    }
                    else if (catchClause.VariableDeclaration.Initializer != null)
                    {
                        GrammarErrorOnFirstToken(catchClause.VariableDeclaration.Initializer, Errors.Catch_clause_variable_cannot_have_an_initializer);
                    }
                    else
                    {
                        var identifierName = catchClause.VariableDeclaration.Name.Cast<IIdentifier>().Text;
                        var locals = catchClause.Block.Locals;
                        if (locals != null && HasProperty(locals, identifierName))
                        {
                            var localSymbol = locals[identifierName];
                            if (localSymbol != null && (localSymbol.Flags & SymbolFlags.BlockScopedVariable) != SymbolFlags.None)
                            {
                                GrammarErrorOnNode(localSymbol.ValueDeclaration, Errors.Cannot_redeclare_identifier_0_in_catch_clause, identifierName);
                            }
                        }
                    }
                }

                CheckBlock(catchClause.Block);
            }

            if (node.FinallyBlock != null)
            {
                CheckBlock(node.FinallyBlock);
            }
        }

        private void CheckIndexConstraints(IType type)
        {
            var declaredNumberIndexer = GetIndexDeclarationOfSymbol(type.Symbol, IndexKind.Number);
            var declaredStringIndexer = GetIndexDeclarationOfSymbol(type.Symbol, IndexKind.String);

            var stringIndexType = GetIndexTypeOfType(type, IndexKind.String);
            var numberIndexType = GetIndexTypeOfType(type, IndexKind.Number);

            if (stringIndexType != null || numberIndexType != null)
            {
                ForEach(GetPropertiesOfObjectType(type), prop =>
                {
                    var propType = GetTypeOfSymbol(prop);

                    CheckIndexConstraintForProperty(prop, propType, type, declaredStringIndexer, stringIndexType, IndexKind.String);
                    CheckIndexConstraintForProperty(prop, propType, type, declaredNumberIndexer, numberIndexType, IndexKind.Number);
                });

                if ((type.Flags & TypeFlags.Class) != TypeFlags.None && IsClassLike(type.Symbol.ValueDeclaration) != null)
                {
                    var classDeclaration = type.Symbol.ValueDeclaration.Cast<IClassLikeDeclaration>();

                    foreach (var member in classDeclaration.Members)
                    {
                        // Only process instance properties with computed names here.
                        // Static properties cannot be in conflict with indexers,
                        // and properties with literal names were already checked.
                        if ((member.Flags & NodeFlags.Static) == NodeFlags.None && HasDynamicName(member) && member.Symbol != null)
                        {
                            var propType = GetTypeOfSymbol(member.Symbol);
                            CheckIndexConstraintForProperty(member.Symbol, propType, type, declaredStringIndexer, stringIndexType, IndexKind.String);
                            CheckIndexConstraintForProperty(member.Symbol, propType, type, declaredNumberIndexer, numberIndexType, IndexKind.Number);
                        }
                    }
                }
            }

            INode errorNode = null;
            if (stringIndexType != null && numberIndexType != null)
            {
                errorNode = declaredNumberIndexer;
                errorNode = errorNode ?? declaredStringIndexer;

                // condition 'errorNode == null' may appear if types does not declare nor string neither int indexer
                if (errorNode == null && (type.Flags & TypeFlags.Interface) != TypeFlags.None)
                {
                    var someBaseTypeHasBothIndexers =
                        Any(GetBaseTypes(type.Cast<IInterfaceType>()), this, (b, @this) =>
                        {
                            return @this.GetIndexTypeOfType(b, IndexKind.String) != null &&
                                  @this.GetIndexTypeOfType(b, IndexKind.Number) != null;
                        });

                    errorNode = someBaseTypeHasBothIndexers ? null : type.Symbol?.DeclarationList.FirstOrDefault();
                }
            }

            if (errorNode != null && !IsTypeAssignableTo(numberIndexType, stringIndexType))
            {
                Error(
                    errorNode,
                    Errors.Numeric_index_type_0_is_not_assignable_to_string_index_type_1,
                    TypeToString(numberIndexType),
                    TypeToString(stringIndexType));
            }
        }

        // Nested to previous function!
        private void CheckIndexConstraintForProperty(
                               ISymbol prop,
                               IType propertyType,
                               IType containingType,
                               IDeclaration indexDeclaration,
                               IType indexType,
                               IndexKind indexKind)
        {
            if (indexType == null)
            {
                return;
            }

            // index is numeric and property name is not valid numeric literal
            if (indexKind == IndexKind.Number && !IsNumericName(prop.ValueDeclaration.Name))
            {
                return;
            }

            // perform property check if property or indexer is declared in 'type'
            // this allows to rule out cases when both property and indexer are inherited from the base class
            INode errorNode = null;
            if (prop.ValueDeclaration.Name.Kind == SyntaxKind.ComputedPropertyName || prop.Parent == containingType.Symbol)
            {
                errorNode = prop.ValueDeclaration;
            }
            else if (indexDeclaration != null)
            {
                errorNode = indexDeclaration;
            }
            else if ((containingType.Flags & TypeFlags.Interface) != TypeFlags.None)
            {
                // for interfaces property and indexer might be inherited from different bases
                // check if any base class already has both property and indexer.
                // check should be performed only if 'type' is the first type that brings property\indexer together
                var someBaseClassHasBothPropertyAndIndexer = Any(GetBaseTypes(containingType.Cast<IInterfaceType>()), b =>
                {
                    return GetPropertyOfObjectType(b, prop.Name) != null && GetIndexTypeOfType(b, indexKind) != null;
                });

                errorNode = someBaseClassHasBothPropertyAndIndexer ? null : containingType.Symbol.DeclarationList[0];
            }

            if (errorNode != null && !IsTypeAssignableTo(propertyType, indexType))
            {
                var errorMessage =
                    indexKind == IndexKind.String
                        ? Errors.Property_0_of_type_1_is_not_assignable_to_string_index_type_2
                        : Errors.Property_0_of_type_1_is_not_assignable_to_numeric_index_type_2;
                Error(errorNode, errorMessage, SymbolToString(prop), TypeToString(propertyType), TypeToString(indexType));
            }
        }

        // HINT: First param *was* DeclarationName, but the only places this is called use INode.Name, which is an
        //        IIdentifier. And this code immediately casts to that so...
        private void CheckTypeNameIsReserved(/*HINT: DeclarationName*/ IIdentifier name, IDiagnosticMessage message)
        {
            // TS 1.0 spec (April 2014): 3.6.1
            // The predefined type keywords are reserved and cannot be used as names of user defined types.
            switch (name.Text)
            {
                case "any":
                case "number":
                case "boolean":
                case "string":
                case "symbol":
                case "void":
                    Error(name, message, name.Text);
                    break;
            }
        }

        // Check each type parameter and check that list has no duplicate type parameter declarations
        private void CheckTypeParameters(NodeArray<ITypeParameterDeclaration> typeParameterDeclarations)
        {
            if (typeParameterDeclarations != null)
            {
                var n = typeParameterDeclarations.Count;
                for (var i = 0; i < n; i++)
                {
                    var node = typeParameterDeclarations[i];
                    CheckTypeParameter(node);

                    if (m_produceDiagnostics)
                    {
                        for (var j = 0; j < i; j++)
                        {
                            if (typeParameterDeclarations[j].Symbol == node.Symbol)
                            {
                                Error(node.Name, Errors.Duplicate_identifier_0, DeclarationNameToString(node.Name));
                            }
                        }
                    }
                }
            }
        }

        private IType CheckClassExpression(IClassExpression node)
        {
            CheckClassLikeDeclaration(node);
            CheckNodeDeferred(node);
            return GetTypeOfSymbol(GetSymbolOfNode(node));
        }

        private void CheckClassExpressionDeferred(IClassExpression node)
        {
            ForEach(node.Members, this, (n, @this) =>
            {
                @this.CheckSourceElement(n);
            });
        }

        private void CheckClassDeclaration(IClassDeclaration node)
        {
            if (node.Name == null && (node.Flags & NodeFlags.Default) == NodeFlags.None)
            {
                GrammarErrorOnFirstToken(node, Errors.A_class_declaration_without_the_default_modifier_must_have_a_name);
            }

            CheckClassLikeDeclaration(node);
            ForEach(node.Members, this, (n, @this) =>
            {
                @this.CheckSourceElement(n);
            });
        }

        private void CheckClassLikeDeclaration(IClassLikeDeclaration node)
        {
            CheckGrammarClassDeclarationHeritageClauses(node);
            CheckDecorators(node);
            if (node.Name != null)
            {
                CheckTypeNameIsReserved(node.Name, Errors.Class_name_cannot_be_0);
                CheckCollisionWithCapturedThisVariable(node, node.Name);
                CheckCollisionWithRequireExportsInGeneratedCode(node, node.Name);
            }

            CheckTypeParameters(node.TypeParameters);
            CheckExportsOnMergedDeclarations(node);

            var symbol = GetSymbolOfNode(node);
            var type = GetDeclaredTypeOfSymbol(symbol).Cast<IInterfaceType>();
            var typeWithThis = GetTypeWithThisArgument(type);
            var staticType = GetTypeOfSymbol(symbol).Cast<IObjectType>();

            var emitState = GetPerFileState(node.GetSourceFile());

            var baseTypeNode = GetClassExtendsHeritageClauseElement(node);
            if (baseTypeNode != null)
            {
                emitState.EmitExtends = emitState.EmitExtends || !IsInAmbientContext(node);
                var baseTypes = GetBaseTypes(type);
                if (baseTypes.Count > 0 && m_produceDiagnostics)
                {
                    var baseType = baseTypes[0];
                    var staticBaseType = GetBaseConstructorTypeOfClass(type);
                    CheckSourceElement(baseTypeNode.Expression);
                    if (baseTypeNode.TypeArguments != null)
                    {
                        ForEach(baseTypeNode.TypeArguments, this, (s, @this) =>
                        {
                            @this.CheckSourceElement(s);
                        });

                        foreach (var constructor in GetConstructorsForTypeArguments(staticBaseType, baseTypeNode.TypeArguments).AsStructEnumerable())
                        {
                            if (!CheckTypeArgumentConstraints(constructor.TypeParameters, baseTypeNode.TypeArguments))
                            {
                                break;
                            }
                        }
                    }

                    INode errorNode = node.Name;
                    errorNode = errorNode ?? node;
                    CheckTypeAssignableTo(typeWithThis, GetTypeWithThisArgument(baseType, type.ThisType), errorNode, Errors.Class_0_incorrectly_extends_base_class_1);
                    CheckTypeAssignableTo(staticType, GetTypeWithoutSignatures(staticBaseType), errorNode,
                        Errors.Class_static_side_0_incorrectly_extends_base_class_static_side_1);

                    if (!(staticBaseType.Symbol != null && staticBaseType.Symbol != null && (staticBaseType.Symbol.Flags & SymbolFlags.Class) != SymbolFlags.None))
                    {
                        // When the static base type is a "class-like" constructor function (but not actually a class), we verify
                        // that all instantiated base constructor signatures return the same type. We can simply compare the type
                        // references (as opposed to checking the structure of the types) because elsewhere we have already checked
                        // that the base type is a class or interface type (and not, for example, an anonymous object type).
                        var constructors = GetInstantiatedConstructorsForTypeArguments(staticBaseType, baseTypeNode.TypeArguments);
                        if (Any(constructors, sig => GetReturnTypeOfSignature(sig) != baseType))
                        {
                            Error(baseTypeNode.Expression, Errors.Base_constructors_must_all_have_the_same_return_type);
                        }
                    }

                    CheckKindsOfPropertyMemberOverrides(type, baseType);
                }
            }

            var implementedTypeNodes = GetClassImplementsHeritageClauseElements(node);
            if (implementedTypeNodes != null)
            {
                foreach (var typeRefNode in implementedTypeNodes)
                {
                    if (!IsSupportedExpressionWithTypeArguments(typeRefNode))
                    {
                        Error(typeRefNode.Expression, Errors.A_class_can_only_implement_an_identifier_Slashqualified_name_with_optional_type_arguments);
                    }

                    CheckTypeReferenceNode(typeRefNode);
                    if (m_produceDiagnostics)
                    {
                        var t = GetTypeFromTypeNode(typeRefNode);
                        if (t != m_unknownType)
                        {
                            var declaredType = (t.Flags & TypeFlags.Reference) != TypeFlags.None ? t.Cast<ITypeReference>().Target : t;
                            if ((declaredType.Flags & (TypeFlags.Class | TypeFlags.Interface)) != TypeFlags.None)
                            {
                                INode errorNode = node.Name;
                                errorNode = errorNode ?? node;
                                CheckTypeAssignableTo(typeWithThis, GetTypeWithThisArgument(t, type.ThisType), errorNode, Errors.Class_0_incorrectly_implements_interface_1);
                            }
                            else
                            {
                                Error(typeRefNode, Errors.A_class_may_only_implement_another_class_or_interface);
                            }
                        }
                    }
                }
            }

            if (m_produceDiagnostics)
            {
                CheckIndexConstraints(type);
                CheckTypeForDuplicateIndexSignatures(node);
            }
        }

        private ISymbol GetTargetSymbol(ISymbol s)
        {
            // if symbol is instantiated its flags are not copied from the 'target'
            // so we'll need to get back original 'target' symbol to work with correct set of flags
            return (s.Flags & SymbolFlags.Instantiated) != SymbolFlags.None ? GetSymbolLinks(s).Target : s;
        }

        private static IDeclaration GetClassLikeDeclarationOfSymbol(ISymbol symbol)
        {
            return ForEachUntil(symbol.DeclarationList, d => IsClassLike(d) != null ? d : null);
        }

        private void CheckKindsOfPropertyMemberOverrides(IInterfaceType type, /*HINT: IObjectType*/ IType baseType)
        {
            // TypeScript 1.0 spec (April 2014): 8.2.3
            // A derived class inherits all members from its base class it doesn't override.
            // Inheritance means that a derived class implicitly contains all non - overridden members of the base class.
            // Both public and private property members are inherited, but only public property members can be overridden.
            // A property member in a derived class is said to override a property member in a base class
            // when the derived class property member has the same name and kind(instance or static)
            // as the base class property member.
            // The type of an overriding property member must be assignable(section 3.8.4)
            // to the type of the overridden property member, or otherwise a compile - time error occurs.
            // Base class instance member functions can be overridden by derived class instance member functions,
            // but not by other kinds of members.
            // Base class instance member variables and accessors can be overridden by
            // derived class instance member variables and accessors, but not by other kinds of members.

            // NOTE: assignability is checked in checkClassDeclaration
            var baseProperties = GetPropertiesOfObjectType(baseType);
            foreach (var baseProperty in baseProperties.AsStructEnumerable())
            {
                var @base = GetTargetSymbol(baseProperty);

                if ((@base.Flags & SymbolFlags.Prototype) != SymbolFlags.None)
                {
                    continue;
                }

                var derived = GetTargetSymbol(GetPropertyOfObjectType(type, @base.Name));
                var baseDeclarationFlags = GetDeclarationFlagsFromSymbol(@base);

                Contract.Assert(derived != null, "derived should point to something, even if it is the base class' declaration.");

                if (derived != null)
                {
                    // In order to resolve whether the inherited method was overriden in the base class or not,
                    // we compare the Symbols obtained. Since getTargetISymbol returns the symbol on the *uninstantiated*
                    // type declaration, derived and base resolve to the same symbol even in the case of generic classes.
                    if (derived == @base)
                    {
                        // derived class inherits base without override/redeclaration
                        var derivedClassDecl = GetClassLikeDeclarationOfSymbol(type.Symbol);

                        // It is an error to inherit an abstract member without implementing it or being declared abstract.
                        // If there is no declaration for the derived class (as in the case of class expressions),
                        // then the class cannot be declared abstract.
                        if ((baseDeclarationFlags & NodeFlags.Abstract) != NodeFlags.None &&
                            (derivedClassDecl == null || (derivedClassDecl.Flags & NodeFlags.Abstract) == NodeFlags.None))
                        {
                            if (derivedClassDecl.Kind == SyntaxKind.ClassExpression)
                            {
                                Error(derivedClassDecl, Errors.Non_abstract_class_expression_does_not_implement_inherited_abstract_member_0_from_class_1,
                                    SymbolToString(baseProperty), TypeToString(baseType));
                            }
                            else
                            {
                                Error(derivedClassDecl, Errors.Non_abstract_class_0_does_not_implement_inherited_abstract_member_1_from_class_2,
                                    TypeToString(type), SymbolToString(baseProperty), TypeToString(baseType));
                            }
                        }
                    }
                    else
                    {
                        // derived overrides base.
                        var derivedDeclarationFlags = GetDeclarationFlagsFromSymbol(derived);
                        if ((baseDeclarationFlags & NodeFlags.Private) != NodeFlags.None || (derivedDeclarationFlags & NodeFlags.Private) != NodeFlags.None)
                        {
                            // either base or derived property is private - not override, skip it
                            continue;
                        }

                        if ((baseDeclarationFlags & NodeFlags.Static) != (derivedDeclarationFlags & NodeFlags.Static))
                        {
                            // value of 'static' is not the same for properties - not override, skip it
                            continue;
                        }

                        if ((@base.Flags & derived.Flags & SymbolFlags.Method) != SymbolFlags.None ||
                            ((@base.Flags & SymbolFlags.PropertyOrAccessor) != SymbolFlags.None && (derived.Flags & SymbolFlags.PropertyOrAccessor) != SymbolFlags.None))
                        {
                            // method is overridden with method or property/accessor is overridden with property/accessor - correct case
                            continue;
                        }

                        IDiagnosticMessage errorMessage = null;
                        if ((@base.Flags & SymbolFlags.Method) != SymbolFlags.None)
                        {
                            if ((derived.Flags & SymbolFlags.Accessor) != SymbolFlags.None)
                            {
                                errorMessage = Errors.Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_accessor;
                            }
                            else
                            {
                                Contract.Assert((derived.Flags & SymbolFlags.Property) != SymbolFlags.None);
                                errorMessage = Errors.Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_property;
                            }
                        }
                        else if ((@base.Flags & SymbolFlags.Property) != SymbolFlags.None)
                        {
                            Contract.Assert((derived.Flags & SymbolFlags.Method) != SymbolFlags.None);
                            errorMessage = Errors.Class_0_defines_instance_member_property_1_but_extended_class_2_defines_it_as_instance_member_function;
                        }
                        else
                        {
                            Contract.Assert((@base.Flags & SymbolFlags.Accessor) != SymbolFlags.None);
                            Contract.Assert((derived.Flags & SymbolFlags.Method) != SymbolFlags.None);
                            errorMessage = Errors.Class_0_defines_instance_member_accessor_1_but_extended_class_2_defines_it_as_instance_member_function;
                        }

                        Error(derived.ValueDeclaration.Name, errorMessage, TypeToString(baseType), SymbolToString(@base), TypeToString(type));
                    }
                }
            }
        }

        private static bool IsAccessor(SyntaxKind kind)
        {
            return kind == SyntaxKind.GetAccessor || kind == SyntaxKind.SetAccessor;
        }

        private bool AreTypeParametersIdentical(NodeArray<ITypeParameterDeclaration> list1, NodeArray<ITypeParameterDeclaration> list2)
        {
            if (list1 == null && list2 == null)
            {
                return true;
            }

            if (list1 == null || list2 == null || list1.Length != list2.Length)
            {
                return false;
            }

            // TypeScript 1.0 spec (April 2014):
            // When a generic interface has multiple declarations,  all declarations must have identical type parameter
            // lists, i.e., identical type parameter names with identical varraints in identical order.
            var len = list1.Length;
            for (var i = 0; i < len; i++)
            {
                var tp1 = list1[i];
                var tp2 = list2[i];
                if (tp1.Name.Text != tp2.Name.Text)
                {
                    return false;
                }

                if (tp1.Constraint == null && tp2.Constraint == null)
                {
                    continue;
                }

                if (tp1.Constraint == null || tp2.Constraint == null)
                {
                    return false;
                }

                if (!IsTypeIdenticalTo(GetTypeFromTypeNode(tp1.Constraint), GetTypeFromTypeNode(tp2.Constraint)))
                {
                    return false;
                }
            }

            return true;
        }

        /// <nodoc/>
        private class SymbolAndContainingType
        {
            /// <nodoc/>
            public ISymbol Prop { get; }

            /// <nodoc/>
            public IType ContainingType { get; }

            /// <nodoc/>
            public SymbolAndContainingType(ISymbol prop, IType containingType)
            {
                Prop = prop;
                ContainingType = containingType;
            }
        }

        private bool CheckInheritedPropertiesAreIdentical(IInterfaceType type, INode typeNode)
        {
            var baseTypes = GetBaseTypes(type);
            if (baseTypes.Count < 2)
            {
                return true;
            }

            Map<SymbolAndContainingType> seen = new Map<SymbolAndContainingType>();
            ForEach(ResolveDeclaredMembers(type).DeclaredProperties, p =>
            {
                seen[p.Name] = new SymbolAndContainingType(p, type);
            });

            var ok = true;

            foreach (var @base in baseTypes.AsStructEnumerable())
            {
                var properties = GetPropertiesOfObjectType(GetTypeWithThisArgument(@base, type.ThisType));
                foreach (var prop in properties.AsStructEnumerable())
                {
                    if (!seen.ContainsKey(prop.Name))
                    {
                        seen.Add(prop.Name, new SymbolAndContainingType(prop, @base));
                    }
                    else
                    {
                        var existing = seen[prop.Name];
                        var isInheritedProperty = existing.ContainingType != type;
                        if (isInheritedProperty && !IsPropertyIdenticalTo(existing.Prop, prop))
                        {
                            ok = false;

                            var typeName1 = TypeToString(existing.ContainingType);
                            var typeName2 = TypeToString(@base);

                            var errorInfo = ChainDiagnosticMessages(null, Errors.Named_property_0_of_types_1_and_2_are_not_identical, SymbolToString(prop), typeName1, typeName2);
                            errorInfo = ChainDiagnosticMessages(errorInfo, Errors.Interface_0_cannot_simultaneously_extend_types_1_and_2, TypeToString(type), typeName1, typeName2);
                            m_diagnostics.Add(Diagnostic.CreateDiagnosticForNodeFromMessageChain(typeNode, errorInfo));
                        }
                    }
                }
            }

            return ok;
        }

        private void CheckInterfaceDeclaration(IInterfaceDeclaration node)
        {
            // Grammar checking
            var grammarCheck = CheckGrammarDecorators(node) || CheckGrammarModifiers(node) || CheckGrammarInterfaceDeclaration(node);

            CheckTypeParameters(node.TypeParameters);
            if (m_produceDiagnostics)
            {
                CheckTypeNameIsReserved(node.Name, Errors.Interface_name_cannot_be_0);

                CheckDecorators(node);
                CheckExportsOnMergedDeclarations(node);
                var symbol = GetSymbolOfNode(node);
                var firstInterfaceDecl = GetDeclarationOfKind(symbol, SyntaxKind.InterfaceDeclaration)?.Cast<IInterfaceDeclaration>();
                if (symbol.DeclarationList.Count > 1)
                {
                    if (node.ResolveUnionType() != firstInterfaceDecl.ResolveUnionType() &&
                        !AreTypeParametersIdentical(firstInterfaceDecl.TypeParameters, node.TypeParameters))
                    {
                        Error(node.Name, Errors.All_declarations_of_an_interface_must_have_identical_type_parameters);
                    }
                }

                // Only check this symbol once
                if (node.ResolveUnionType() == firstInterfaceDecl.ResolveUnionType())
                {
                    var type = GetDeclaredTypeOfSymbol(symbol).Cast<IInterfaceType>();
                    var typeWithThis = GetTypeWithThisArgument(type);

                    // run subsequent checks only if first set succeeded
                    if (CheckInheritedPropertiesAreIdentical(type, node.Name))
                    {
                        foreach (var baseType in GetBaseTypes(type).AsStructEnumerable())
                        {
                            CheckTypeAssignableTo(
                                typeWithThis,
                                GetTypeWithThisArgument(baseType, type.ThisType),
                                node.Name,
                                Errors.Interface_0_incorrectly_extends_interface_1);
                        }

                        CheckIndexConstraints(type);
                    }
                }
            }

            ForEach(GetInterfaceBaseTypeNodes(node), this, (heritageElement, @this) =>
            {
                if (!IsSupportedExpressionWithTypeArguments(heritageElement))
                {
                    @this.Error(heritageElement.Expression, Errors.An_interface_can_only_extend_an_identifier_Slashqualified_name_with_optional_type_arguments);
                }

                @this.CheckTypeReferenceNode(heritageElement);
            });

            ForEach(node.Members, this, (e, @this) =>
            {
                @this.CheckSourceElement(e);
            });

            if (m_produceDiagnostics)
            {
                CheckTypeForDuplicateIndexSignatures(node);
            }
        }

        private void CheckTypeAliasDeclaration(ITypeAliasDeclaration node)
        {
            // Grammar checking
            if (!CheckGrammarDecorators(node))
            {
                CheckGrammarModifiers(node);
            }

            // DScript-specific. Type aliases can be decorated
            CheckDecorators(node);

            CheckTypeNameIsReserved(node.Name, Errors.Type_alias_name_cannot_be_0);
            CheckSourceElement(node.Type);
        }

        private void ComputeEnumMemberValues(IEnumDeclaration node)
        {
            var nodeLinks = GetNodeLinks(node);

            if ((nodeLinks.Flags & NodeCheckFlags.EnumValuesComputed) == NodeCheckFlags.None)
            {
                var enumSymbol = GetSymbolOfNode(node);
                var enumType = GetDeclaredTypeOfSymbol(enumSymbol);
                Number? autoValue = new Number(0);
                var ambient = IsInAmbientContext(node);
                var enumIsConst = IsConst(node);

                foreach (var member in node.Members)
                {
                    // DScript-specific. Enum members can have decorators.
                    CheckDecorators(member);

                    if (IsComputedNonLiteralName(member.Name.Cast<PropertyName>()))
                    {
                        Error(member.Name, Errors.Computed_property_names_are_not_allowed_in_enums);
                    }
                    else
                    {
                        var text = GetTextOfPropertyName(member.Name);
                        if (Number.IsNumericLiteralName(text))
                        {
                            Error(member.Name, Errors.An_enum_member_cannot_have_a_numeric_name);
                        }
                    }

                    var previousEnumMemberIsNonConstant = autoValue == null;

                    var initializer = member.Initializer;
                    if (initializer)
                    {
                        autoValue = ComputeConstantValueForEnumMemberInitializer(initializer.Value, enumType, enumIsConst, ambient);
                    }
                    else if (ambient && !enumIsConst)
                    {
                        // In ambient enum declarations that specify no var modifier, enum member declarations
                        // that omit a value are considered computed members (as opposed to having auto-incremented values assigned).
                        autoValue = null;
                    }
                    else if (previousEnumMemberIsNonConstant)
                    {
                        // If the member declaration specifies no value, the member is considered a varant enum member.
                        // If the member is the first member in the enum declaration, it is assigned the value zero.
                        // Otherwise, it is assigned the value of the immediately preceding member plus one,
                        // and an error occurs if the immediately preceding member is not a varant enum member
                        Error(member.Name, Errors.Enum_member_must_have_initializer);
                    }

                    if (autoValue != null)
                    {
                        GetNodeLinks(member).EnumMemberValue = autoValue.Value.AsInt32();
                        autoValue++;
                    }
                }

                nodeLinks.Flags |= NodeCheckFlags.EnumValuesComputed;
            }
        }

        private Number? ComputeConstantValueForEnumMemberInitializer(IExpression initializer, IType enumType, bool enumIsConst, bool ambient)
        {
            // Controls if error should be reported after evaluation of varant value is completed
            // Can be false if another more precise error was already reported during evaluation.
            var closure = new ComputeConstantValueForEnumMemberInitializerClosure(this, initializer, true);

            var value = closure.EvalConstant(initializer);

            if (closure.ReportError)
            {
                if (value == null)
                {
                    if (enumIsConst)
                    {
                        Error(initializer, Errors.In_const_enum_declarations_member_initializer_must_be_constant_expression);
                    }
                    else if (ambient)
                    {
                        Error(initializer, Errors.In_ambient_enum_declarations_member_initializer_must_be_constant_expression);
                    }
                    else
                    {
                        // Only here do we need to check that the initializer is assignable to the enum type.
                        CheckTypeAssignableTo(CheckExpression(initializer), enumType, initializer, /*headMessage*/ null);
                    }
                }
                else if (enumIsConst)
                {
                    if (value.Value.IsNaN())
                    {
                        Error(initializer, Errors.Const_enum_member_initializer_was_evaluated_to_disallowed_value_NaN);
                    }
                    else if (!value.Value.IsFinite())
                    {
                        Error(initializer, Errors.Const_enum_member_initializer_was_evaluated_to_a_non_finite_value);
                    }
                    else if (!value.Value.IsInt32())
                    {
                        Error(initializer, Errors.Const_enum_member_initializer_was_evaluated_to_a_non_integer_value);
                        return null;
                    }
                }
            }

            return value;
        }

        private sealed class ComputeConstantValueForEnumMemberInitializerClosure
        {
            public bool ReportError { get; set; }

            private readonly IExpression m_initializer;
            private readonly Checker m_checker;

            public ComputeConstantValueForEnumMemberInitializerClosure(
                Checker checker,
                IExpression initializer,
                bool reportError)
            {
                ReportError = reportError;
                m_initializer = initializer;
                m_checker = checker;
            }

            public Number? EvalConstant(INode e)
            {
                switch (e.Kind)
                {
                    case SyntaxKind.PrefixUnaryExpression:
                        var value = EvalConstant(e.Cast<IPrefixUnaryExpression>().Operand);

                        if (value == null)
                        {
                            return null;
                        }

                        switch (e.Cast<IPrefixUnaryExpression>().Operator)
                        {
                            case SyntaxKind.PlusToken: return value;
                            case SyntaxKind.MinusToken: return -value;
                            case SyntaxKind.TildeToken: return ~value;
                        }

                        return null;

                    case SyntaxKind.BinaryExpression:
                        var left = EvalConstant(e.Cast<IBinaryExpression>().Left);

                        if (left == null)
                        {
                            return null;
                        }

                        var right = EvalConstant(e.Cast<IBinaryExpression>().Right);

                        if (right == null)
                        {
                            return null;
                        }

                        switch (e.Cast<IBinaryExpression>().OperatorToken.Kind)
                        {
                            case SyntaxKind.BarToken: return left | right;
                            case SyntaxKind.AmpersandToken: return left & right;
                            case SyntaxKind.GreaterThanGreaterThanToken: return left >> right.Value.AsInt32();

                            // TODO: Validate casting hyjinx below resolve to the same thing as '>>>'
                            case SyntaxKind.GreaterThanGreaterThanGreaterThanToken: return new Number(left.Value.AsUInt32() >> right.Value.AsInt32());
                            case SyntaxKind.LessThanLessThanToken: return left << right.Value.AsInt32();
                            case SyntaxKind.CaretToken: return left.Value ^ right.Value;
                            case SyntaxKind.AsteriskToken: return left * right;
                            case SyntaxKind.SlashToken: return left / right;
                            case SyntaxKind.PlusToken: return left + right;
                            case SyntaxKind.MinusToken: return left - right;
                            case SyntaxKind.PercentToken: return left % right;
                        }

                        return null;

                    case SyntaxKind.NumericLiteral:
                        return Number.Parse(e.Cast<ILiteralExpression>().Text);

                    case SyntaxKind.ParenthesizedExpression:
                        return EvalConstant(e.Cast<IParenthesizedExpression>().Expression);

                    case SyntaxKind.Identifier:
                    case SyntaxKind.ElementAccessExpression:
                    case SyntaxKind.PropertyAccessExpression:
                        var member = m_initializer.Parent;
                        var currentType = m_checker.GetTypeOfSymbol(m_checker.GetSymbolOfNode(member.Parent));
                        IType enumType = null;
                        string propertyName = null;

                        if (e.Kind == SyntaxKind.Identifier)
                        {
                            // unqualified names can refer to member that reside in different declaration of the enum so just doing name resolution won't work.
                            // instead pick current enum type and later try to fetch member from the type
                            enumType = currentType;
                            propertyName = e.Cast<IIdentifier>().Text;
                        }
                        else
                        {
                            IExpression expression = null;
                            if (e.Kind == SyntaxKind.ElementAccessExpression)
                            {
                                if (e.Cast<IElementAccessExpression>().ArgumentExpression == null ||
                                    e.Cast<IElementAccessExpression>().ArgumentExpression.Kind != SyntaxKind.StringLiteral)
                                {
                                    return null;
                                }

                                expression = e.Cast<IElementAccessExpression>().Expression;
                                propertyName = e.Cast<IElementAccessExpression>().ArgumentExpression.Cast<ILiteralExpression>().Text;
                            }
                            else
                            {
                                expression = e.Cast<IPropertyAccessExpression>().Expression;
                                propertyName = e.Cast<IPropertyAccessExpression>().Name.Text;
                            }

                            // expression part in ElementAccess\PropertyAccess should be either identifier or dottedName
                            var current = expression;
                            while (current != null)
                            {
                                if (current.Kind == SyntaxKind.Identifier)
                                {
                                    break;
                                }
                                else if (current.Kind == SyntaxKind.PropertyAccessExpression)
                                {
                                    current = current.Cast<IPropertyAccessExpression>().Expression;
                                }
                                else
                                {
                                    return null;
                                }
                            }

                            enumType = m_checker.CheckExpression(expression);

                            // allow references to constant members of other enums
                            if (!(enumType.Symbol != null && (enumType.Symbol.Flags & SymbolFlags.Enum) != SymbolFlags.None))
                            {
                                return null;
                            }
                        }

                        if (propertyName == null)
                        {
                            return null;
                        }

                        var property = m_checker.GetPropertyOfObjectType(enumType, propertyName);
                        if (property == null || (property.Flags & SymbolFlags.EnumMember) == SymbolFlags.None)
                        {
                            return null;
                        }

                        var propertyDecl = property.ValueDeclaration;

                        // self references are illegal
                        if (member.ResolveUnionType() == propertyDecl.ResolveUnionType())
                        {
                            return null;
                        }

                        // illegal forward case reference
                        if (!m_checker.IsBlockScopedNameDeclaredBeforeUse(propertyDecl, member))
                        {
                            ReportError = false;
                            m_checker.Error(e, Errors.A_member_initializer_in_a_enum_declaration_cannot_reference_members_declared_after_it_including_members_defined_in_other_enums);
                            return null;
                        }

                        var enumValue = m_checker.GetNodeLinks(propertyDecl).EnumMemberValue;
                        return enumValue.IsValid() ? (Number?)new Number(enumValue) : null;
                }

                return null;
            }
        }

        private void CheckEnumDeclaration(IEnumDeclaration node)
        {
            if (!m_produceDiagnostics)
            {
                return;
            }

            // Grammar checking
            if (!CheckGrammarDecorators(node))
            {
                CheckGrammarModifiers(node);
            }

            CheckDecorators(node);
            CheckTypeNameIsReserved(node.Name, Errors.Enum_name_cannot_be_0);
            CheckCollisionWithCapturedThisVariable(node, node.Name);
            CheckCollisionWithRequireExportsInGeneratedCode(node, node.Name);
            CheckExportsOnMergedDeclarations(node);

            ComputeEnumMemberValues(node);

            var enumIsConst = IsConst(node);
            if (m_compilerOptions.IsolatedModules.HasValue && m_compilerOptions.IsolatedModules.Value && enumIsConst && IsInAmbientContext(node))
            {
                Error(node.Name, Errors.Ambient_const_enums_are_not_allowed_when_the_isolatedModules_flag_is_provided);
            }

            // Spec 2014 - Section 9.3:
            // It isn't possible for one enum declaration to continue the automatic numbering sequence of another,
            // and when an enum type has multiple declarations, only one declaration is permitted to omit a value
            // for the first member.
            //
            // Only perform this check once per symbol
            var enumSymbol = GetSymbolOfNode(node);
            var firstDeclaration = GetDeclarationOfKind(enumSymbol, node.Kind);
            if (node.ResolveUnionType() == firstDeclaration.ResolveUnionType())
            {
                if (enumSymbol?.DeclarationList.Count > 1)
                {
                    // check that const is placed\omitted on all enum declarations
                    ForEach(enumSymbol.DeclarationList, decl =>
                    {
                        if (IsConstEnumDeclaration(decl) != enumIsConst)
                        {
                            Error(decl.Name, Errors.Enum_declarations_must_all_be_const_or_non_const);
                        }
                    });
                }

                var seenEnumMissingInitialInitializer = false;
                enumSymbol.DeclarationList.Any(declaration =>
                {
                    // return true if we hit a violation of the rule, false otherwise
                    if (declaration.Kind != SyntaxKind.EnumDeclaration)
                    {
                        return false;
                    }

                    var enumDeclaration = declaration.Cast<IEnumDeclaration>();
                    if (enumDeclaration.Members.Count == 0)
                    {
                        return false;
                    }

                    var firstEnumMember = enumDeclaration.Members[0];
                    if (!firstEnumMember.Initializer)
                    {
                        if (seenEnumMissingInitialInitializer)
                        {
                            Error(firstEnumMember.Name, Errors.In_an_enum_with_multiple_declarations_only_one_declaration_can_omit_an_initializer_for_its_first_enum_element);
                        }
                        else
                        {
                            seenEnumMissingInitialInitializer = true;
                        }
                    }

                    return false;
                });
            }
        }

        private static IDeclaration GetFirstNonAmbientClassOrFunctionDeclaration(ISymbol symbol)
        {
            var declarations = symbol.DeclarationList;

            foreach (var declaration in declarations)
            {
                if ((declaration.Kind == SyntaxKind.ClassDeclaration ||
                    (declaration.Kind == SyntaxKind.FunctionDeclaration && NodeIsPresent(declaration.Cast<IFunctionLikeDeclaration>().Body))) &&
                    !IsInAmbientContext(declaration))
                {
                    return declaration;
                }
            }

            return null;
        }

        private bool InSameLexicalScope(INode node1, INode node2)
        {
            var container1 = GetEnclosingBlockScopeContainer(node1);
            var container2 = GetEnclosingBlockScopeContainer(node2);

            if (IsGlobalSourceFile(container1))
            {
                return IsGlobalSourceFile(container2);
            }
            else if (IsGlobalSourceFile(container2))
            {
                return false;
            }
            else
            {
                return container1.ResolveUnionType() == container2.ResolveUnionType();
            }
        }

        private void CheckModuleDeclaration(IModuleDeclaration node)
        {
            if (m_produceDiagnostics)
            {
                // Grammar checking
                var isAmbientExternalModule = node.Name.Kind == SyntaxKind.StringLiteral;
                var contextErrorMessage = isAmbientExternalModule
                    ? Errors.An_ambient_module_declaration_is_only_allowed_at_the_top_level_in_a_file
                    : Errors.A_namespace_declaration_is_only_allowed_in_a_namespace_or_module;

                if (CheckGrammarModuleElementContext(node, contextErrorMessage))
                {
                    // If we hit a module declaration in an illegal context, just bail out to avoid cascading errors.
                    return;
                }

                if (!CheckGrammarDecorators(node) && !CheckGrammarModifiers(node))
                {
                    if (!IsInAmbientContext(node) && node.Name.Kind == SyntaxKind.StringLiteral)
                    {
                        GrammarErrorOnNode(node.Name, Errors.Only_ambient_modules_can_use_quoted_names);
                    }
                }

                CheckCollisionWithCapturedThisVariable(node, node.Name);
                CheckCollisionWithRequireExportsInGeneratedCode(node, node.Name);
                CheckExportsOnMergedDeclarations(node);

                // DScript-specific. Modules can be decorated
                CheckDecorators(node);

                var symbol = GetSymbolOfNode(node);

                // The following checks only apply on a non-ambient instantiated module declaration.
                bool preserveConstEnums = m_compilerOptions.PreserveConstEnums.HasValue && m_compilerOptions.PreserveConstEnums.Value;
                preserveConstEnums |= m_compilerOptions.IsolatedModules.HasValue && m_compilerOptions.IsolatedModules.Value;

                // TypeScript allows function/namespace merging. The following code is correct:
                // function X() {return 42;}
                // namespace X {export const x = 42;}
                // But this should be prohibited in DScript.
                // Skipping the following logic saves a lot of time on a giagentic builds.
                if (!m_isScriptFile)
                {
                    if ((symbol.Flags & SymbolFlags.ValueModule) != SymbolFlags.None
                    && symbol.DeclarationList.Count > 1
                    && !IsInAmbientContext(node)
                    && IsInstantiatedModule(node, preserveConstEnums))
                    {
                        var firstNonAmbientClassOrFunc = GetFirstNonAmbientClassOrFunctionDeclaration(symbol);
                        if (firstNonAmbientClassOrFunc != null)
                        {
                            if (node.GetSourceFile().ResolveUnionType() != firstNonAmbientClassOrFunc.GetSourceFile().ResolveUnionType())
                            {
                                Error(node.Name, Errors.A_namespace_declaration_cannot_be_in_a_different_file_from_a_class_or_function_with_which_it_is_merged);
                            }
                            else if (node.Pos < firstNonAmbientClassOrFunc.Pos)
                            {
                                Error(node.Name, Errors.A_namespace_declaration_cannot_be_located_prior_to_a_class_or_function_with_which_it_is_merged);
                            }
                        }

                        // if the module merges with a class declaration in the same lexical scope,
                        // we need to track this to ensure the correct emit.
                        var mergedClass = GetDeclarationOfKind(symbol, SyntaxKind.ClassDeclaration);
                        if (mergedClass != null &&
                            InSameLexicalScope(node, mergedClass))
                        {
                            GetNodeLinks(node).Flags |= NodeCheckFlags.LexicalModuleMergesWithClass;
                        }
                    }

                    // Checks for ambient external modules.
                    if (isAmbientExternalModule)
                    {
                        if (!IsGlobalSourceFile(node.Parent))
                        {
                            Error(node.Name, Errors.Ambient_modules_cannot_be_nested_in_other_modules_or_namespaces);
                        }

                        if (IsExternalModuleNameRelative(node.Name.Text))
                        {
                            Error(node.Name, Errors.Ambient_module_declaration_cannot_specify_relative_module_name);
                        }
                    }
                }
            }

            CheckSourceElement(node.Body);

            RecordTemplateAndQualifiersForFile2FileRelationship(node);
        }

        private void RecordTemplateAndQualifiersForFile2FileRelationship(INode node)
        {
            if (!m_trackFileToFileDependencies)
            {
                // Don't need to compute expensive stuff, if dependency tracking is disabled.
                return;
            }

            // Every namespace (actually, every member of a namespace) has implicit visibility to 2 members:
            // - qualifier
            // - template
            // Need to check this explicitely in order to build cross file relationship.
            var targetQualifierSymbol = ResolveEntryByName(node, Names.CurrentQualifier, SymbolFlags.BlockScopedVariable);
            if (targetQualifierSymbol != null)
            {
                RecordFile2FileRelationships(node, targetQualifierSymbol);
            }

            var targetTemplateSymbol = ResolveEntryByName(node, Names.Template, SymbolFlags.BlockScopedVariable);
            if (targetTemplateSymbol != null)
            {
                RecordFile2FileRelationships(node, targetTemplateSymbol);
            }
        }

        private static IIdentifier GetFirstIdentifier(/*HINT: EntityName | Expression*/ INode node)
        {
            while (true)
            {
                if (node.Kind == SyntaxKind.QualifiedName)
                {
                    node = node.Cast<IQualifiedName>().Left;
                }
                else if (node.Kind == SyntaxKind.PropertyAccessExpression)
                {
                    node = node.Cast<IPropertyAccessExpression>().Expression;
                }
                else
                {
                    break;
                }
            }

            Contract.Assert(node.Kind == SyntaxKind.Identifier);

            return node.Cast<IIdentifier>();
        }

        // TODO: input was IDeclaration, but IImportDeclaration is not an IDeclaration
        private bool CheckExternalImportOrExportDeclaration(/*HINT: IImportDeclaration | IImportEqualsDeclaration | IExportDeclaration*/ INode node)
        {
            var moduleName = GetExternalModuleName(node);
            if (!NodeIsMissing(moduleName) && moduleName.Kind != SyntaxKind.StringLiteral)
            {
                Error(moduleName, Errors.String_literal_expected);
                return false;
            }

            var inAmbientExternalModule = node.Parent.Kind == SyntaxKind.ModuleBlock && node.Parent.Parent.Cast<IModuleDeclaration>().Name.Kind == SyntaxKind.StringLiteral;
            if (node.Parent.Kind != SyntaxKind.SourceFile && !inAmbientExternalModule)
            {
                Error(moduleName, node.Kind == SyntaxKind.ExportDeclaration ?
                    Errors.Export_declarations_are_not_permitted_in_a_namespace :
                    Errors.Import_declarations_in_a_namespace_cannot_reference_a_module);
                return false;
            }

            if (inAmbientExternalModule && IsExternalModuleNameRelative(moduleName.Cast<ILiteralExpression>().Text))
            {
                // TypeScript 1.0 spec (April 2013): 12.1.6
                // An ExternalImportDeclaration in an AmbientExternalModuleDeclaration may reference
                // other external modules only through top - level external module names.
                // Relative external module names are not permitted.
                Error(node, Errors.Import_or_export_declaration_in_an_ambient_module_declaration_cannot_reference_module_through_relative_module_name);
                return false;
            }

            return true;
        }

        private void CheckAliasSymbol(/*HINT: IImportEqualsDeclaration | IImportClause | INamespaceImport | IImportSpecifier | IExportSpecifier*/ IDeclaration node)
        {
            var symbol = GetSymbolOfNode(node);
            var target = ResolveAlias(symbol);
            if (target != m_unknownSymbol)
            {
                var excludedMeanings =
                    ((symbol.Flags & SymbolFlags.Value) != SymbolFlags.None ? SymbolFlags.Value : SymbolFlags.None) |
                    ((symbol.Flags & SymbolFlags.Type) != SymbolFlags.None ? SymbolFlags.Type : SymbolFlags.None) |
                    ((symbol.Flags & SymbolFlags.Namespace) != SymbolFlags.None ? SymbolFlags.Namespace : SymbolFlags.None);

                if ((target.Flags & excludedMeanings) != SymbolFlags.None)
                {
                    var message = node.Kind == SyntaxKind.ExportSpecifier ?
                        Errors.Export_declaration_conflicts_with_exported_declaration_of_0 :
                        Errors.Import_declaration_conflicts_with_local_declaration_of_0;
                    Error(node, message, SymbolToString(symbol));
                }
            }
        }

        private void CheckImportBinding(/*HINT: IImportEqualsDeclaration | IImportClause | INamespaceImport | IImportSpecifier*/ IDeclaration node)
        {
            CheckCollisionWithCapturedThisVariable(node, node.Name);
            CheckCollisionWithRequireExportsInGeneratedCode(node, node.Name);
            CheckAliasSymbol(node);
        }

        private void CheckImportDeclaration(IImportDeclaration node)
        {
            if (CheckGrammarModuleElementContext(node, Errors.An_import_declaration_can_only_be_used_in_a_namespace_or_module))
            {
                // If we hit an import declaration in an illegal context, just bail out to avoid cascading errors.
                return;
            }

            if (!CheckGrammarDecorators(node) && !CheckGrammarModifiers(node) && ((node.Flags & NodeFlags.Modifier) != NodeFlags.None))
            {
                GrammarErrorOnFirstToken(node, Errors.An_import_declaration_cannot_have_modifiers);
            }

            if (CheckExternalImportOrExportDeclaration(node))
            {
                var importClause = node.ImportClause;
                if (importClause != null)
                {
                    if (importClause.Name != null)
                    {
                        CheckImportBinding(importClause);
                    }

                    if (importClause.NamedBindings != null)
                    {
                        if (importClause.NamedBindings.Kind == SyntaxKind.NamespaceImport)
                        {
                            CheckImportBinding(importClause.NamedBindings.Cast<INamespaceImport>());
                        }
                        else
                        {
                            ForEach(importClause.NamedBindings.Cast<INamedImports>().Elements, this, (s, @this) =>
                            {
                                @this.CheckImportBinding(s);
                            });
                        }
                    }
                }
            }
        }

        private void CheckImportEqualsDeclaration(IImportEqualsDeclaration node)
        {
            if (CheckGrammarModuleElementContext(node, Errors.An_import_declaration_can_only_be_used_in_a_namespace_or_module))
            {
                // If we hit an import declaration in an illegal context, just bail out to avoid cascading errors.
                return;
            }

            if (!CheckGrammarDecorators(node))
            {
                CheckGrammarModifiers(node);
            }

            if (IsInternalModuleImportEqualsDeclaration(node) || CheckExternalImportOrExportDeclaration(node))
            {
                CheckImportBinding(node);
                if ((node.Flags & NodeFlags.Export) != NodeFlags.None)
                {
                    MarkExportAsReferenced(node);
                }

                if (IsInternalModuleImportEqualsDeclaration(node))
                {
                    var target = ResolveAlias(GetSymbolOfNode(node));
                    if (target != m_unknownSymbol)
                    {
                        if ((target.Flags & SymbolFlags.Value) != SymbolFlags.None)
                        {
                            // Target is a value symbol, check that it is not hidden by a local declaration with the same name
                            var moduleName = GetFirstIdentifier(node.ModuleReference);
                            if ((ResolveEntityName(moduleName, SymbolFlags.Value | SymbolFlags.Namespace).Flags & SymbolFlags.Namespace) == SymbolFlags.None)
                            {
                                Error(moduleName, Errors.Module_0_is_hidden_by_a_local_declaration_with_the_same_name, DeclarationNameToString(moduleName));
                            }
                        }

                        if ((target.Flags & SymbolFlags.Type) != SymbolFlags.None)
                        {
                            CheckTypeNameIsReserved(node.Name, Errors.Import_name_cannot_be_0);
                        }
                    }
                }
                else
                {
                    if (m_modulekind == ModuleKind.Es6 && !IsInAmbientContext(node))
                    {
                        // Import equals declaration is deprecated in es6 or above
                        GrammarErrorOnNode(node, Errors.Import_assignment_cannot_be_used_when_targeting_ECMAScript_6_modules_Consider_using_import_Asterisk_as_ns_from_mod_import_a_from_mod_import_d_from_mod_or_another_module_format_instead);
                    }
                }
            }
        }

        private void CheckExportDeclaration(IExportDeclaration node)
        {
            if (CheckGrammarModuleElementContext(node, Errors.An_export_declaration_can_only_be_used_in_a_module))
            {
                // If we hit an export in an illegal context, just bail out to avoid cascading errors.
                return;
            }

            if (!CheckGrammarDecorators(node) && !CheckGrammarModifiers(node) && ((node.Flags & NodeFlags.Modifier) != NodeFlags.None))
            {
                GrammarErrorOnFirstToken(node, Errors.An_export_declaration_cannot_have_modifiers);
            }

            CheckDecorators(node);

            if (node.ModuleSpecifier == null || CheckExternalImportOrExportDeclaration(node))
            {
                if (node.ExportClause != null)
                {
                    // export { x, y }
                    // export { x, y } from "foo"
                    ForEach(node.ExportClause.Elements, this, (s, @this) =>
                    {
                        @this.CheckExportSpecifier(s);
                    });

                    var inAmbientExternalModule = node.Parent.Kind == SyntaxKind.ModuleBlock && node.Parent.Parent.Cast<IModuleDeclaration>().Name.Kind == SyntaxKind.StringLiteral;
                    if (node.Parent.Kind != SyntaxKind.SourceFile && !inAmbientExternalModule)
                    {
                        Error(node, Errors.Export_declarations_are_not_permitted_in_a_namespace);
                    }
                }
                else
                {
                    // export * from "foo"
                    var moduleSymbol = ResolveExternalModuleName(node, node.ModuleSpecifier);
                    if (moduleSymbol?.Exports?["export="] != null)
                    {
                        Error(node.ModuleSpecifier, Errors.Module_0_uses_export_and_cannot_be_used_with_export_Asterisk, SymbolToString(moduleSymbol));
                    }
                }
            }
        }

        private bool CheckGrammarModuleElementContext(IStatement node, IDiagnosticMessage errorMessage)
        {
            if (node.Parent.Kind != SyntaxKind.SourceFile && node.Parent.Kind != SyntaxKind.ModuleBlock && node.Parent.Kind != SyntaxKind.ModuleDeclaration)
            {
                return GrammarErrorOnFirstToken(node, errorMessage);
            }

            return false;
        }

        private void CheckExportSpecifier(IExportSpecifier node)
        {
            CheckAliasSymbol(node);
            if (node.Parent.Parent.Cast<IExportDeclaration>().ModuleSpecifier == null)
            {
                MarkExportAsReferenced(node);
            }
        }

        private void CheckExportAssignment(IExportAssignment node)
        {
            if (CheckGrammarModuleElementContext(node, Errors.An_export_assignment_can_only_be_used_in_a_module))
            {
                // If we hit an export assignment in an illegal context, just bail out to avoid cascading errors.
                return;
            }

            var container = node.Parent.Kind == SyntaxKind.SourceFile ? node.Parent : node.Parent.Parent;
            if (container.Kind == SyntaxKind.ModuleDeclaration && container.Cast<IModuleDeclaration>().Name.Kind == SyntaxKind.Identifier)
            {
                Error(node, Errors.An_export_assignment_cannot_be_used_in_a_namespace);
                return;
            }

            // Grammar checking
            if (!CheckGrammarDecorators(node) && !CheckGrammarModifiers(node) && ((node.Flags & NodeFlags.Modifier) != NodeFlags.None))
            {
                GrammarErrorOnFirstToken(node, Errors.An_export_assignment_cannot_have_modifiers);
            }

            if (node.Expression.Kind == SyntaxKind.Identifier)
            {
                MarkExportAsReferenced(node);
            }
            else
            {
                CheckExpressionCached(node.Expression);
            }

            CheckExternalModuleExports(container.Cast<IDeclaration>());

            if (node.IsExportEquals.HasValue && node.IsExportEquals.Value && !IsInAmbientContext(node))
            {
                if (m_modulekind == ModuleKind.Es6)
                {
                    // export assignment is not supported in es6 modules
                    GrammarErrorOnNode(node, Errors.Export_assignment_cannot_be_used_when_targeting_ECMAScript_6_modules_Consider_using_export_default_or_another_module_format_instead);
                }
                else if (m_modulekind == ModuleKind.System)
                {
                    // system modules does not support export assignment
                    GrammarErrorOnNode(node, Errors.Export_assignment_is_not_supported_when_module_flag_is_system);
                }
            }
        }

        private static bool HasExportedMembers(ISymbol moduleSymbol)
        {
            if (moduleSymbol.Exports != null)
            {
                foreach (var kvp in moduleSymbol.Exports)
                {
                    string id = kvp.Key;
                    if (id != "export=")
                    {
                        return true;
                    }
                }
            }

            return false;
        }

        private void CheckExternalModuleExports(/*HINT: ISourceFile | IModuleDeclaration*/ IDeclaration node)
        {
            var moduleSymbol = GetSymbolOfNode(node);
            GetSymbolLinks(moduleSymbol).GetOrSetExportsChecked(this, (links, @this) =>
            {
                var exportEqualsSymbol = moduleSymbol?.Exports["export="];

                if (exportEqualsSymbol != null && HasExportedMembers(moduleSymbol))
                {
                    var declaration = GetDeclarationOfAliasSymbol(exportEqualsSymbol) ??
                                      exportEqualsSymbol.ValueDeclaration;

                    Error(declaration, Errors.An_export_assignment_cannot_be_used_in_a_module_with_other_exported_elements);
                }

                // Checks for export * conflicts
                var exports = GetExportsOfModule(moduleSymbol);
                foreach (var kvp in exports)
                {
                    var id = kvp.Key;
                    if (id == "__export")
                    {
                        continue;
                    }

                    var export = kvp.Value;
                    var declarations = export.DeclarationList;
                    var flags = export.Flags;

                    // ECMA262: 15.2.1.1 It is a Syntax Error if the ExportedNames of ModuleItemList contains any duplicate entries. (TS namespaces Exceptions,  overloads, enums, and interfaces)
                    if (((flags & (SymbolFlags.Namespace | SymbolFlags.Interface | SymbolFlags.Enum)) == SymbolFlags.None) &&
                        ((flags & SymbolFlags.TypeAlias) != SymbolFlags.None ? declarations.Count - 1 : declarations.Count) > 1)
                    {
                        var exportedDeclarations = declarations.Filter(d => IsNotOverload(d));
                        if (exportedDeclarations.Count > 1)
                        {
                            foreach (var declaration in exportedDeclarations)
                            {
                                m_diagnostics.Add(Diagnostic.CreateDiagnosticForNode(declaration, Errors.Cannot_redeclare_exported_variable_0, id));
                            }
                        }
                    }
                }

                return true;
            });
        }

        private static bool IsNotOverload(IDeclaration declaration)
        {
            return declaration.Kind != SyntaxKind.FunctionDeclaration || declaration.Cast<IFunctionDeclaration>().Body != null;
        }

        private void CheckTypePredicate(ITypePredicateNode node)
        {
            var parameterName = node.ParameterName;

            if (parameterName.Kind == SyntaxKind.Identifier && !IsInLegalParameterTypePredicatePosition(node))
            {
                Error(node, Errors.A_type_predicate_is_only_allowed_in_return_type_position_for_functions_and_methods);
            }
            else if (parameterName.Kind == SyntaxKind.ThisType)
            {
                if (!IsInLegalThisTypePredicatePosition(node))
                {
                    Error(node, Errors.A_this_based_type_predicate_is_only_allowed_within_a_class_or_interface_s_members_get_accessors_or_return_type_positions_for_functions_and_methods);
                }
                else
                {
                    GetTypeFromThisTypeNode(parameterName.Cast<IThisTypeNode>());
                }
            }
        }

        private void CheckSourceElement(INode node)
        {
            if (node == null)
            {
                return;
            }

            var kind = node.Kind;
            if (m_cancellationToken != null)
            {
                // Only bother checking on a few construct kinds.  We don't want to be excessivly
                // hitting the cancellation token on every node we check.
                switch (kind)
                {
                    case SyntaxKind.ModuleDeclaration:
                    case SyntaxKind.ClassDeclaration:
                    case SyntaxKind.InterfaceDeclaration:
                    case SyntaxKind.FunctionDeclaration:
                        m_cancellationToken.ThrowIfCancellationRequested();
                        break;
                }
            }

            switch (kind)
            {
                case SyntaxKind.TypeParameter:
                    CheckTypeParameter(node.Cast<ITypeParameterDeclaration>());
                    break;

                case SyntaxKind.Parameter:
                    CheckParameter(node.Cast<IParameterDeclaration>());
                    break;

                case SyntaxKind.PropertyDeclaration:
                    CheckPropertyDeclaration(node.Cast<IPropertyDeclaration>());
                    break;

                case SyntaxKind.PropertySignature:
                    CheckPropertyDeclaration(node.Cast<IPropertySignature>());
                    break;

                case SyntaxKind.FunctionType:
                case SyntaxKind.ConstructorType:
                case SyntaxKind.CallSignature:
                case SyntaxKind.ConstructSignature:
                case SyntaxKind.IndexSignature:
                    CheckSignatureDeclaration(node.Cast<IFunctionLikeDeclaration>());
                    break;

                case SyntaxKind.MethodDeclaration:
                case SyntaxKind.MethodSignature:
                    CheckMethodDeclaration(node.Cast<IFunctionLikeDeclaration>());
                    break;

                case SyntaxKind.Constructor:
                    CheckConstructorDeclaration(node.Cast<IConstructorDeclaration>());
                    break;

                case SyntaxKind.GetAccessor:
                case SyntaxKind.SetAccessor:
                    CheckAccessorDeclaration(node.Cast<IAccessorDeclaration>());
                    break;

                case SyntaxKind.TypeReference:
                    CheckTypeReferenceNode(node.Cast<ITypeNode>());
                    break;

                case SyntaxKind.TypePredicate:
                    CheckTypePredicate(node.Cast<ITypePredicateNode>());
                    break;

                case SyntaxKind.TypeQuery:
                    CheckTypeQuery(node.Cast<ITypeQueryNode>());
                    break;

                case SyntaxKind.TypeLiteral:
                    CheckTypeLiteral(node.Cast<ITypeLiteralNode>());
                    break;

                case SyntaxKind.ArrayType:
                    CheckArrayType(node.Cast<IArrayTypeNode>());
                    break;

                case SyntaxKind.TupleType:
                    CheckTupleType(node.Cast<ITupleTypeNode>());
                    break;

                case SyntaxKind.UnionType:
                case SyntaxKind.IntersectionType:
                    CheckUnionOrIntersectionType(node.Cast<IUnionOrIntersectionTypeNode>());
                    break;

                case SyntaxKind.ParenthesizedType:
                    CheckSourceElement(node.Cast<IParenthesizedTypeNode>().Type);
                    break;

                case SyntaxKind.FunctionDeclaration:
                    CheckFunctionDeclaration(node.Cast<IFunctionDeclaration>());
                    break;

                case SyntaxKind.Block:
                case SyntaxKind.ModuleBlock:
                    CheckBlock(node.Cast<IStatement>());
                    break;

                case SyntaxKind.VariableStatement:
                    CheckVariableStatement(node.Cast<IVariableStatement>());
                    break;

                case SyntaxKind.ExpressionStatement:
                    CheckExpressionStatement(node.Cast<IExpressionStatement>());
                    break;

                case SyntaxKind.IfStatement:
                    CheckIfStatement(node.Cast<IIfStatement>());
                    break;

                case SyntaxKind.DoStatement:
                    CheckDoStatement(node.Cast<IDoStatement>());
                    break;

                case SyntaxKind.WhileStatement:
                    CheckWhileStatement(node.Cast<IWhileStatement>());
                    break;

                case SyntaxKind.ForStatement:
                    CheckForStatement(node.Cast<IForStatement>());
                    break;

                case SyntaxKind.ForInStatement:
                    CheckForInStatement(node.Cast<IForInStatement>());
                    break;

                case SyntaxKind.ForOfStatement:
                    CheckForOfStatement(node.Cast<IForOfStatement>());
                    break;

                case SyntaxKind.ContinueStatement:
                case SyntaxKind.BreakStatement:
                    CheckBreakOrContinueStatement(node.Cast<IBreakOrContinueStatement>());
                    break;

                case SyntaxKind.ReturnStatement:
                    CheckReturnStatement(node.Cast<IReturnStatement>());
                    break;

                case SyntaxKind.WithStatement:
                    CheckWithStatement(node.Cast<IWithStatement>());
                    break;

                case SyntaxKind.SwitchStatement:
                    CheckSwitchStatement(node.Cast<ISwitchStatement>());
                    break;

                case SyntaxKind.LabeledStatement:
                    CheckLabeledStatement(node.Cast<ILabeledStatement>());
                    break;

                case SyntaxKind.ThrowStatement:
                    CheckThrowStatement(node.Cast<IThrowStatement>());
                    break;

                case SyntaxKind.TryStatement:
                    CheckTryStatement(node.Cast<ITryStatement>());
                    break;

                case SyntaxKind.VariableDeclaration:
                    CheckVariableDeclaration(node.Cast<IVariableDeclaration>());
                    break;

                case SyntaxKind.BindingElement:
                    CheckBindingElement(node.Cast<IBindingElement>());
                    break;

                case SyntaxKind.ClassDeclaration:
                    CheckClassDeclaration(node.Cast<IClassDeclaration>());
                    break;

                case SyntaxKind.InterfaceDeclaration:
                    CheckInterfaceDeclaration(node.Cast<IInterfaceDeclaration>());
                    break;

                case SyntaxKind.TypeAliasDeclaration:
                    CheckTypeAliasDeclaration(node.Cast<ITypeAliasDeclaration>());
                    break;

                case SyntaxKind.EnumDeclaration:
                    CheckEnumDeclaration(node.Cast<IEnumDeclaration>());
                    break;

                case SyntaxKind.ModuleDeclaration:
                    CheckModuleDeclaration(node.Cast<IModuleDeclaration>());
                    break;

                case SyntaxKind.ImportDeclaration:
                    CheckImportDeclaration(node.Cast<IImportDeclaration>());
                    break;

                case SyntaxKind.ImportEqualsDeclaration:
                    CheckImportEqualsDeclaration(node.Cast<IImportEqualsDeclaration>());
                    break;

                case SyntaxKind.ExportDeclaration:
                    CheckExportDeclaration(node.Cast<IExportDeclaration>());
                    break;

                case SyntaxKind.ExportAssignment:
                    CheckExportAssignment(node.Cast<IExportAssignment>());
                    break;

                case SyntaxKind.EmptyStatement:
                    CheckGrammarStatementInAmbientContext(node);
                    break;

                case SyntaxKind.DebuggerStatement:
                    CheckGrammarStatementInAmbientContext(node);
                    break;

                case SyntaxKind.MissingDeclaration:
                    CheckMissingDeclaration(node);
                    break;
                case SyntaxKind.StringLiteralType:
                    // DScript-specific: string literal types support decorators. Need to validate them.
                    CheckDecorators(node);
                    break;
            }
        }

        // Function and class expression bodies are checked after all statements in the enclosing body. This is
        // to ensure constructs like the following are permitted:
        //     const foo = function () {
        //        const s = foo();
        //        return "hello";
        //     }
        // Here, performing a full type check of the body of the function expression whilst in the process of
        // determining the type of foo would cause foo to be given type any because of the recursive reference.
        // Delaying the type check of the body ensures foo has been assigned a type.
        private void CheckNodeDeferred(INode node)
        {
            var perFileState = GetPerFileState(node);
            perFileState.DeferredNodes.Enqueue(node);
        }

        private void CheckDeferredNodes(ConcurrentQueue<INode> deferredNodes)
        {
            // Originial code was just traversing the collection
            // But insertions happen while iterating. Changed to a queue.
            INode node;
            while (deferredNodes.TryDequeue(out node))
            {
                switch (node.Kind)
                {
                    case SyntaxKind.FunctionExpression:
                    case SyntaxKind.ArrowFunction:
                    case SyntaxKind.MethodDeclaration:
                    case SyntaxKind.MethodSignature:
                        CheckFunctionExpressionOrObjectLiteralMethodDeferred(node.Cast<IFunctionLikeDeclaration>());
                        break;

                    case SyntaxKind.GetAccessor:
                    case SyntaxKind.SetAccessor:
                        CheckAccessorDeferred(node.Cast<IAccessorDeclaration>());
                        break;

                    case SyntaxKind.ClassExpression:
                        CheckClassExpressionDeferred(node.Cast<IClassExpression>());
                        break;
                }
            }
        }

        private void CheckSourceFile(ISourceFile node)
        {
            // Type checker stopwatch
            var sw = Stopwatch.StartNew();
            CheckSourceFileWorker(node);
            m_host.ReportSpecTypeCheckingCompleted(node, sw.Elapsed);
        }

        // Fully type check a source file and collect the relevant diagnostics.
        private void CheckSourceFileWorker(ISourceFile node)
        {
            var links = GetNodeLinks(node);

            if ((links.Flags & NodeCheckFlags.TypeChecked) == NodeCheckFlags.None)
            {
                // Check whether the file has declared it is the default lib,
                // and whether the user has specifically chosen to avoid checking it.
                if (m_compilerOptions.SkipDefaultLibCheck.ValueOrDefault)
                {
                    // If the user specified '--noLib' and a file has a '/// <reference no-default-lib="true"/>',
                    // then we should treat that file as a default lib.
                    if (node.HasNoDefaultLib)
                    {
                        return;
                    }
                }

                // Grammar checking
                CheckGrammarSourceFile(node);

                var perFileState = GetPerFileState(node);

                // Need to find qualifiers and templates for the root namespace
                // because it can introduce new edges in file-2-file dependency graph.
                RecordTemplateAndQualifiersForFile2FileRelationship(node);

                ForEach(node.Statements, this, (s, @this) =>
                {
                    @this.CheckSourceElement(s);
                });

                CheckDeferredNodes(perFileState.DeferredNodes);
                perFileState.DeferredNodes = new ConcurrentQueue<INode>();

                if (SourceFileExtensions.IsExternalOrCommonJsModule(node))
                {
                    CheckExternalModuleExports(node);
                }

                if (perFileState.PotentialThisCollisions.Count > 0)
                {
                    ForEach(perFileState.PotentialThisCollisions.ToArray(), this, (s, @this) =>
                    {
                        @this.CheckIfThisIsCapturedInEnclosingScope(s);
                    });

                    perFileState.PotentialThisCollisions = new ConcurrentQueue<INode>();
                }

                if (perFileState.EmitExtends)
                {
                    links.Flags |= NodeCheckFlags.EmitExtends;
                }

                if (perFileState.EmitDecorate)
                {
                    links.Flags |= NodeCheckFlags.EmitDecorate;
                }

                if (perFileState.EmitParam)
                {
                    links.Flags |= NodeCheckFlags.EmitParam;
                }

                if (perFileState.EmitAwaiter)
                {
                    links.Flags |= NodeCheckFlags.EmitAwaiter;
                }

                if (m_emitGenerator || (perFileState.EmitAwaiter && m_languageVersion < ScriptTarget.Es6))
                {
                    links.Flags |= NodeCheckFlags.EmitGenerator;
                }

                links.Flags |= NodeCheckFlags.TypeChecked;
            }
        }

        /// <inheritdoc/>
        public List<Diagnostic> GetDiagnostics(ISourceFile sourceFile, CancellationToken ct)
        {
            try
            {
                // TODO: cancellation is not supoprted properly by managed checker.
                // Cancellation is used only for IDE and managed checker is not supposed to power IDE right now.

                // Record the cancellation token so it can be checked later on during checkSourceElement.
                // Do this in a finally block so we can ensure that it gets reset back to nothing after
                // this call is done.
                m_cancellationToken = ct;
                return GetDiagnosticsWorker(sourceFile);
            }
            finally
            {
                m_cancellationToken = null;
            }
        }

        private List<Diagnostic> GetDiagnosticsWorker(ISourceFile sourceFile)
        {
            ThrowIfNonDiagnosticsProducing();
            if (sourceFile != null)
            {
                CheckSourceFile(sourceFile);
                return m_diagnostics.GetDiagnostics(sourceFile.FileName);
            }

            // Need to check all the source files first.
            ForEach(m_sourceFiles, s =>
            {
                CheckSourceFile(s);
            }, degreeOfParallelism: m_degreeOfParallelism);

            return m_diagnostics.GetDiagnostics();
        }

        /// <inheritdoc/>
        public List<Diagnostic> GetGlobalDiagnostics()
        {
            ThrowIfNonDiagnosticsProducing();
            return m_diagnostics.GetGlobalDiagnostics();
        }

        private void ThrowIfNonDiagnosticsProducing()
        {
            // Incremental mode will be true for the DScript IDE and
            // the IDE does want some level of diagnostics even
            // if the m_produceDiagnostics flag is false.
            // However, if we are not producing diagnostics, and we are not in
            // incremental mode (used for IDE), then we want to
            // know what is requesting diagnostics and why.
            if (!m_produceDiagnostics && !m_interactiveMode)
            {
                throw new InvalidOperationException("Trying to get diagnostics from a type checker that does not produce them.");
            }
        }

        // Language service support
        [System.Diagnostics.Contracts.Pure]
        private static bool IsInsideWithStatementBody(INode node)
        {
            // DScript doesn't support 'with' statements
            return false;
        }

        /// <inheritdoc/>
        public IReadOnlyList<ISymbol> GetSymbolsInScope(INode location, SymbolFlags meaning)
        {
            ISymbolTable symbols = new SymbolTable();
            NodeFlags memberFlags = NodeFlags.None;

            if (IsInsideWithStatementBody(location))
            {
                // We cannot answer semantic questions within a with block, do not proceed any further
                return CollectionUtilities.EmptyArray<ISymbol>();
            }

            var closure = new GetSymbolsInScopeClosure(
                                    this,
                                    location,
                                    meaning,
                                    symbols,
                                    memberFlags);

            closure.PopulateSymbols();
            return SymbolsToArray(symbols);
        }

        private sealed class GetSymbolsInScopeClosure
        {
            private INode m_location;
            private readonly SymbolFlags m_meaning;
            private readonly ISymbolTable m_symbols;
            private NodeFlags m_memberFlags;
            private readonly Checker m_checker;

            public GetSymbolsInScopeClosure(
                Checker checker,
                INode location,
                SymbolFlags meaning,
                ISymbolTable symbols,
                NodeFlags memberFlags)
            {
                m_checker = checker;
                m_location = location;
                m_meaning = meaning;
                m_symbols = symbols;
                m_memberFlags = memberFlags;
            }

            public void PopulateSymbols()
            {
                while (m_location != null)
                {
                    if (m_location.Locals != null && !m_checker.IsGlobalSourceFile(m_location))
                    {
                        CopySymbols(m_location.Locals, m_meaning);
                    }

                    switch (m_location.Kind)
                    {
                        case SyntaxKind.SourceFile:
                        case SyntaxKind.ModuleDeclaration:
                            if (m_location.Kind == SyntaxKind.SourceFile && !IsExternalOrCommonJsModule(m_location.Cast<ISourceFile>()))
                            {
                                break;
                            }

                            CopySymbols(m_checker.GetSymbolOfNode(m_location).Exports, m_meaning & SymbolFlags.ModuleMember);
                            break;

                        case SyntaxKind.EnumDeclaration:
                            CopySymbols(m_checker.GetSymbolOfNode(m_location).Exports, m_meaning & SymbolFlags.EnumMember);
                            break;

                        case SyntaxKind.ClassExpression:
                        case SyntaxKind.ClassDeclaration:
                        case SyntaxKind.InterfaceDeclaration:
                            if (m_location.Kind == SyntaxKind.ClassExpression)
                            {
                                var className = m_location.Cast<IClassExpression>().Name;
                                if (className != null)
                                {
                                    CopySymbol(m_location.Symbol, m_meaning);
                                }
                            }

                            // We would like to handle type parameter inside class expression similar to how we handle it in
                            // classDeclaration and interface Declaration

                            // If we didn't come from static member of class or interface,
                            // add the type parameters into the symbol table
                            // (type parameters of classDeclaration/classExpression and interface are in member property of the symbol.
                            // that Note the memberFlags come from previous iteration.
                            if ((m_memberFlags & NodeFlags.Static) == NodeFlags.None)
                            {
                                CopySymbols(m_checker.GetSymbolOfNode(m_location).Members, m_meaning & SymbolFlags.Type);
                            }

                            break;

                        case SyntaxKind.FunctionExpression:
                            var funcName = m_location.Cast<IFunctionExpression>().Name;
                            if (funcName != null)
                            {
                                CopySymbol(m_location.Symbol, m_meaning);
                            }

                            break;
                    }

                    if (IntroducesArgumentsExoticObject(m_location))
                    {
                        CopySymbol(m_checker.m_argumentsSymbol, m_meaning);
                    }

                    m_memberFlags = m_location.Flags;
                    m_location = m_location.Parent;
                }

                CopySymbols(m_checker.m_globals, m_meaning);
            }

            /// <summary>
            /// Copy the given symbol into symbol tables if the symbol has the given meaning
            /// and it doesn't already existed in the symbol table
            /// </summary>
            /// <param name="symbol">the symbol to be added into symbol table</param>
            /// <param name="meaning">meaning of symbol to filter by before adding to symbol table</param>
            private void CopySymbol(ISymbol symbol, SymbolFlags meaning)
            {
                if ((symbol.Flags & meaning) != SymbolFlags.None)
                {
                    var id = symbol.Name;

                    // We will copy all symbol regardless of its reserved name because
                    // symbolsToArray will check whether the key is a reserved name and
                    // it will not copy symbol with reserved name to the array
                    if (!HasProperty(m_symbols, id))
                    {
                        m_symbols[id] = symbol;
                    }
                }
            }

            private void CopySymbols(ISymbolTable source, SymbolFlags meaning)
            {
                if (meaning != SymbolFlags.None)
                {
                    foreach (var kvp in source)
                    {
                        var id = kvp.Key;
                        var symbol = source[id];
                        CopySymbol(symbol, meaning);
                    }
                }
            }
        }

        private static bool IsTypeDeclarationName(INode name)
        {
            return name.Kind == SyntaxKind.Identifier &&
                IsTypeDeclaration(name.Parent) &&
                name.Parent.Cast<IDeclaration>().Name.ResolveUnionType() == name.ResolveUnionType();
        }

        private static bool IsTypeDeclaration(INode node)
        {
            switch (node.Kind)
            {
                case SyntaxKind.TypeParameter:
                case SyntaxKind.ClassDeclaration:
                case SyntaxKind.InterfaceDeclaration:
                case SyntaxKind.TypeAliasDeclaration:
                case SyntaxKind.EnumDeclaration:
                    return true;
            }

            return false;
        }

        // True if the given identifier is part of a type reference
        private static bool IsTypeReferenceIdentifier(/*HINT: EntityName*/ INode entityName)
        {
            INode node = entityName;

            while (node.Parent != null && node.Parent.Kind == SyntaxKind.QualifiedName)
            {
                node = node.Parent;
            }

            return node.Parent != null && node.Parent.Kind == SyntaxKind.TypeReference;
        }

        [System.Diagnostics.Contracts.Pure]
        private static bool IsHeritageClauseElementIdentifier(INode entityName)
        {
            var node = entityName;

            while (node.Parent != null && node.Parent.Kind == SyntaxKind.PropertyAccessExpression)
            {
                node = node.Parent;
            }

            return node.Parent != null && node.Parent.Kind == SyntaxKind.ExpressionWithTypeArguments;
        }

        [System.Diagnostics.Contracts.Pure]
        private static ExportAssignmentOrImportEqualsDeclaration GetLeftSideOfImportEqualsOrExportAssignment(/*HINT: EntityName*/ INode nodeOnRightSide)
        {
            INode current = nodeOnRightSide;
            while (current.Parent.Kind == SyntaxKind.QualifiedName)
            {
                current = current.Parent;
            }

            var parent = current.Parent;
            if (parent.Kind == SyntaxKind.ImportEqualsDeclaration &&
                parent.Cast<IImportEqualsDeclaration>().ModuleReference.ResolveUnionType() == current.ResolveUnionType())
            {
                return new ExportAssignmentOrImportEqualsDeclaration(parent.Cast<IImportEqualsDeclaration>());
            }

            if (parent.Kind == SyntaxKind.ExportAssignment &&
                parent.Cast<IExportAssignment>().Expression.ResolveUnionType() == nodeOnRightSide.ResolveUnionType())
            {
                return new ExportAssignmentOrImportEqualsDeclaration(parent.Cast<IExportAssignment>());
            }

            return null;
        }

        [System.Diagnostics.Contracts.Pure]
        private static bool IsInRightSideOfImportOrExportAssignment(/*HINT: EntityName*/ INode node)
        {
            return GetLeftSideOfImportEqualsOrExportAssignment(node) != null;
        }

        private ISymbol GetSymbolOfEntityNameOrPropertyAccessExpression(/*HINT: EntityName | IPropertyAccessExpression*/ INode entityName)
        {
            if (IsDeclarationName(entityName) != null)
            {
                return GetSymbolOfNode(entityName.Parent);
            }

            if (entityName.Parent.Kind == SyntaxKind.ExportAssignment)
            {
                return ResolveEntityName(
                    entityName,
                    /*all meanings*/ SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace | SymbolFlags.Alias);
            }

            if (entityName.Kind != SyntaxKind.PropertyAccessExpression)
            {
                if (IsInRightSideOfImportOrExportAssignment(entityName))
                {
                    // Since we already checked for ExportAssignment, this really could only be an Import
                    return GetSymbolOfPartOfRightHandSideOfImportEquals(entityName);
                }
            }

            if (IsRightSideOfQualifiedNameOrPropertyAccess(entityName))
            {
                // entityName = <QualifiedName | PropertyAccessExpression> entityName.Parent;
                var qualifiedName = entityName.Parent.As<IQualifiedName>();
                if (qualifiedName != null)
                {
                    entityName = qualifiedName;
                }
                else
                {
                    entityName = entityName.Parent.Cast<IPropertyAccessExpression>();
                }
            }

            if (IsHeritageClauseElementIdentifier(entityName))
            {
                var meaning = SymbolFlags.None;

                // In an interface or class, we're definitely interested in a type.
                if (entityName.Parent.Kind == SyntaxKind.ExpressionWithTypeArguments)
                {
                    meaning = SymbolFlags.Type;

                    // In a class 'extends' clause we are also looking for a value.
                    if (IsExpressionWithTypeArgumentsInClassExtendsClause(entityName.Parent))
                    {
                        meaning |= SymbolFlags.Value;
                    }
                }
                else
                {
                    meaning = SymbolFlags.Namespace;
                }

                meaning |= SymbolFlags.Alias;
                return ResolveEntityName(entityName, meaning);
            }

            if (IsExpression(entityName))
            {
                if (NodeIsMissing(entityName))
                {
                    // Missing entity name.
                    return null;
                }

                if (entityName.Kind == SyntaxKind.Identifier)
                {
                    // Include aliases in the meaning, this ensures that we do not follow aliases to where they point and instead
                    // return the alias symbol.
                    SymbolFlags meaning = SymbolFlags.Value | SymbolFlags.Alias;
                    return ResolveEntityName(entityName, meaning);
                }

                if (entityName.Kind == SyntaxKind.PropertyAccessExpression)
                {
                    var symbol = GetResolvedSymbol(entityName);
                    if (symbol == null)
                    {
                        CheckPropertyAccessExpression(entityName.Cast<IPropertyAccessExpression>());
                    }

                    return GetResolvedSymbol(entityName);
                }

                if (entityName.Kind == SyntaxKind.QualifiedName)
                {
                    var symbol = GetResolvedSymbol(entityName);
                    if (symbol == null)
                    {
                        CheckQualifiedName(entityName.Cast<IQualifiedName>());
                    }

                    return GetResolvedSymbol(entityName);
                }
            }
            else if (IsTypeReferenceIdentifier(entityName))
            {
                var meaning = entityName.Parent.Kind == SyntaxKind.TypeReference ? SymbolFlags.Type : SymbolFlags.Namespace;

                // Include aliases in the meaning, this ensures that we do not follow aliases to where they point and instead
                // return the alias symbol.
                meaning |= SymbolFlags.Alias;
                return ResolveEntityName(entityName, meaning);
            }

            if (entityName.Parent.Kind == SyntaxKind.TypePredicate)
            {
                return ResolveEntityName(entityName, /*meaning*/ SymbolFlags.FunctionScopedVariable);
            }

            // Do we want to return null here?
            return null;
        }

        /// <inheritdoc/>
        public ISymbol GetSymbolAtLocation(INode node)
        {
            if (IsInsideWithStatementBody(node))
            {
                // We cannot answer semantic questions within a with block, do not proceed any further
                return null;
            }

            if (IsDeclarationName(node) != null)
            {
                // This is a declaration, call GetSymbolOfNode
                return GetSymbolOfNode(node.Parent);
            }

            if (node.Kind == SyntaxKind.Identifier)
            {
                if (IsInRightSideOfImportOrExportAssignment(node))
                {
                    return node.Parent.Kind == SyntaxKind.ExportAssignment
                        ? GetSymbolOfEntityNameOrPropertyAccessExpression(node)
                        : GetSymbolOfPartOfRightHandSideOfImportEquals(node);
                }

                if (node.Parent.Kind == SyntaxKind.BindingElement &&
                    node.Parent.Parent.Kind == SyntaxKind.ObjectBindingPattern &&
                    node.ResolveUnionType() == node.Parent.Cast<IBindingElement>().PropertyName.ResolveUnionType())
                {
                    var typeOfPattern = GetTypeOfNode(node.Parent.Parent);
                    var propertyDeclaration = typeOfPattern != null ? GetPropertyOfType(typeOfPattern, node.Cast<IIdentifier>().Text) : null;

                    if (propertyDeclaration != null)
                    {
                        return propertyDeclaration;
                    }
                }
            }

            switch (node.Kind)
            {
                case SyntaxKind.Identifier:
                case SyntaxKind.PropertyAccessExpression:
                case SyntaxKind.QualifiedName:
                    return GetSymbolOfEntityNameOrPropertyAccessExpression(node);

                case SyntaxKind.ThisKeyword:
                case SyntaxKind.SuperKeyword:
                    var type = IsExpression(node) ? CheckExpression(node) : GetTypeFromTypeNode(node.Cast<ITypeNode>());
                    return type.Symbol;

                case SyntaxKind.ThisType:
                    return GetTypeFromTypeNode(node.Cast<ITypeNode>()).Symbol;

                case SyntaxKind.ConstructorKeyword:
                    // constructor keyword for an overload, should take us to the definition if it exist
                    var constructorDeclaration = node.Parent;
                    if (constructorDeclaration?.Kind == SyntaxKind.Constructor)
                    {
                        return constructorDeclaration.Parent.Cast<IClassDeclaration>().Symbol;
                    }

                    return null;

                case SyntaxKind.StringLiteral:
                    if (node.Parent.IsImportFrom(/*checkArgumentIsStringLiteral*/false))
                    {
                        return ResolveExternalModuleName(node, node.Cast<ILiteralExpression>());
                    }

                    if (node.Kind == SyntaxKind.StringLiteral)
                    {
                        // External module name in an import declaration
                        if ((IsExternalModuleImportEqualsDeclaration(node.Parent.Parent) &&
                             GetExternalModuleImportEqualsDeclarationExpression(node.Parent.Parent).ResolveUnionType() == node.ResolveUnionType()) ||
                            ((node.Parent.Kind == SyntaxKind.ImportDeclaration || node.Parent.Kind == SyntaxKind.ExportDeclaration) &&
                             GetModuleSpecifierFromImportOrExportDeclaration(node.Parent).ResolveUnionType() == node.ResolveUnionType()))
                        {
                            return ResolveExternalModuleName(node, node.Cast<ILiteralExpression>());
                        }
                    }

                    // Explicit fall through to the next case.
                    goto case SyntaxKind.NumericLiteral;
                case SyntaxKind.NumericLiteral:
                    // index access
                    if (node.Parent.Kind == SyntaxKind.ElementAccessExpression &&
                        node.Parent.Cast<IElementAccessExpression>().ArgumentExpression.ResolveUnionType() == node.ResolveUnionType())
                    {
                        var objectType = CheckExpression(node.Parent.Cast<IElementAccessExpression>().Expression);
                        if (objectType == m_unknownType)
                        {
                            return null;
                        }

                        var apparentType = GetApparentType(objectType);
                        if (apparentType == m_unknownType)
                        {
                            return null;
                        }

                        return GetPropertyOfType(apparentType, node.Cast<ILiteralExpression>().Text);
                    }

                    break;
            }

            return null;
        }

        private static IExpression GetModuleSpecifierFromImportOrExportDeclaration(INode node)
        {
            Contract.Assert(node.Kind == SyntaxKind.ImportDeclaration || node.Kind == SyntaxKind.ExportDeclaration);
            var import = node.As<IImportDeclaration>();
            return import != null ? import.ModuleSpecifier : node.Cast<IExportDeclaration>().ModuleSpecifier;
        }

        /// <inheritdoc/>
        public ISymbol GetShorthandAssignmentValueSymbol(INode location)
        {
            // The returns a value symbol of an identifier in the short-hand property assignment.
            // This is necessary as an identifier in short-hand property assignment can contains two meaning:
            // property name and property value.
            if (location != null && location.Kind == SyntaxKind.ShorthandPropertyAssignment)
            {
                return ResolveEntityName(location.Cast<IShorthandPropertyAssignment>().Name, SymbolFlags.Value);
            }

            return null;
        }

        private IType GetTypeOfNode(INode node)
        {
            if (IsInsideWithStatementBody(node))
            {
                // We cannot answer semantic questions within a with block, do not proceed any further
                return m_unknownType;
            }

            if (IsTypeNode(node))
            {
                return GetTypeFromTypeNode(node.Cast<ITypeNode>());
            }

            if (IsExpression(node))
            {
                return GetTypeOfExpression(node.Cast<IExpression>());
            }

            if (IsExpressionWithTypeArgumentsInClassExtendsClause(node))
            {
                // A SyntaxKind.ExpressionWithTypeArguments is considered a type node, except when it occurs in the
                // extends clause of a class. We handle that case here.
                return GetBaseTypes(GetDeclaredTypeOfSymbol(GetSymbolOfNode(node.Parent.Parent)).Cast<IInterfaceType>())[0];
            }

            if (IsTypeDeclaration(node))
            {
                // In this case, we call GetSymbolOfNode instead of GetSymbolAtLocation because it is a declaration
                var symbol = GetSymbolOfNode(node);
                return GetDeclaredTypeOfSymbol(symbol);
            }

            if (IsTypeDeclarationName(node))
            {
                var symbol = GetSymbolAtLocation(node);
                return symbol != null ? GetDeclaredTypeOfSymbol(symbol) : null;
            }

            if (IsDeclaration(node))
            {
                // In this case, we call GetSymbolOfNode instead of GetSymbolAtLocation because it is a declaration
                var symbol = GetSymbolOfNode(node);
                return GetTypeOfSymbol(symbol);
            }

            if (IsDeclarationName(node) != null)
            {
                var symbol = GetSymbolAtLocation(node);
                return symbol != null ? GetTypeOfSymbol(symbol) : null;
            }

            if (IsBindingPattern(node) != null)
            {
                return GetTypeForVariableLikeDeclaration(node.Parent.Cast<IVariableLikeDeclaration>());
            }

            if (IsInRightSideOfImportOrExportAssignment(node))
            {
                var symbol = GetSymbolAtLocation(node);
                var declaredType = symbol != null ? GetDeclaredTypeOfSymbol(symbol) : null;
                return declaredType != m_unknownType ? declaredType : GetTypeOfSymbol(symbol);
            }

            return m_unknownType;
        }

        private IType GetTypeOfExpression(IExpression expr)
        {
            if (IsRightSideOfQualifiedNameOrPropertyAccess(expr))
            {
                expr = expr.Parent.Cast<IExpression>();
            }

            return CheckExpression(expr);
        }

        /// <summary>
        /// Gets either the static or instance type of a class element, based on
        /// whether the element is declared as "static".
        /// </summary>
        private IType GetParentTypeOfClassElement(IClassElement node)
        {
            var classSymbol = GetSymbolOfNode(node.Parent);
            return (node.Flags & NodeFlags.Static) != NodeFlags.None
                ? GetTypeOfSymbol(classSymbol)
                : GetDeclaredTypeOfSymbol(classSymbol);
        }

        /// <summary>
        /// Return the list of properties of the given type, augmented with properties from Function
        /// if the type has call or construct signatures
        /// </summary>
        public IReadOnlyList<ISymbol> GetAugmentedPropertiesOfType(IType type)
        {
            type = GetApparentType(type);
            var propsByName = SymbolTable.Create(GetPropertiesOfType(type));
            if (GetSignaturesOfType(type, SignatureKind.Call)?.Count != 0 || GetSignaturesOfType(type, SignatureKind.Construct)?.Count != 0)
            {
                ForEach(GetPropertiesOfType(m_globalFunctionType), propsByName, (p, propertiesByName) =>
                {
                    if (!HasProperty(propertiesByName, p.Name))
                    {
                        propertiesByName[p.Name] = p;
                    }
                });
            }

            return GetNamedMembers(propsByName);
        }

        /// <inheritdoc/>
        public List<ISymbol> GetRootSymbols(ISymbol symbol)
        {
            if ((symbol.Flags & SymbolFlags.SyntheticProperty) != SymbolFlags.None)
            {
                List<ISymbol> symbols = new List<ISymbol>();
                var name = symbol.Name;
                ForEach(GetSymbolLinks(symbol).ContainingType.Types, t =>
                {
                    var s = GetPropertyOfType(t, name);
                    if (s != null)
                    {
                        symbols.Add(s);
                    }
                });

                return symbols;
            }

            if ((symbol.Flags & SymbolFlags.Transient) != SymbolFlags.None)
            {
                var target = GetSymbolLinks(symbol).Target;
                if (target != null)
                {
                    return new List<ISymbol>() { target };
                }
            }

            return new List<ISymbol>() { symbol };
        }

        // Emitter support
        private bool IsArgumentsLocalBinding(IIdentifier node)
        {
            return GetReferencedValueSymbol(node) == m_argumentsSymbol;
        }

        private bool ModuleExportsSomeValue(IExpression moduleReferenceExpression)
        {
            var moduleSymbol = ResolveExternalModuleName(moduleReferenceExpression.Parent, moduleReferenceExpression);
            if (moduleSymbol == null)
            {
                // module not found - be conservative
                return true;
            }

            var hasExportAssignment = GetExportAssignmentSymbol(moduleSymbol) != null;

            // if module has export assignment then 'GetExportAssignmentSymbol' will return resolved symbol for export assignment
            // otherwise it will return moduleISymbol itself
            moduleSymbol = GetExportAssignmentSymbol(moduleSymbol);

            return GetSymbolLinks(moduleSymbol).GetOrSetExportsSomeValue(this, (links, @this) =>
            {
                // for export assignments - check if resolved symbol for RHS is itself a value
                // otherwise - check if at least one export is value
                return hasExportAssignment
                    ? (moduleSymbol.Flags & SymbolFlags.Value) != SymbolFlags.None
                    : GetExportsOfModule(moduleSymbol).Enumerate().Any(IsValue);
            });
        }

        private bool IsValue(ISymbol s)
        {
            s = ResolveSymbol(s);
            return s != null && (s.Flags & SymbolFlags.Value) != SymbolFlags.None;
        }

        /// <summary>
        /// When resolved as an expression identifier, if the given node references an exported entity, return the declaration
        /// node of the exported entity's container. Otherwise, return null.
        /// </summary>
        private /*HINT: ISourceFile | IModuleDeclaration | IEnumDeclaration*/ IDeclaration GetReferencedExportContainer(IIdentifier node)
        {
            var symbol = GetReferencedValueSymbol(node);
            if (symbol != null)
            {
                if ((symbol.Flags & SymbolFlags.ExportValue) != SymbolFlags.None)
                {
                    // If we reference an exported entity within the same module declaration, then whether
                    // we prefix depends on the kind of entity. SymbolFlags.ExportHasLocal encompasses all the
                    // kinds that we do NOT prefix.
                    var exportSymbol = GetMergedSymbol(symbol.ExportSymbol);
                    if ((exportSymbol.Flags & SymbolFlags.ExportHasLocal) != SymbolFlags.None)
                    {
                        return null;
                    }

                    symbol = exportSymbol;
                }

                var parentSymbol = GetParentOfSymbol(symbol);
                if (parentSymbol != null)
                {
                    if ((parentSymbol.Flags & SymbolFlags.ValueModule) != SymbolFlags.None &&
                        parentSymbol.ValueDeclaration?.Kind == SyntaxKind.SourceFile)
                    {
                        return parentSymbol.ValueDeclaration;
                    }

                    for (var n = node.Parent; n != null; n = n.Parent)
                    {
                        if ((n.Kind == SyntaxKind.ModuleDeclaration || n.Kind == SyntaxKind.EnumDeclaration) && GetSymbolOfNode(n) == parentSymbol)
                        {
                            return n.Cast<IDeclaration>();
                        }
                    }
                }
            }

            return null;
        }

        // When resolved as an expression identifier, if the given node references an import, return the declaration of
        // that import. Otherwise, return null.
        private IDeclaration GetReferencedImportDeclaration(IIdentifier node)
        {
            var symbol = GetReferencedValueSymbol(node);
            return symbol != null && (symbol.Flags & SymbolFlags.Alias) != SymbolFlags.None ? GetDeclarationOfAliasSymbol(symbol) : null;
        }

        private static bool IsStatementWithLocals(INode node)
        {
            switch (node.Kind)
            {
                case SyntaxKind.Block:
                case SyntaxKind.CaseBlock:
                case SyntaxKind.ForStatement:
                case SyntaxKind.ForInStatement:
                case SyntaxKind.ForOfStatement:
                    return true;
            }

            return false;
        }

        private bool IsNestedRedeclarationSymbol(ISymbol symbolArg)
        {
            if ((symbolArg.Flags & SymbolFlags.BlockScoped) != SymbolFlags.None)
            {
                return GetSymbolLinks(symbolArg).GetOrSetIsNestedRedeclaration((checker: this, symbolArg), (links, tuple) =>
                {
                    var @this = tuple.checker;
                    var symbol = tuple.symbolArg;
                    var container = GetEnclosingBlockScopeContainer(symbol.ValueDeclaration);
                    return IsStatementWithLocals(container) &&
                        @this.ResolveName(container.Parent, symbol.Name, SymbolFlags.Value, /*nameNotFoundMessage*/ null, /*nameArg*/ (string)null) != null;
                });
            }

            return false;
        }

        // When resolved as an expression identifier, if the given node references a nested block scoped entity with
        // a name that hides an existing name, return the declaration of that entity. Otherwise, return null.
        private IDeclaration GetReferencedNestedRedeclaration(IIdentifier node)
        {
            var symbol = GetReferencedValueSymbol(node);
            return symbol != null && IsNestedRedeclarationSymbol(symbol) ? symbol.ValueDeclaration : null;
        }

        // Return true if the given node is a declaration of a nested block scoped entity with a name that hides an
        // existing name.
        private bool IsNestedRedeclaration(IDeclaration node)
        {
            return IsNestedRedeclarationSymbol(GetSymbolOfNode(node));
        }

        private bool IsValueAliasDeclaration(INode node)
        {
            switch (node.Kind)
            {
                case SyntaxKind.ImportEqualsDeclaration:
                case SyntaxKind.ImportClause:
                case SyntaxKind.NamespaceImport:
                case SyntaxKind.ImportSpecifier:
                case SyntaxKind.ExportSpecifier:
                    return IsAliasResolvedToValue(GetSymbolOfNode(node));

                case SyntaxKind.ExportDeclaration:
                    var exportClause = node.Cast<IExportDeclaration>().ExportClause;
                    return exportClause != null && Any(exportClause.Elements, e => IsValueAliasDeclaration(e));

                case SyntaxKind.ExportAssignment:
                    return node.Cast<IExportAssignment>().Expression != null && node.Cast<IExportAssignment>().Expression.Kind == SyntaxKind.Identifier ?
                        IsAliasResolvedToValue(GetSymbolOfNode(node)) :
                        true;
            }

            return false;
        }

        private bool IsTopLevelValueImportEqualsWithEntityName(IImportEqualsDeclaration node)
        {
            if (node.Parent.Kind != SyntaxKind.SourceFile || !IsInternalModuleImportEqualsDeclaration(node))
            {
                // parent is not source file or it is not reference to internal module
                return false;
            }

            var isValue = IsAliasResolvedToValue(GetSymbolOfNode(node));
            return isValue && node.ModuleReference != null && !NodeIsMissing(node.ModuleReference);
        }

        private bool IsAliasResolvedToValue(ISymbol symbol)
        {
            var target = ResolveAlias(symbol);
            if (target == m_unknownSymbol && m_compilerOptions.IsolatedModules.HasValue && m_compilerOptions.IsolatedModules.Value)
            {
                return true;
            }

            // const enums and modules that contain only const enums are not considered values from the emit perespective
            // unless 'preserveConstEnums' option is set to true
            return target != m_unknownSymbol &&
                   target != null &&
                   (target.Flags & SymbolFlags.Value) != SymbolFlags.None &&
                   ((m_compilerOptions.PreserveConstEnums.HasValue && m_compilerOptions.PreserveConstEnums.Value) || !IsConstEnumOrConstEnumOnlyModule(target));
        }

        private static bool IsConstEnumOrConstEnumOnlyModule(ISymbol s)
        {
            return IsConstEnumSymbol(s)
                || false;

            // const enum modules are not supported
            // || (s.ConstEnumOnlyModule.HasValue && s.ConstEnumOnlyModule.Value);
        }

        // Need to use custom class called Boolean to work around ForEachChild restriction that result type should be a class.
        // Consider changing this in the future.
        private Bool IsReferencedAliasDeclaration(INode node, bool checkChildren)
        {
            if (IsAliasSymbolDeclaration(node))
            {
                var symbol = GetSymbolOfNode(node);
                var symbolLinks = GetSymbolLinks(symbol);

                if (symbolLinks.Referenced.HasValue && symbolLinks.Referenced.Value)
                {
                    return true;
                }
            }

            if (checkChildren)
            {
                return NodeWalker.ForEachChild(node, this, (n, @this) => @this.IsReferencedAliasDeclaration(n, true));
            }

            return false;
        }

        /// <inheritdoc/>
        public bool IsImplementationOfOverload(IFunctionLikeDeclaration node)
        {
            if (NodeIsPresent(node.Body))
            {
                var symbol = GetSymbolOfNode(node);
                var signaturesOfSymbol = GetSignaturesOfSymbol(symbol);

                // If this function body corresponds to function with multiple signature, it is implementation of overload
                // e.g.: function foo(a: string): string;
                //       function foo(a: number): number;
                //       function foo(a: any) { // This is implementation of the overloads
                //           return a;
                //       }
                return signaturesOfSymbol.Count > 1 ||

                // If there is single signature for the symbol, it is overload if that signature isn't coming from the node
                // e.g.: function foo(a: string): string;
                //       function foo(a: any) { // This is implementation of the overloads
                //           return a;
                //       }
                (signaturesOfSymbol.Count == 1 && signaturesOfSymbol[0].Declaration.ResolveUnionType() != node.ResolveUnionType());
            }

            return false;
        }

        private NodeCheckFlags GetNodeCheckFlags(INode node)
        {
            return TryGetNodeLinks(node)?.Flags ?? NodeCheckFlags.None;
        }

        private int GetEnumMemberValue(IEnumMember node)
        {
            ComputeEnumMemberValues(node.Parent.Cast<IEnumDeclaration>());

            return TryGetNodeLinks(node)?.EnumMemberValue.ValueOrDefault() ?? 0;
        }

        /// <inheritdoc/>
        public int? GetConstantValue(/*HINT: IEnumMember | IPropertyAccessExpression | IElementAccessExpression*/ INode node)
        {
            if (node.Kind == SyntaxKind.EnumMember)
            {
                return GetEnumMemberValue(node.Cast<IEnumMember>());
            }

            var symbol = GetResolvedSymbol(node);
            if (symbol != null && ((symbol.Flags & SymbolFlags.EnumMember) != SymbolFlags.None))
            {
                // inline property\index accesses only for const enums
                if (IsConstEnumDeclaration(symbol.ValueDeclaration.Parent))
                {
                    return GetEnumMemberValue(symbol.ValueDeclaration.Cast<IEnumMember>());
                }
            }

            return null;
        }

        private bool IsFunctionType(IType type)
        {
            return (type.Flags & TypeFlags.ObjectType) != TypeFlags.None && GetSignaturesOfType(type, SignatureKind.Call)?.Count > 0;
        }

        private TypeReferenceSerializationKind GetTypeReferenceSerializationKind(/*HINT: EntityName*/ INode typeName)
        {
            // Resolve the symbol as a value to ensure the type can be reached at runtime during emit.
            var valueSymbol = ResolveEntityName(typeName, SymbolFlags.Value, /*ignoreErrors*/ true);
            var constructorType = valueSymbol != null ? GetTypeOfSymbol(valueSymbol) : null;
            if (constructorType != null && IsConstructorType(constructorType))
            {
                return TypeReferenceSerializationKind.TypeWithConstructSignatureAndValue;
            }

            // Resolve the symbol as a type so that we can provide a more useful hint for the type serializer.
            var typeSymbol = ResolveEntityName(typeName, SymbolFlags.Type, /*ignoreErrors*/ true);

            // We might not be able to resolve type symbol so use unknown type in that case (eg error case)
            if (typeSymbol == null)
            {
                return TypeReferenceSerializationKind.ObjectType;
            }

            var type = GetDeclaredTypeOfSymbol(typeSymbol);
            if (type == m_unknownType)
            {
                return TypeReferenceSerializationKind.Unknown;
            }
            else if ((type.Flags & TypeFlags.Any) != TypeFlags.None)
            {
                return TypeReferenceSerializationKind.ObjectType;
            }
            else if (IsTypeOfKind(type, TypeFlags.Void))
            {
                return TypeReferenceSerializationKind.VoidType;
            }
            else if (IsTypeOfKind(type, TypeFlags.Boolean))
            {
                return TypeReferenceSerializationKind.BooleanType;
            }
            else if (IsTypeOfKind(type, TypeFlags.NumberLike))
            {
                return TypeReferenceSerializationKind.NumberLikeType;
            }
            else if (IsTypeOfKind(type, TypeFlags.StringLike))
            {
                return TypeReferenceSerializationKind.StringLikeType;
            }
            else if (IsTypeOfKind(type, TypeFlags.Tuple))
            {
                return TypeReferenceSerializationKind.ArrayLikeType;
            }
            else if (IsTypeOfKind(type, TypeFlags.EsSymbol))
            {
                return TypeReferenceSerializationKind.EsSymbolType;
            }
            else if (IsFunctionType(type))
            {
                return TypeReferenceSerializationKind.TypeWithCallSignature;
            }
            else if (IsArrayType(type))
            {
                return TypeReferenceSerializationKind.ArrayLikeType;
            }
            else
            {
                return TypeReferenceSerializationKind.ObjectType;
            }
        }

        private void WriteTypeOfDeclaration(/*HINT: IAccessorDeclaration | IVariableLikeDeclaration*/ INode declaration, INode enclosingDeclaration, TypeFormatFlags flags, ISymbolWriter writer)
        {
            // Get type of the symbol if this is the valid symbol otherwise get type at location
            var symbol = GetSymbolOfNode(declaration);
            var type = symbol != null && ((symbol.Flags & (SymbolFlags.TypeLiteral | SymbolFlags.Signature)) == SymbolFlags.None)
                ? GetTypeOfSymbol(symbol)
                : m_unknownType;

            GetSymbolDisplayBuilder().BuildTypeDisplay(type, writer, enclosingDeclaration, flags);
        }

        private void WriteReturnTypeOfSignatureDeclaration(ISignatureDeclaration signatureDeclaration, INode enclosingDeclaration, TypeFormatFlags flags, ISymbolWriter writer)
        {
            var signature = GetSignatureFromDeclaration(signatureDeclaration);
            GetSymbolDisplayBuilder().BuildTypeDisplay(GetReturnTypeOfSignature(signature), writer, enclosingDeclaration, flags);
        }

        private void WriteTypeOfExpression(IExpression expr, INode enclosingDeclaration, TypeFormatFlags flags, ISymbolWriter writer)
        {
            var type = GetTypeOfExpression(expr);
            GetSymbolDisplayBuilder().BuildTypeDisplay(type, writer, enclosingDeclaration, flags);
        }

        private bool HasGlobalName(string name)
        {
            return HasProperty(m_globals, name);
        }

        private ISymbol GetReferencedValueSymbol(IIdentifier reference)
        {
            return
                GetResolvedSymbol(reference) ??
                ResolveName(reference, reference.Text, SymbolFlags.Value | SymbolFlags.ExportValue | SymbolFlags.Alias,
                    /*nodeNotFoundMessage*/ null, /*nameArg*/ (string)null);
        }

        private IDeclaration GetReferencedValueDeclaration(IIdentifier reference)
        {
            Contract.Requires(!NodeIsSynthesized(reference));

            var symbol = GetReferencedValueSymbol(reference);
            return symbol == null ? null : GetExportSymbolOfValueSymbolIfExported(symbol).ValueDeclaration;
        }

        private ISourceFile GetExternalModuleFileFromDeclaration(/*HINT: IImportEqualsDeclaration | IImportDeclaration | IExportDeclaration*/ INode declaration)
        {
            var specifier = GetExternalModuleName(declaration);
            var moduleSymbol = GetSymbolAtLocation(specifier);
            if (moduleSymbol == null)
            {
                return null;
            }

            return GetDeclarationOfKind(moduleSymbol, SyntaxKind.SourceFile).As<ISourceFile>();
        }

        private static bool IsScriptProject(ISourceFile[] sources)
        {
            return sources.Any(s => s.IsScriptFile());
        }

        private void InitializeTypeChecker()
        {
            m_sourceFiles = m_host.GetSourceFiles();

            // Bind all source files and propagate errors
            ForEach(m_sourceFiles, file =>
            {
                Binder.Bind(file, m_compilerOptions);
            }, degreeOfParallelism: m_degreeOfParallelism);

            m_isScriptFile = IsScriptProject(m_sourceFiles);

            // Initialize global symbol table
            ForEach(m_sourceFiles, (index, file) =>
            {
                ((SourceFile)file).InitDependencyMaps(index, m_sourceFiles.Length);
                ModuleName preludeName;
                var hasPrelude = m_host.TryGetPreludeModuleName(out preludeName);
                ModuleName moduleName;

                // DScript-specific. We check if the spec is owned by a module with implicit references, and in that case
                // we populate the module symbol information
                // DScript-specific. The prelude is always considered to be an internal module, despite its shape
                if (m_host.TryGetOwningModule(file.FileName, out moduleName) && moduleName.ProjectReferencesAreImplicit)
                {
                    lock (this)
                    {
                        AddFileSymbolInformationToModule(moduleName.Name, file);
                    }
                }
                else if (!IsExternalOrCommonJsModule(file) || (hasPrelude && preludeName.Equals(moduleName)))
                {
                    lock (this)
                    {
                        MergeSymbolTable(m_globals, file.Locals);
                    }
                }
            }, degreeOfParallelism: m_degreeOfParallelism);

            // Setup global builtins
            AddToSymbolTable(m_globals, m_builtinGlobals, Errors.Declaration_name_conflicts_with_built_in_global_identifier_0);

            GetSymbolLinks(m_undefinedSymbol).Type = m_undefinedType;
            GetSymbolLinks(m_argumentsSymbol).Type = GetGlobalType("IArguments");
            GetSymbolLinks(m_unknownSymbol).Type = m_unknownType;

            // Initialize special types
            m_globalArrayType = (IGenericType)GetGlobalType("Array", /*arity*/ 1);
            m_globalObjectType = GetGlobalType("Object");
            m_globalFunctionType = GetGlobalType("Function");
            m_globalStringType = GetGlobalType("String");
            m_globalNumberType = GetGlobalType("Number");
            m_globalBooleanType = GetGlobalType("Boolean");
            m_globalRegExpType = GetGlobalType("RegExp");

            m_getGlobalTypedPropertyDescriptorType = Memoize(() => GetGlobalType("TypedPropertyDescriptor", /*arity*/ 1));
            m_getGlobalPromiseType = Memoize(() => GetGlobalType("Promise", /*arity*/ 1));

            // TODO: if we ever want to support Promise in DScript, we need to fix this.
            m_tryGetGlobalPromiseType = Memoize(() => /*(IObjectType)GetGlobalSymbol("Promise", SymbolFlags.Type, diagnostic: null) ??*/ m_getGlobalPromiseType());
            m_getGlobalPromiseLikeType = Memoize(() => GetGlobalType("PromiseLike", /*arity*/ 1));
            m_getInstantiatedGlobalPromiseLikeType = Memoize(CreateInstantiatedPromiseLikeType);
            m_getGlobalPromiseConstructorLikeType = Memoize(() => GetGlobalType("PromiseConstructorLike"));
            m_getGlobalThenableType = Memoize(CreateThenableType);

            // If we're in ES6 mode, load the TemplateStringsArray.
            // Otherwise, default to 'unknown' for the purposes of type checking in LS scenarios.
            if (m_languageVersion >= ScriptTarget.Es6)
            {
                m_globalTemplateStringsArrayType = GetGlobalType("TemplateStringsArray");
                m_globalEsSymbolType = GetGlobalType("Symbol");
                m_globalEsSymbolConstructorSymbol = GetGlobalValueSymbol("Symbol");
                m_globalIterableType = (IGenericType)GetGlobalType("Iterable", /*arity*/ 1);
                m_globalIteratorType = (IGenericType)GetGlobalType("Iterator", /*arity*/ 1);
                m_globalIterableIteratorType = (IGenericType)GetGlobalType("IterableIterator", /*arity*/ 1);
            }
            else
            {
                m_globalTemplateStringsArrayType = m_unknownType;

                // Consider putting ISymbol interface in lib.D.ts. On the plus side, putting it in lib.D.ts would make it
                // extensible for Polyfilling Symbols. But putting it into lib.D.ts could also break users that have
                // a global ISymbol already, particularly if it is a class.
                m_globalEsSymbolType = CreateAnonymousType(null, s_emptySymbols, s_emptySignatureEnumerable, s_emptySignatureEnumerable, null, null);
                m_globalEsSymbolConstructorSymbol = null;
                m_globalIterableType = m_emptyGenericType;
                m_globalIteratorType = m_emptyGenericType;
                m_globalIterableIteratorType = m_emptyGenericType;
            }

            m_anyArrayType = CreateArrayType(m_anyType);
        }

        private IObjectType CreateInstantiatedPromiseLikeType()
        {
            var promiseLikeType = m_getGlobalPromiseLikeType();
            if (promiseLikeType != m_emptyGenericType)
            {
                return CreateTypeReference((IGenericType)promiseLikeType, new List<IType>() { m_anyType });
            }

            return m_emptyObjectType;
        }

        private IResolvedType CreateThenableType()
        {
            // build the thenable type that is used to verify against a non-promise "thenable" operand to `await`.
            var thenPropertySymbol = CreateSymbol(SymbolFlags.Transient | SymbolFlags.Property, "then");
            GetSymbolLinks(thenPropertySymbol).Type = m_globalFunctionType;

            var thenableType = (IResolvedType)CreateObjectType<ResolvedType>(TypeFlags.Anonymous);
            var properties = new List<ISymbol>() { thenPropertySymbol };
            var resolvedTypeData = new ResolvedTypeData()
            {
                Properties = properties,
                Members = SymbolTable.Create(properties),
                CallSignatures = new List<ISignature>(),
                ConstructSignatures = new List<ISignature>(),
            };

            return thenableType.Resolve(resolvedTypeData);
        }

        // GRAMMAR CHECKING
        private bool CheckGrammarDecorators(INode node)
        {
            if (node.Decorators == null)
            {
                return false;
            }

            if (!NodeCanBeDecorated(node, m_isScriptFile))
            {
                return GrammarErrorOnFirstToken(node, Errors.Decorators_are_not_valid_here);
            }
            else if (node.Kind == SyntaxKind.GetAccessor || node.Kind == SyntaxKind.SetAccessor)
            {
                var accessors = GetAllAccessorDeclarations(node.Parent.Cast<IClassDeclaration>().Members, node.Cast<IAccessorDeclaration>());
                if (accessors.FirstAccessor.Decorators != null && node.ResolveUnionType() == accessors.SecondAccessor.ResolveUnionType())
                {
                    return GrammarErrorOnFirstToken(node, Errors.Decorators_cannot_be_applied_to_multiple_get_Slashset_accessors_of_the_same_name);
                }
            }

            return false;
        }

        private bool CheckGrammarModifiers(INode node)
        {
            switch (node.Kind)
            {
                case SyntaxKind.GetAccessor:
                case SyntaxKind.SetAccessor:
                case SyntaxKind.Constructor:
                case SyntaxKind.PropertyDeclaration:
                case SyntaxKind.PropertySignature:
                case SyntaxKind.MethodDeclaration:
                case SyntaxKind.MethodSignature:
                case SyntaxKind.IndexSignature:
                case SyntaxKind.ModuleDeclaration:
                case SyntaxKind.ImportDeclaration:
                case SyntaxKind.ImportEqualsDeclaration:
                case SyntaxKind.ExportDeclaration:
                case SyntaxKind.ExportAssignment:
                case SyntaxKind.Parameter:
                    break;

                case SyntaxKind.FunctionDeclaration:
                    if (node.Modifiers != null && (node.Modifiers.Count > 1 || (node.Modifiers.Count > 0 && node.Modifiers[0].Kind != SyntaxKind.AsyncKeyword)) &&
                        node.Parent.Kind != SyntaxKind.ModuleBlock && node.Parent.Kind != SyntaxKind.SourceFile)
                    {
                        return GrammarErrorOnFirstToken(node, Errors.Modifiers_cannot_appear_here);
                    }

                    break;

                case SyntaxKind.ClassDeclaration:
                case SyntaxKind.InterfaceDeclaration:
                case SyntaxKind.VariableStatement:
                case SyntaxKind.TypeAliasDeclaration:
                    if (node.Modifiers != null && node.Parent.Kind != SyntaxKind.ModuleBlock && node.Parent.Kind != SyntaxKind.SourceFile)
                    {
                        return GrammarErrorOnFirstToken(node, Errors.Modifiers_cannot_appear_here);
                    }

                    break;

                case SyntaxKind.EnumDeclaration:
                    if (node.Modifiers != null && (node.Modifiers.Count > 1 || (node.Modifiers.Count > 0 && node.Modifiers[0].Kind != SyntaxKind.ConstKeyword)) &&
                        node.Parent.Kind != SyntaxKind.ModuleBlock && node.Parent.Kind != SyntaxKind.SourceFile)
                    {
                        return GrammarErrorOnFirstToken(node, Errors.Modifiers_cannot_appear_here);
                    }

                    break;

                default:
                    return false;
            }

            if (node.Modifiers == null)
            {
                // TODO: original implementation returns nothing.
                // Potentially, it means that this function returns 3 different states: true, false, undefined
                return false;
            }

            INode lastStatic = null, lastPrivate = null, lastProtected = null, lastDeclare = null, lastAsync = null;
            NodeFlags flags = NodeFlags.None;

            foreach (var modifier in node.Modifiers)
            {
                switch (modifier.Kind)
                {
                    case SyntaxKind.ConstKeyword:
                        if (node.Kind != SyntaxKind.EnumDeclaration && node.Parent.Kind == SyntaxKind.ClassDeclaration)
                        {
                            return GrammarErrorOnNode(node, Errors.A_class_member_cannot_have_the_0_keyword, TokenToString(SyntaxKind.ConstKeyword));
                        }

                        break;

                    case SyntaxKind.PublicKeyword:
                    case SyntaxKind.ProtectedKeyword:
                    case SyntaxKind.PrivateKeyword:
                        string text = null;
                        if (modifier.Kind == SyntaxKind.PublicKeyword)
                        {
                            text = "public";
                        }
                        else if (modifier.Kind == SyntaxKind.ProtectedKeyword)
                        {
                            text = "protected";
                            lastProtected = modifier;
                        }
                        else
                        {
                            text = "private";
                            lastPrivate = modifier;
                        }

                        if ((flags & NodeFlags.AccessibilityModifier) != NodeFlags.None)
                        {
                            return GrammarErrorOnNode(modifier, Errors.Accessibility_modifier_already_seen);
                        }
                        else if ((flags & NodeFlags.Static) != NodeFlags.None)
                        {
                            return GrammarErrorOnNode(modifier, Errors.Modifier0_must_precede_modifier1, text, "static");
                        }
                        else if ((flags & NodeFlags.Async) != NodeFlags.None)
                        {
                            return GrammarErrorOnNode(modifier, Errors.Modifier0_must_precede_modifier1, text, "async");
                        }
                        else if (node.Parent.Kind == SyntaxKind.ModuleBlock || node.Parent.Kind == SyntaxKind.SourceFile)
                        {
                            return GrammarErrorOnNode(modifier, Errors.Modifier0_cannot_appear_on_a_module_element, text);
                        }
                        else if ((flags & NodeFlags.Abstract) != NodeFlags.None)
                        {
                            if (modifier.Kind == SyntaxKind.PrivateKeyword)
                            {
                                return GrammarErrorOnNode(modifier, Errors.Zero_modifier_cannot_be_used_with_1_modifier, text, "abstract");
                            }
                            else
                            {
                                return GrammarErrorOnNode(modifier, Errors.Modifier0_must_precede_modifier1, text, "abstract");
                            }
                        }

                        flags |= modifier.Kind.ModifierToFlag();
                        break;

                    case SyntaxKind.StaticKeyword:
                        if ((flags & NodeFlags.Static) != NodeFlags.None)
                        {
                            return GrammarErrorOnNode(modifier, Errors.Modifier0_already_seen, "static");
                        }
                        else if ((flags & NodeFlags.Async) != NodeFlags.None)
                        {
                            return GrammarErrorOnNode(modifier, Errors.Modifier0_must_precede_modifier1, "static", "async");
                        }
                        else if (node.Parent.Kind == SyntaxKind.ModuleBlock || node.Parent.Kind == SyntaxKind.SourceFile)
                        {
                            return GrammarErrorOnNode(modifier, Errors.Modifier0_cannot_appear_on_a_module_element, "static");
                        }
                        else if (node.Kind == SyntaxKind.Parameter)
                        {
                            return GrammarErrorOnNode(modifier, Errors.Zero_modifier_cannot_appear_on_a_parameter, "static");
                        }
                        else if ((flags & NodeFlags.Abstract) != NodeFlags.None)
                        {
                            return GrammarErrorOnNode(modifier, Errors.Zero_modifier_cannot_be_used_with_1_modifier, "static", "abstract");
                        }

                        flags |= NodeFlags.Static;
                        lastStatic = modifier;
                        break;

                    case SyntaxKind.ExportKeyword:
                        if ((flags & NodeFlags.Export) != NodeFlags.None)
                        {
                            return GrammarErrorOnNode(modifier, Errors.Modifier0_already_seen, "export");
                        }
                        else if ((flags & NodeFlags.Ambient) != NodeFlags.None)
                        {
                            return GrammarErrorOnNode(modifier, Errors.Modifier0_must_precede_modifier1, "export", "declare");
                        }
                        else if ((flags & NodeFlags.Abstract) != NodeFlags.None)
                        {
                            return GrammarErrorOnNode(modifier, Errors.Modifier0_must_precede_modifier1, "export", "abstract");
                        }
                        else if ((flags & NodeFlags.Async) != NodeFlags.None)
                        {
                            return GrammarErrorOnNode(modifier, Errors.Modifier0_must_precede_modifier1, "export", "async");
                        }
                        else if (node.Parent.Kind == SyntaxKind.ClassDeclaration)
                        {
                            return GrammarErrorOnNode(modifier, Errors.Modifier0_cannot_appear_on_a_class_element, "export");
                        }
                        else if (node.Kind == SyntaxKind.Parameter)
                        {
                            return GrammarErrorOnNode(modifier, Errors.Zero_modifier_cannot_appear_on_a_parameter, "export");
                        }

                        flags |= NodeFlags.Export;
                        break;

                    case SyntaxKind.DeclareKeyword:
                        if ((flags & NodeFlags.Ambient) != NodeFlags.None)
                        {
                            return GrammarErrorOnNode(modifier, Errors.Modifier0_already_seen, "declare");
                        }
                        else if ((flags & NodeFlags.Async) != NodeFlags.None)
                        {
                            return GrammarErrorOnNode(modifier, Errors.Modifier0_cannot_be_used_in_an_ambient_context, "async");
                        }
                        else if (node.Parent.Kind == SyntaxKind.ClassDeclaration)
                        {
                            return GrammarErrorOnNode(modifier, Errors.Modifier0_cannot_appear_on_a_class_element, "declare");
                        }
                        else if (node.Kind == SyntaxKind.Parameter)
                        {
                            return GrammarErrorOnNode(modifier, Errors.Zero_modifier_cannot_appear_on_a_parameter, "declare");
                        }
                        else if (IsInAmbientContext(node.Parent) && node.Parent.Kind == SyntaxKind.ModuleBlock)
                        {
                            return GrammarErrorOnNode(modifier, Errors.A_declare_modifier_cannot_be_used_in_an_already_ambient_context);
                        }

                        flags |= NodeFlags.Ambient;
                        lastDeclare = modifier;
                        break;

                    case SyntaxKind.AbstractKeyword:
                        if ((flags & NodeFlags.Abstract) != NodeFlags.None)
                        {
                            return GrammarErrorOnNode(modifier, Errors.Modifier0_already_seen, "abstract");
                        }

                        if (node.Kind != SyntaxKind.ClassDeclaration)
                        {
                            if (node.Kind != SyntaxKind.MethodDeclaration)
                            {
                                return GrammarErrorOnNode(modifier, Errors.Abstract_modifier_can_only_appear_on_a_class_or_method_declaration);
                            }

                            if (!(node.Parent.Kind == SyntaxKind.ClassDeclaration && (node.Parent.Flags & NodeFlags.Abstract) != NodeFlags.None))
                            {
                                return GrammarErrorOnNode(modifier, Errors.Abstract_methods_can_only_appear_within_an_abstract_class);
                            }

                            if ((flags & NodeFlags.Static) != NodeFlags.None)
                            {
                                return GrammarErrorOnNode(modifier, Errors.Zero_modifier_cannot_be_used_with_1_modifier, "static", "abstract");
                            }

                            if ((flags & NodeFlags.Private) != NodeFlags.None)
                            {
                                return GrammarErrorOnNode(modifier, Errors.Zero_modifier_cannot_be_used_with_1_modifier, "private", "abstract");
                            }
                        }

                        flags |= NodeFlags.Abstract;
                        break;

                    case SyntaxKind.AsyncKeyword:
                        if ((flags & NodeFlags.Async) != NodeFlags.None)
                        {
                            return GrammarErrorOnNode(modifier, Errors.Modifier0_already_seen, "async");
                        }
                        else if ((flags & NodeFlags.Ambient) != NodeFlags.None || IsInAmbientContext(node.Parent))
                        {
                            return GrammarErrorOnNode(modifier, Errors.Modifier0_cannot_be_used_in_an_ambient_context, "async");
                        }
                        else if (node.Kind == SyntaxKind.Parameter)
                        {
                            return GrammarErrorOnNode(modifier, Errors.Zero_modifier_cannot_appear_on_a_parameter, "async");
                        }

                        flags |= NodeFlags.Async;
                        lastAsync = modifier;
                        break;
                }
            }

            if (node.Kind == SyntaxKind.Constructor)
            {
                if ((flags & NodeFlags.Static) != NodeFlags.None)
                {
                    return GrammarErrorOnNode(lastStatic, Errors.Zero_modifier_cannot_appear_on_a_constructor_declaration, "static");
                }

                if ((flags & NodeFlags.Abstract) != NodeFlags.None)
                {
                    return GrammarErrorOnNode(lastStatic, Errors.Zero_modifier_cannot_appear_on_a_constructor_declaration, "abstract");
                }
                else if ((flags & NodeFlags.Protected) != NodeFlags.None)
                {
                    return GrammarErrorOnNode(lastProtected, Errors.Zero_modifier_cannot_appear_on_a_constructor_declaration, "protected");
                }
                else if ((flags & NodeFlags.Private) != NodeFlags.None)
                {
                    return GrammarErrorOnNode(lastPrivate, Errors.Zero_modifier_cannot_appear_on_a_constructor_declaration, "private");
                }
                else if ((flags & NodeFlags.Async) != NodeFlags.None)
                {
                    return GrammarErrorOnNode(lastAsync, Errors.Zero_modifier_cannot_appear_on_a_constructor_declaration, "async");
                }

                // TODO: this was just 'return'. It means that this function potentially could have 3 different return values!
                return false;
            }
            else if ((node.Kind == SyntaxKind.ImportDeclaration || node.Kind == SyntaxKind.ImportEqualsDeclaration) && (flags & NodeFlags.Ambient) != NodeFlags.None)
            {
                return GrammarErrorOnNode(lastDeclare, Errors.A_0_modifier_cannot_be_used_with_an_import_declaration, "declare");
            }
            else if (node.Kind == SyntaxKind.Parameter && (flags & NodeFlags.AccessibilityModifier) != NodeFlags.None && IsBindingPattern(node.Cast<IParameterDeclaration>().Name) != null)
            {
                return GrammarErrorOnNode(node, Errors.A_parameter_property_may_not_be_a_binding_pattern);
            }

            if ((flags & NodeFlags.Async) != NodeFlags.None)
            {
                return CheckGrammarAsyncModifier(node, lastAsync);
            }

            return false;
        }

        private bool CheckGrammarAsyncModifier(INode node, INode asyncModifier)
        {
            if (m_languageVersion < ScriptTarget.Es6)
            {
                return GrammarErrorOnNode(asyncModifier, Errors.Async_functions_are_only_available_when_targeting_ECMAScript_6_and_higher);
            }

            switch (node.Kind)
            {
                case SyntaxKind.MethodDeclaration:
                case SyntaxKind.FunctionDeclaration:
                case SyntaxKind.FunctionExpression:
                case SyntaxKind.ArrowFunction:
                    if (!node.Cast<IFunctionLikeDeclaration>().AsteriskToken)
                    {
                        return false;
                    }

                    break;
            }

            return GrammarErrorOnNode(asyncModifier, Errors.Modifier0_cannot_be_used_here, "async");
        }

        private bool CheckGrammarForDisallowedTrailingComma([CanBeNull] INodeArray<INode> list)
        {
            if (list?.HasTrailingComma == true)
            {
                var start = list.End - ",".Length;
                var end = list.End;
                var sourceFile = list[0].GetSourceFile();
                return GrammarErrorAtPos(sourceFile, start, end - start, Errors.Trailing_comma_not_allowed);
            }

            return false;
        }

        private bool CheckGrammarTypeParameterList(IFunctionLikeDeclaration node, [CanBeNull] INodeArray<ITypeParameterDeclaration> typeParameters, ISourceFile file)
        {
            if (CheckGrammarForDisallowedTrailingComma(typeParameters))
            {
                return true;
            }

            if (typeParameters?.Count == 0)
            {
                var start = typeParameters.Pos - "<".Length;
                var end = SkipTrivia(file.Text, typeParameters.End) + ">".Length;
                return GrammarErrorAtPos(file, start, end - start, Errors.Type_parameter_list_cannot_be_empty);
            }

            return false;
        }

        private bool CheckGrammarParameterList(NodeArray<IParameterDeclaration> parameters)
        {
            if (CheckGrammarForDisallowedTrailingComma(parameters))
            {
                return true;
            }

            var seenOptionalParameter = false;
            var parameterCount = parameters.Length;

            for (var i = 0; i < parameterCount; i++)
            {
                var parameter = parameters[i];
                if (parameter.DotDotDotToken)
                {
                    if (i != parameterCount - 1)
                    {
                        return GrammarErrorOnNode(parameter.DotDotDotToken.ValueOrDefault, Errors.A_rest_parameter_must_be_last_in_a_parameter_list);
                    }

                    if (IsBindingPattern(parameter.Name) != null)
                    {
                        return GrammarErrorOnNode(parameter.Name, Errors.A_rest_element_cannot_contain_a_binding_pattern);
                    }

                    if (parameter.QuestionToken)
                    {
                        return GrammarErrorOnNode(parameter.QuestionToken.ValueOrDefault, Errors.A_rest_parameter_cannot_be_optional);
                    }

                    if (parameter.Initializer != null)
                    {
                        return GrammarErrorOnNode(parameter.Name, Errors.A_rest_parameter_cannot_have_an_initializer);
                    }
                }
                else if (parameter.QuestionToken)
                {
                    seenOptionalParameter = true;

                    if (parameter.Initializer != null)
                    {
                        return GrammarErrorOnNode(parameter.Name, Errors.Parameter_cannot_have_question_mark_and_initializer);
                    }
                }
                else if (seenOptionalParameter && parameter.Initializer == null)
                {
                    return GrammarErrorOnNode(parameter.Name, Errors.A_required_parameter_cannot_follow_an_optional_parameter);
                }
            }

            return false;
        }

        private bool CheckGrammarFunctionLikeDeclaration(IFunctionLikeDeclaration node)
        {
            // Prevent cascading error by short-circuit
            var file = NodeStructureExtensions.GetSourceFile(node);
            return CheckGrammarDecorators(node) || CheckGrammarModifiers(node) || CheckGrammarTypeParameterList(node, node.TypeParameters, file) ||
                CheckGrammarParameterList(node.Parameters) || CheckGrammarArrowFunction(node, file);
        }

        private bool CheckGrammarArrowFunction(IFunctionLikeDeclaration node, ISourceFile file)
        {
            // DScript-specific. We relax this restriction for DScript files.
            if (node.Kind == SyntaxKind.ArrowFunction && !m_isScriptFile)
            {
                var arrowFunction = node.Cast<IArrowFunction>();
                var startLine = GetLineAndCharacterOfPosition(file, arrowFunction.EqualsGreaterThanToken.Pos).Line;
                var endLine = GetLineAndCharacterOfPosition(file, arrowFunction.EqualsGreaterThanToken.End).Line;
                if (startLine != endLine)
                {
                    return GrammarErrorOnNode(arrowFunction.EqualsGreaterThanToken, Errors.Line_terminator_not_permitted_before_arrow);
                }
            }

            return false;
        }

        private bool CheckGrammarIndexSignatureParameters(ISignatureDeclaration node)
        {
            var parameter = node.Parameters.FirstOrDefault();
            if (node.Parameters.Length != 1)
            {
                if (parameter != null)
                {
                    return GrammarErrorOnNode(parameter.Name, Errors.An_index_signature_must_have_exactly_one_parameter);
                }
                else
                {
                    return GrammarErrorOnNode(node, Errors.An_index_signature_must_have_exactly_one_parameter);
                }
            }

            if (parameter.DotDotDotToken)
            {
                return GrammarErrorOnNode(parameter.DotDotDotToken.ValueOrDefault, Errors.An_index_signature_cannot_have_a_rest_parameter);
            }

            if ((parameter.Flags & NodeFlags.Modifier) != NodeFlags.None)
            {
                return GrammarErrorOnNode(parameter.Name, Errors.An_index_signature_parameter_cannot_have_an_accessibility_modifier);
            }

            if (parameter.QuestionToken)
            {
                return GrammarErrorOnNode(parameter.QuestionToken.ValueOrDefault, Errors.An_index_signature_parameter_cannot_have_a_question_mark);
            }

            if (parameter.Initializer != null)
            {
                return GrammarErrorOnNode(parameter.Name, Errors.An_index_signature_parameter_cannot_have_an_initializer);
            }

            if (parameter.Type == null)
            {
                return GrammarErrorOnNode(parameter.Name, Errors.An_index_signature_parameter_must_have_a_type_annotation);
            }

            if (parameter.Type.Kind != SyntaxKind.StringKeyword && parameter.Type.Kind != SyntaxKind.NumberKeyword)
            {
                return GrammarErrorOnNode(parameter.Name, Errors.An_index_signature_parameter_type_must_be_string_or_number);
            }

            if (node.Type == null)
            {
                return GrammarErrorOnNode(node, Errors.An_index_signature_must_have_a_type_annotation);
            }

            return false;
        }

        private bool CheckGrammarForIndexSignatureModifier(ISignatureDeclaration node)
        {
            if ((node.Flags & NodeFlags.Modifier) != NodeFlags.None)
            {
                GrammarErrorOnFirstToken(node, Errors.Modifiers_not_permitted_on_index_signature_members);
            }

            return false;
        }

        private bool CheckGrammarIndexSignature(ISignatureDeclaration node)
        {
            // Prevent cascading error by short-circuit
            return CheckGrammarDecorators(node) || CheckGrammarModifiers(node) || CheckGrammarIndexSignatureParameters(node) || CheckGrammarForIndexSignatureModifier(node);
        }

        private bool CheckGrammarForAtLeastOneTypeArgument(INode node, NodeArray<ITypeNode> typeArguments)
        {
            if (typeArguments?.Count == 0)
            {
                var sourceFile = NodeStructureExtensions.GetSourceFile(node);
                var start = typeArguments.Pos - "<".Length;
                var end = SkipTrivia(sourceFile.Text, typeArguments.End) + ">".Length;
                return GrammarErrorAtPos(sourceFile, start, end - start, Errors.Type_argument_list_cannot_be_empty);
            }

            return false;
        }

        private bool CheckGrammarTypeArguments(INode node, NodeArray<ITypeNode> typeArguments)
        {
            return CheckGrammarForDisallowedTrailingComma(typeArguments) ||
                CheckGrammarForAtLeastOneTypeArgument(node, typeArguments);
        }

        private bool CheckGrammarForOmittedArgument(ICallExpression node, NodeArray<IExpression> args)
        {
            if (args != null)
            {
                var sourceFile = NodeStructureExtensions.GetSourceFile(node);
                foreach (var arg in args)
                {
                    if (arg.Kind == SyntaxKind.OmittedExpression)
                    {
                        return GrammarErrorAtPos(sourceFile, arg.Pos, 0, Errors.Argument_expression_expected);
                    }
                }
            }

            return false;
        }

        private bool CheckGrammarArguments(ICallExpression node, NodeArray<IExpression> args)
        {
            return CheckGrammarForDisallowedTrailingComma(args) ||
                CheckGrammarForOmittedArgument(node, args);
        }

        private bool CheckGrammarHeritageClause(IHeritageClause node)
        {
            var types = node.Types;
            if (CheckGrammarForDisallowedTrailingComma(types))
            {
                return true;
            }

            if (types?.Count == 0)
            {
                var listType = TokenToString(node.Token);
                var sourceFile = NodeStructureExtensions.GetSourceFile(node);
                return GrammarErrorAtPos(sourceFile, types.Pos, 0, Errors.Zero_list_cannot_be_empty, listType);
            }

            return false;
        }

        private bool CheckGrammarClassDeclarationHeritageClauses(IClassLikeDeclaration node)
        {
            var seenExtendsClause = false;
            var seenImplementsClause = false;

            if (!CheckGrammarDecorators(node) && !CheckGrammarModifiers(node) && node.HeritageClauses != null)
            {
                foreach (var heritageClause in node.HeritageClauses)
                {
                    if (heritageClause.Token == SyntaxKind.ExtendsKeyword)
                    {
                        if (seenExtendsClause)
                        {
                            return GrammarErrorOnFirstToken(heritageClause, Errors.Extends_clause_already_seen);
                        }

                        if (seenImplementsClause)
                        {
                            return GrammarErrorOnFirstToken(heritageClause, Errors.Extends_clause_must_precede_implements_clause);
                        }

                        if (heritageClause.Types.Length > 1)
                        {
                            return GrammarErrorOnFirstToken(heritageClause.Types[1], Errors.Classes_can_only_extend_a_single_class);
                        }

                        seenExtendsClause = true;
                    }
                    else
                    {
                        Contract.Assert(heritageClause.Token == SyntaxKind.ImplementsKeyword);
                        if (seenImplementsClause)
                        {
                            return GrammarErrorOnFirstToken(heritageClause, Errors.Implements_clause_already_seen);
                        }

                        seenImplementsClause = true;
                    }

                    // Grammar checking heritageClause inside class declaration
                    CheckGrammarHeritageClause(heritageClause);
                }
            }

            return false;
        }

        private bool CheckGrammarInterfaceDeclaration(IInterfaceDeclaration node)
        {
            var seenExtendsClause = false;

            if (node.HeritageClauses != null)
            {
                foreach (var heritageClause in node.HeritageClauses)
                {
                    if (heritageClause.Token == SyntaxKind.ExtendsKeyword)
                    {
                        if (seenExtendsClause)
                        {
                            return GrammarErrorOnFirstToken(heritageClause, Errors.Extends_clause_already_seen);
                        }

                        seenExtendsClause = true;
                    }
                    else
                    {
                        Contract.Assert(heritageClause.Token == SyntaxKind.ImplementsKeyword);
                        return GrammarErrorOnFirstToken(heritageClause, Errors.Interface_declaration_cannot_have_implements_clause);
                    }

                    // Grammar checking heritageClause inside class declaration
                    CheckGrammarHeritageClause(heritageClause);
                }
            }

            return false;
        }

        private bool CheckGrammarComputedPropertyName(INode node)
        {
            // If node is not a computedPropertyName, just skip the grammar checking
            if (node.Kind != SyntaxKind.ComputedPropertyName)
            {
                return false;
            }

            var computedPropertyName = node.Cast<IComputedPropertyName>();
            if (computedPropertyName.Expression.Kind == SyntaxKind.BinaryExpression && computedPropertyName.Expression.Cast<IBinaryExpression>().OperatorToken.Kind == SyntaxKind.CommaToken)
            {
                return GrammarErrorOnNode(computedPropertyName.Expression, Errors.A_comma_expression_is_not_allowed_in_a_computed_property_name);
            }

            return false;
        }

        private bool CheckGrammarForGenerator(IFunctionLikeDeclaration node)
        {
            if (node.AsteriskToken)
            {
                Contract.Assert(node.Kind == SyntaxKind.FunctionDeclaration ||
                                node.Kind == SyntaxKind.FunctionExpression ||
                                node.Kind == SyntaxKind.MethodDeclaration);

                if (IsInAmbientContext(node))
                {
                    return GrammarErrorOnNode(node.AsteriskToken.ValueOrDefault, Errors.Generators_are_not_allowed_in_an_ambient_context);
                }

                if (node.Body == null)
                {
                    return GrammarErrorOnNode(node.AsteriskToken.ValueOrDefault, Errors.An_overload_signature_cannot_be_declared_as_a_generator);
                }

                if (m_languageVersion < ScriptTarget.Es6)
                {
                    return GrammarErrorOnNode(node.AsteriskToken.ValueOrDefault, Errors.Generators_are_only_available_when_targeting_ECMAScript_6_or_higher);
                }
            }

            return false;
        }

        private bool CheckGrammarForInvalidQuestionMark(IDeclaration node, INode questionToken, IDiagnosticMessage message)
        {
            if (questionToken != null)
            {
                return GrammarErrorOnNode(questionToken, message);
            }

            return false;
        }

        private bool CheckGrammarObjectLiteralExpression(IObjectLiteralExpression node, bool inDestructuring)
        {
            Map<SymbolFlags> seen = new Map<SymbolFlags>();
            SymbolFlags property = (SymbolFlags)1;
            SymbolFlags getAccessor = (SymbolFlags)2;
            SymbolFlags setAccesor = (SymbolFlags)4;
            SymbolFlags getOrSetAccessor = getAccessor | setAccesor;

            foreach (var prop in node.Properties)
            {
                var name = prop.Name;
                if (prop.Kind == SyntaxKind.OmittedExpression)
                {
                    continue;
                }

                if (name.Kind == SyntaxKind.ComputedPropertyName)
                {
                    CheckGrammarComputedPropertyName(name.Cast<IComputedPropertyName>());
                    continue;
                }

                if (prop.Kind == SyntaxKind.ShorthandPropertyAssignment && !inDestructuring && prop.Cast<IShorthandPropertyAssignment>().ObjectAssignmentInitializer != null)
                {
                    // having objectAssignmentInitializer is only valid in ObjectAssignmentPattern
                    // outside of destructuring it is a syntax error
                    return GrammarErrorOnNode(prop.Cast<IShorthandPropertyAssignment>().EqualsToken.ValueOrDefault, Errors.Can_only_be_used_in_an_object_literal_property_inside_a_destructuring_assignment);
                }

                // Modifiers are never allowed on properties except for 'async' on a method declaration
                ForEach(prop.Modifiers, (checker: this, prop), (mod, tuple) =>
                {
                    var @this = tuple.checker;
                    var p = tuple.prop;
                    if (mod.Kind != SyntaxKind.AsyncKeyword || p.Kind != SyntaxKind.MethodDeclaration)
                    {
                        @this.GrammarErrorOnNode(mod, Errors.Modifier0_cannot_be_used_here, GetTextOfNode(mod));
                    }
                });

                // ECMA-262 11.1.5 Object Initialiser
                // If previous is not undefined then throw a SyntaxError exception if any of the following conditions are true
                // a.This production is contained in strict code and IsDataDescriptor(previous) is true and
                // IsDataDescriptor(propId.descriptor) is true.
                //    b.IsDataDescriptor(previous) is true and IsAccessorDescriptor(propId.descriptor) is true.
                //    c.IsAccessorDescriptor(previous) is true and IsDataDescriptor(propId.descriptor) is true.
                //    d.IsAccessorDescriptor(previous) is true and IsAccessorDescriptor(propId.descriptor) is true
                // and either both previous and propId.descriptor have[[Get]] fields or both previous and propId.descriptor have[[Set]] fields
                SymbolFlags currentKind = default(SymbolFlags);

                if (prop.Kind == SyntaxKind.PropertyAssignment || prop.Kind == SyntaxKind.ShorthandPropertyAssignment)
                {
                    // Grammar checking for computedPropertName and shorthandPropertyAssignment
                    Types.Optional<INode> questionToken = null;
                    switch (prop.Kind)
                    {
                        case SyntaxKind.PropertyAssignment:
                            questionToken = prop.Cast<IPropertyAssignment>().QuestionToken;
                            break;
                        case SyntaxKind.ShorthandPropertyAssignment:
                            questionToken = prop.Cast<IShorthandPropertyAssignment>().QuestionToken;
                            break;
                        default:
                            Contract.Assert(false, "Unexpected fallthrough");
                            break;
                    }

                    CheckGrammarForInvalidQuestionMark(prop, questionToken.ValueOrDefault, Errors.An_object_member_cannot_be_declared_optional);
                    if (name.Kind == SyntaxKind.NumericLiteral)
                    {
                        CheckGrammarNumericLiteral(name);
                    }

                    currentKind = property;
                }
                else if (prop.Kind == SyntaxKind.MethodDeclaration)
                {
                    currentKind = property;
                }
                else if (prop.Kind == SyntaxKind.GetAccessor)
                {
                    currentKind = getAccessor;
                }
                else if (prop.Kind == SyntaxKind.SetAccessor)
                {
                    currentKind = setAccesor;
                }
                else
                {
                    Contract.Assert(false, "Unexpected syntax kind:" + prop.Kind);
                }

                if (!seen.ContainsKey(name.Text))
                {
                    seen[name.Text] = currentKind;
                }
                else
                {
                    SymbolFlags existingKind = seen[name.Cast<IIdentifier>().Text];
                    if (currentKind == property && existingKind == property)
                    {
                        continue;
                    }
                    else if ((currentKind & getOrSetAccessor) != SymbolFlags.None && (existingKind & getOrSetAccessor) != SymbolFlags.None)
                    {
                        if (existingKind != getOrSetAccessor && currentKind != existingKind)
                        {
                            seen[name.Text] = currentKind | existingKind;
                        }
                        else
                        {
                            return GrammarErrorOnNode(name, Errors.An_object_literal_cannot_have_multiple_get_Slashset_accessors_with_the_same_name);
                        }
                    }
                    else
                    {
                        return GrammarErrorOnNode(name, Errors.An_object_literal_cannot_have_property_and_accessor_with_the_same_name);
                    }
                }
            }

            return false;
        }

        private bool CheckGrammarForInOrForOfStatement(/*HINT: IForInStatement | IForOfStatement*/ IIterationStatement forInOrOfStatement)
        {
            var initializer = forInOrOfStatement.Kind == SyntaxKind.ForOfStatement ?
                                forInOrOfStatement.Cast<IForOfStatement>().Initializer :
                                forInOrOfStatement.Cast<IForInStatement>().Initializer;

            if (CheckGrammarStatementInAmbientContext(forInOrOfStatement))
            {
                return true;
            }

            if (initializer.Kind == SyntaxKind.VariableDeclarationList)
            {
                var variableList = initializer.Cast<IVariableDeclarationList>();
                if (!CheckGrammarVariableDeclarationList(variableList))
                {
                    var declarations = variableList.Declarations;

                    // declarations.length can be zero if there is an error in variable declaration in for-of or for-in
                    // See http://www.ecma-international.org/ecma-262/6.0/#sec-for-in-and-for-of-statements for details
                    // For example:
                    //      var let = 10;
                    //      for (let of [1,2,3]) {} // this is invalid ES6 syntax
                    //      for (let in [1,2,3]) {} // this is invalid ES6 syntax
                    // We will then want to skip on grammar checking on variableList declaration
                    if (declarations.Count == 0)
                    {
                        return false;
                    }

                    if (declarations.Length > 1)
                    {
                        var diagnostic = forInOrOfStatement.Kind == SyntaxKind.ForInStatement
                            ? Errors.Only_a_single_variable_declaration_is_allowed_in_a_for_in_statement
                            : Errors.Only_a_single_variable_declaration_is_allowed_in_a_for_of_statement;
                        return GrammarErrorOnFirstToken(variableList.Declarations[1], diagnostic);
                    }

                    var firstDeclaration = declarations[0];

                    if (firstDeclaration.Initializer != null)
                    {
                        var diagnostic = forInOrOfStatement.Kind == SyntaxKind.ForInStatement
                            ? Errors.The_variable_declaration_of_a_for_in_statement_cannot_have_an_initializer
                            : Errors.The_variable_declaration_of_a_for_of_statement_cannot_have_an_initializer;
                        return GrammarErrorOnNode(firstDeclaration.Name, diagnostic);
                    }

                    if (firstDeclaration.Type != null)
                    {
                        var diagnostic = forInOrOfStatement.Kind == SyntaxKind.ForInStatement
                            ? Errors.The_left_hand_side_of_a_for_in_statement_cannot_use_a_type_annotation
                            : Errors.The_left_hand_side_of_a_for_of_statement_cannot_use_a_type_annotation;
                        return GrammarErrorOnNode(firstDeclaration, diagnostic);
                    }
                }
            }

            return false;
        }

        private bool CheckGrammarAccessor(/*HINT:IMethodDeclaration*/ IFunctionLikeDeclaration accessor)
        {
            var kind = accessor.Kind;
            if (m_languageVersion < ScriptTarget.Es5)
            {
                return GrammarErrorOnNode(accessor.Name, Errors.Accessors_are_only_available_when_targeting_ECMAScript_5_and_higher);
            }
            else if (IsInAmbientContext(accessor))
            {
                return GrammarErrorOnNode(accessor.Name, Errors.An_accessor_cannot_be_declared_in_an_ambient_context);
            }
            else if (accessor.Body == null)
            {
                return GrammarErrorAtPos(NodeStructureExtensions.GetSourceFile(accessor), accessor.End - 1, ";".Length, Errors.Token_expected, "{");
            }
            else if (accessor.TypeParameters != null)
            {
                return GrammarErrorOnNode(accessor.Name, Errors.An_accessor_cannot_have_type_parameters);
            }
            else if (kind == SyntaxKind.GetAccessor && accessor.Parameters.Count != 0)
            {
                return GrammarErrorOnNode(accessor.Name, Errors.A_get_accessor_cannot_have_parameters);
            }
            else if (kind == SyntaxKind.SetAccessor)
            {
                if (accessor.Type != null)
                {
                    return GrammarErrorOnNode(accessor.Name, Errors.A_set_accessor_cannot_have_a_return_type_annotation);
                }
                else if (accessor.Parameters.Length != 1)
                {
                    return GrammarErrorOnNode(accessor.Name, Errors.A_set_accessor_must_have_exactly_one_parameter);
                }
                else
                {
                    var parameter = accessor.Parameters[0];
                    if (parameter.DotDotDotToken)
                    {
                        return GrammarErrorOnNode(parameter.DotDotDotToken.ValueOrDefault, Errors.A_set_accessor_cannot_have_rest_parameter);
                    }
                    else if ((parameter.Flags & NodeFlags.Modifier) != NodeFlags.None)
                    {
                        return GrammarErrorOnNode(accessor.Name, Errors.A_parameter_property_is_only_allowed_in_a_constructor_implementation);
                    }
                    else if (parameter.QuestionToken)
                    {
                        return GrammarErrorOnNode(parameter.QuestionToken.ValueOrDefault, Errors.A_set_accessor_cannot_have_an_optional_parameter);
                    }
                    else if (parameter.Initializer != null)
                    {
                        return GrammarErrorOnNode(accessor.Name, Errors.A_set_accessor_parameter_cannot_have_an_initializer);
                    }
                }
            }

            return false;
        }

        private bool CheckGrammarForNonSymbolComputedProperty(DeclarationName node, IDiagnosticMessage message)
        {
            if (IsDynamicName(node))
            {
                return GrammarErrorOnNode(node, message);
            }

            return false;
        }

        private bool CheckGrammarMethod(/*HINT: IMethodDeclaration*/ IFunctionLikeDeclaration node)
        {
            if (CheckGrammarDisallowedModifiersOnObjectLiteralExpressionMethod(node) ||
                CheckGrammarFunctionLikeDeclaration(node) ||
                CheckGrammarForGenerator(node))
            {
                return true;
            }

            if (node.Parent.Kind == SyntaxKind.ObjectLiteralExpression)
            {
                if (CheckGrammarForInvalidQuestionMark(node, node.QuestionToken.ValueOrDefault, Errors.A_class_member_cannot_be_declared_optional))
                {
                    return true;
                }
                else if (node.Body == null)
                {
                    return GrammarErrorAtPos(GetSourceFile(node), node.End - 1, ";".Length, Errors.Token_expected, "{");
                }
            }

            if (IsClassLike(node.Parent) != null)
            {
                if (CheckGrammarForInvalidQuestionMark(node, node.QuestionToken.ValueOrDefault, Errors.A_class_member_cannot_be_declared_optional))
                {
                    return true;
                }

                // Technically, computed properties in ambient contexts is disallowed
                // for property declarations and accessors too, not just methods.
                // However, property declarations disallow computed names in general,
                // and accessors are not allowed in ambient contexts in general,
                // so this error only really matters for methods.
                if (IsInAmbientContext(node))
                {
                    return CheckGrammarForNonSymbolComputedProperty(node.Name, Errors.A_computed_property_name_in_an_ambient_context_must_directly_refer_to_a_built_in_symbol);
                }
                else if (node.Body == null)
                {
                    return CheckGrammarForNonSymbolComputedProperty(node.Name, Errors.A_computed_property_name_in_a_method_overload_must_directly_refer_to_a_built_in_symbol);
                }
            }
            else if (node.Parent.Kind == SyntaxKind.InterfaceDeclaration)
            {
                return CheckGrammarForNonSymbolComputedProperty(node.Name, Errors.A_computed_property_name_in_an_interface_must_directly_refer_to_a_built_in_symbol);
            }
            else if (node.Parent.Kind == SyntaxKind.TypeLiteral)
            {
                return CheckGrammarForNonSymbolComputedProperty(node.Name, Errors.A_computed_property_name_in_a_type_literal_must_directly_refer_to_a_built_in_symbol);
            }

            return false;
        }

        private bool CheckGrammarBreakOrContinueStatement(IBreakOrContinueStatement node)
        {
            INode current = node;
            while (current != null)
            {
                if (IsFunctionLike(current) != null)
                {
                    return GrammarErrorOnNode(node, Errors.Jump_target_cannot_cross_function_boundary);
                }

                switch (current.Kind)
                {
                    case SyntaxKind.LabeledStatement:
                        if (node.Label != null && current.Cast<ILabeledStatement>().Label.Text == node.Label.Text)
                        {
                            // found matching label - verify that label usage is correct
                            // continue can only target labels that are on iteration statements
                            var isMisplacedContinueLabel = node.Kind == SyntaxKind.ContinueStatement
                                && !IsIterationStatement(current.Cast<ILabeledStatement>().Statement, /*lookInLabeledStatement*/ true);

                            if (isMisplacedContinueLabel)
                            {
                                return GrammarErrorOnNode(node, Errors.A_continue_statement_can_only_jump_to_a_label_of_an_enclosing_iteration_statement);
                            }

                            return false;
                        }

                        break;

                    case SyntaxKind.SwitchStatement:
                        if (node.Kind == SyntaxKind.BreakStatement && node.Label == null)
                        {
                            // unlabeled break within switch statement - ok
                            return false;
                        }

                        break;

                    default:
                        if (IsIterationStatement(current, /*lookInLabeledStatement*/ false) && node.Label == null)
                        {
                            // unlabeled break or continue within iteration statement - ok
                            return false;
                        }

                        break;
                }

                current = current.Parent;
            }

            if (node.Label != null)
            {
                var message = node.Kind == SyntaxKind.BreakStatement
                    ? Errors.A_break_statement_can_only_jump_to_a_label_of_an_enclosing_statement
                    : Errors.A_continue_statement_can_only_jump_to_a_label_of_an_enclosing_iteration_statement;

                return GrammarErrorOnNode(node, message);
            }
            else
            {
                var message = node.Kind == SyntaxKind.BreakStatement
                    ? Errors.A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement
                    : Errors.A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement;
                return GrammarErrorOnNode(node, message);
            }
        }

        private bool CheckGrammarBindingElement(IBindingElement node)
        {
            if (node.DotDotDotToken)
            {
                var elements = node.Parent.Cast<IBindingPattern>().Elements;
                if (node.ResolveUnionType() != elements.LastOrDefault()?.ResolveUnionType())
                {
                    return GrammarErrorOnNode(node, Errors.A_rest_element_must_be_last_in_an_array_destructuring_pattern);
                }

                if (node.Name.Kind == SyntaxKind.ArrayBindingPattern || node.Name.Kind == SyntaxKind.ObjectBindingPattern)
                {
                    return GrammarErrorOnNode(node.Name, Errors.A_rest_element_cannot_contain_a_binding_pattern);
                }

                if (node.Initializer != null)
                {
                    // Error on equals token which immediate precedes the initializer
                    return GrammarErrorAtPos(NodeStructureExtensions.GetSourceFile(node), node.Initializer.Pos - 1, 1, Errors.A_rest_element_cannot_have_an_initializer);
                }
            }

            return false;
        }

        private bool CheckGrammarVariableDeclaration(IVariableDeclaration node)
        {
            if (node.Parent.Parent.Kind != SyntaxKind.ForInStatement && node.Parent.Parent.Kind != SyntaxKind.ForOfStatement)
            {
                if (IsInAmbientContext(node))
                {
                    // DScript-specific. Template declarations are an exception for ambients and do allow initializers
                    if (node.Initializer != null && !node.IsTemplateDeclaration())
                    {
                        // Error on equals token which immediate precedes the initializer
                        var equalsTokenLength = "=".Length;
                        return GrammarErrorAtPos(NodeStructureExtensions.GetSourceFile(node), node.Initializer.Pos - equalsTokenLength,
                            equalsTokenLength, Errors.Initializers_are_not_allowed_in_ambient_contexts);
                    }
                }
                else if (node.Initializer == null)
                {
                    if (IsBindingPattern(node.Name) != null && IsBindingPattern(node.Parent) == null)
                    {
                        return GrammarErrorOnNode(node, Errors.A_destructuring_declaration_must_have_an_initializer);
                    }

                    if (IsConst(node))
                    {
                        return GrammarErrorOnNode(node, Errors.Const_declarations_must_be_initialized);
                    }
                }
            }

            var checkLetConstNames = IsLet(node) || IsConst(node);

            // 1. LexicalDeclaration : LetOrConst BindingList ;
            // It is a Syntax Error if the BoundNames of BindingList contains "let".
            // 2. ForDeclaration ForDeclaration : LetOrConst ForBinding
            // It is a Syntax Error if the BoundNames of ForDeclaration contains "let".

            // It is a SyntaxError if a VariableDeclaration or VariableDeclarationNoIn occurs within strict code
            // and its Identifier is eval or arguments
            return checkLetConstNames && CheckGrammarNameInLetOrConstDeclarations(node.Name);
        }

        private bool CheckGrammarNameInLetOrConstDeclarations(IdentifierOrBindingPattern name)
        {
            if (name.Kind == SyntaxKind.Identifier)
            {
                if (name.Cast<IIdentifier>().OriginalKeywordKind == SyntaxKind.LetKeyword)
                {
                    return GrammarErrorOnNode(name, Errors.Let_is_not_allowed_to_be_used_as_a_name_in_let_or_const_declarations);
                }
            }
            else
            {
                var elements = name.Cast<IBindingPattern>().Elements;
                foreach (var element in elements)
                {
                    if (element.Kind != SyntaxKind.OmittedExpression)
                    {
                        CheckGrammarNameInLetOrConstDeclarations(element.Name);
                    }
                }
            }

            return false;
        }

        private bool CheckGrammarVariableDeclarationList(IVariableDeclarationList declarationList)
        {
            var declarations = declarationList.Declarations;
            if (CheckGrammarForDisallowedTrailingComma(declarationList.Declarations))
            {
                return true;
            }

            if (declarationList.Declarations.Count == 0)
            {
                return GrammarErrorAtPos(NodeStructureExtensions.GetSourceFile(declarationList), declarations.Pos, declarations.End - declarations.Pos, Errors.Variable_declaration_list_cannot_be_empty);
            }

            return false;
        }

        private bool AllowLetAndConstDeclarations(INode parent)
        {
            switch (parent.Kind)
            {
                case SyntaxKind.IfStatement:
                case SyntaxKind.DoStatement:
                case SyntaxKind.WhileStatement:
                case SyntaxKind.WithStatement:
                case SyntaxKind.ForStatement:
                case SyntaxKind.ForInStatement:
                case SyntaxKind.ForOfStatement:
                    return false;

                case SyntaxKind.LabeledStatement:
                    return AllowLetAndConstDeclarations(parent.Parent);
            }

            return true;
        }

        private bool CheckGrammarForDisallowedLetOrConstStatement(IVariableStatement node)
        {
            if (!AllowLetAndConstDeclarations(node.Parent))
            {
                if (IsLet(node.DeclarationList))
                {
                    return GrammarErrorOnNode(node, Errors.Let_declarations_can_only_be_declared_inside_a_block);
                }
                else if (IsConst(node.DeclarationList))
                {
                    return GrammarErrorOnNode(node, Errors.Let_declarations_can_only_be_declared_inside_a_block);
                }
            }

            return false;
        }

        private static bool HasParseDiagnostics(ISourceFile sourceFile)
        {
            return sourceFile.ParseDiagnostics?.Count > 0;
        }

        private bool GrammarErrorOnFirstToken(INode node, IDiagnosticMessage message, params object[] args)
        {
            var sourceFile = NodeStructureExtensions.GetSourceFile(node);
            if (!HasParseDiagnostics(sourceFile))
            {
                var span = GetSpanOfTokenAtPosition(sourceFile, node.Pos);
                m_diagnostics.Add(Diagnostic.CreateFileDiagnostic(sourceFile, span.Start, span.Length, message, args));
                return true;
            }

            return false;
        }

        private bool GrammarErrorAtPos(ISourceFile sourceFile, int start, int length, IDiagnosticMessage message, params object[] args)
        {
            if (!HasParseDiagnostics(sourceFile))
            {
                m_diagnostics.Add(Diagnostic.CreateFileDiagnostic(sourceFile, start, length, message, args));
                return true;
            }

            return false;
        }

        private bool GrammarErrorOnNode(INode node, IDiagnosticMessage message, params object[] args)
        {
            var sourceFile = NodeStructureExtensions.GetSourceFile(node);
            if (!HasParseDiagnostics(sourceFile))
            {
                m_diagnostics.Add(Diagnostic.CreateDiagnosticForNode(node, message, args));
                return true;
            }

            return false;
        }

        private bool CheckGrammarConstructorTypeParameters(IConstructorDeclaration node)
        {
            if (node.TypeParameters != null)
            {
                return GrammarErrorAtPos(NodeStructureExtensions.GetSourceFile(node), node.TypeParameters.Pos, node.TypeParameters.End - node.TypeParameters.Pos, Errors.Type_parameters_cannot_appear_on_a_constructor_declaration);
            }

            return false;
        }

        private bool CheckGrammarConstructorTypeAnnotation(IConstructorDeclaration node)
        {
            if (node.Type != null)
            {
                return GrammarErrorOnNode(node.Type, Errors.Type_annotation_cannot_appear_on_a_constructor_declaration);
            }

            return false;
        }

        private bool CheckGrammarProperty(/*HINT: IPropertyDeclaration*/ IDeclaration node)
        {
            Contract.Assert(node.Kind == SyntaxKind.PropertyDeclaration || node.Kind == SyntaxKind.PropertySignature);

            var questionToken = (node.Kind == SyntaxKind.PropertyDeclaration) ?
                                    node.Cast<IPropertyDeclaration>().QuestionToken :
                                    node.Cast<IPropertySignature>().QuestionToken;

            var initializer = (node.Kind == SyntaxKind.PropertyDeclaration) ?
                                node.Cast<IPropertyDeclaration>().Initializer :
                                node.Cast<IPropertySignature>().Initializer;

            if (IsClassLike(node.Parent) != null)
            {
                if (CheckGrammarForInvalidQuestionMark(node, questionToken.ValueOrDefault, Errors.A_class_member_cannot_be_declared_optional) ||
                    CheckGrammarForNonSymbolComputedProperty(node.Name, Errors.A_computed_property_name_in_a_class_property_declaration_must_directly_refer_to_a_built_in_symbol))
                {
                    return true;
                }
            }
            else if (node.Parent.Kind == SyntaxKind.InterfaceDeclaration)
            {
                if (CheckGrammarForNonSymbolComputedProperty(node.Name, Errors.A_computed_property_name_in_an_interface_must_directly_refer_to_a_built_in_symbol))
                {
                    return true;
                }

                if (initializer != null)
                {
                    return GrammarErrorOnNode(initializer, Errors.An_interface_property_cannot_have_an_initializer);
                }
            }
            else if (node.Parent.Kind == SyntaxKind.TypeLiteral)
            {
                if (CheckGrammarForNonSymbolComputedProperty(node.Name, Errors.A_computed_property_name_in_a_type_literal_must_directly_refer_to_a_built_in_symbol))
                {
                    return true;
                }

                if (initializer != null)
                {
                    return GrammarErrorOnNode(initializer, Errors.A_type_literal_property_cannot_have_an_initializer);
                }
            }

            // DScript-specific. Template declarations allow initializers even though they are ambients.
            if (IsInAmbientContext(node) && initializer != null && !node.IsTemplateDeclaration())
            {
                return GrammarErrorOnFirstToken(initializer, Errors.Initializers_are_not_allowed_in_ambient_contexts);
            }

            return false;
        }

        private bool CheckGrammarTopLevelElementForRequiredDeclareModifier(INode node)
        {
            // A declare modifier is required for any top level .d.ts declaration except export=, export default,
            // interfaces and imports categories:
            //
            //  DeclarationElement:
            //     ExportAssignment
            //     export_opt   InterfaceDeclaration
            //     export_opt   TypeAliasDeclaration
            //     export_opt   ImportDeclaration
            //     export_opt   ExternalImportDeclaration
            //     export_opt   AmbientDeclaration
            //
            // TODO: The spec needs to be amended to reflect this grammar.
            if (node.Kind == SyntaxKind.InterfaceDeclaration ||
                node.Kind == SyntaxKind.TypeAliasDeclaration ||
                node.Kind == SyntaxKind.ImportDeclaration ||
                node.Kind == SyntaxKind.ImportEqualsDeclaration ||
                node.Kind == SyntaxKind.ExportDeclaration ||
                node.Kind == SyntaxKind.ExportAssignment ||
                ((node.Flags & NodeFlags.Ambient) != NodeFlags.None) ||
                ((node.Flags & (NodeFlags.Export | NodeFlags.Default)) != NodeFlags.None))
            {
                return false;
            }

            return GrammarErrorOnFirstToken(node, Errors.A_declare_modifier_is_required_for_a_top_level_declaration_in_a_d_ts_file);
        }

        private bool CheckGrammarTopLevelElementsForRequiredDeclareModifier(ISourceFile file)
        {
            foreach (var decl in file.Statements)
            {
                if (IsDeclaration(decl) || decl.Kind == SyntaxKind.VariableStatement)
                {
                    if (CheckGrammarTopLevelElementForRequiredDeclareModifier(decl))
                    {
                        return true;
                    }
                }
            }

            return false;
        }

        private bool CheckGrammarSourceFile(ISourceFile node)
        {
            return IsInAmbientContext(node) && CheckGrammarTopLevelElementsForRequiredDeclareModifier(node);
        }

        private bool CheckGrammarStatementInAmbientContext(INode node)
        {
            if (IsInAmbientContext(node))
            {
                // An accessors is already reported about the ambient context
                if (IsAccessor(node.Parent.Kind))
                {
                    GetNodeLinks(node).HasReportedStatementInAmbientContext = true;
                    return true;
                }

                // Find containing block which is either Block, ModuleBlock, SourceFile
                var links = GetNodeLinks(node);
                if (!links.HasReportedStatementInAmbientContext.GetValueOrDefault() && IsFunctionLike(node.Parent) != null)
                {
                    bool result = GrammarErrorOnFirstToken(node, Errors.An_implementation_cannot_be_declared_in_ambient_contexts);
                    GetNodeLinks(node).HasReportedStatementInAmbientContext = result;
                    return result;
                }

                // We are either parented by another statement, or some sort of block.
                // If we're in a block, we only want to really report an error once
                // to prevent noisyness.  So use a bit on the block to indicate if
                // this has already been reported, and don't report if it has.
                if (node.Parent.Kind == SyntaxKind.Block || node.Parent.Kind == SyntaxKind.ModuleBlock || node.Parent.Kind == SyntaxKind.SourceFile)
                {
                    links = GetNodeLinks(node.Parent);

                    // Check if the containing block ever report this error
                    if (!links.HasReportedStatementInAmbientContext.GetValueOrDefault())
                    {
                        bool result = GrammarErrorOnFirstToken(node, Errors.Statements_are_not_allowed_in_ambient_contexts);
                        links.HasReportedStatementInAmbientContext = result;
                        return result;
                    }
                }
                else
                {
                    // We must be parented by a statement.  If so, there's no need
                    // to report the error as our parent will have already done it.
                    // Debug.Assert(isStatement(node.Parent));
                }
            }

            return false;
        }

        private bool CheckGrammarNumericLiteral(INode node)
        {
            // Grammar checking
            if ((node.Flags & NodeFlags.OctalLiteral) != NodeFlags.None && m_languageVersion >= ScriptTarget.Es5)
            {
                return GrammarErrorOnNode(node, Errors.Octal_literals_are_not_available_when_targeting_ECMAScript_5_and_higher);
            }

            return false;
        }

        private bool GrammarErrorAfterFirstToken(INode node, IDiagnosticMessage message, params object[] args)
        {
            var sourceFile = NodeStructureExtensions.GetSourceFile(node);
            if (!HasParseDiagnostics(sourceFile))
            {
                var span = GetSpanOfTokenAtPosition(sourceFile, node.Pos);
                m_diagnostics.Add(Diagnostic.CreateFileDiagnostic(sourceFile, TextUtilities.TextSpanEnd(span), 0, message, args));
                return true;
            }

            return false;
        }

        #region Private functions that are not part of typescript codebase

        private Map<TypeAndFlag> CreatePrimitiveTypeInfo()
        {
            return new Map<TypeAndFlag>
            {
                ["string"] = new TypeAndFlag(m_stringType, TypeFlags.StringLike),
                ["number"] = new TypeAndFlag(m_numberType, TypeFlags.NumberLike),
                ["boolean"] = new TypeAndFlag(m_booleanType, TypeFlags.Boolean),
                ["symbol"] = new TypeAndFlag(m_esSymbolType, TypeFlags.EsSymbol),
                ["undefined"] = new TypeAndFlag(m_undefinedType, TypeFlags.ContainsUndefinedOrNull),
            };
        }

        private GenericType CreateGenericType(ISymbol symbol, ISymbolTable members, IEnumerable<ISignature> callSignatures,
            IEnumerable<ISignature> constructSignatures, IType stringIndexType, IType numberIndexType)
        {
            var result = CreateObjectType<GenericType>(TypeFlags.Anonymous, symbol);

            SetObjectTypeMembers(
               result,
               members,
               callSignatures,
               constructSignatures,
               stringIndexType,
               numberIndexType);

            return result;
        }

        private TransientSymbol CreateTransientSymbol(SymbolFlags flags, string name, ref SymbolData extraData)
        {
            m_counters.IncrementSymbolCount();
            return TransientSymbol.Create(flags, name, extraData);
        }

        /// <inheritdoc />
        void IDisposable.Dispose()
        {
            throw new NotImplementedException();
        }

        #endregion
    }
}
