# Cache Component

The Cache component implements BuildXL's content-addressable storage and memoization layer. It supports local and remote (Azure Blob) caching with a two-phase lookup algorithm for correctness in the presence of non-deterministic builds.

## Architecture

### Two-Phase Cache Lookup
BuildXL uses a two-phase algorithm to handle builds where not all inputs are statically known:

1. **Phase 1 — Weak Fingerprint**: Hash of statically known inputs (declared files, command line, paths). Deterministic and computed upfront. Returns matching pathsets.
2. **Phase 2 — Strong Fingerprint**: Weak fingerprint + hashes of dynamically observed file accesses (reads, probes, directory enumerations). Matches against cached pathsets to find exact output.

**Weak fingerprint augmentation**: When a weak fingerprint produces too many unique pathsets, the cache augments it with common accessed paths to reduce pathset explosion. Enabled by default for JavaScript, CMake, Ninja, and MSBuild resolvers.

### Cache Convergence
When concurrent builds produce slightly different outputs for the same pip (non-determinism), the cache can "snap to" a pre-existing result:
1. Build A executes pip, stores results
2. Build B executes same pip with different output
3. Cache indicates entry already exists → Build B adopts Build A's result

### Multi-Tier Architecture
- **Local cache (L1)**: On-disk content store with configurable size limits
- **Remote cache (L3)**: Azure Blob Storage with universe-based namespace isolation
- **Peer-to-peer**: Workers exchange artifacts directly in distributed builds

### Lazy Materialization
Files are materialized (brought to disk) only when needed:
- `/enableLazyOutputs` (default) — materialize for filter matches + dependencies
- `/enableLazyOutputs:minimal` — only materialize for cache misses
- Disabled when no pip filter is specified (all outputs requested)

## Module Structure

| Directory | Purpose |
|-----------|---------|
| `ContentStore/` | Core content-addressable storage engine with distributed support |
| `ContentStore/Interfaces/` | `IContentStore` and related abstractions |
| `DistributedCache.Host/` | Service hosting for distributed cache, configuration, launcher |
| `MemoizationStore/` | Fingerprint → content mapping (weak/strong fingerprint lookups) |
| `MemoizationStore/Interfaces/` | `IMemoizationStore` and related abstractions |
| `BuildCacheResource/` | Resource management for cache operations |
| `LifetimeManager/` | Cache lifecycle and retention management |
| `Logging/` | Cache-specific logging infrastructure |
| `VerticalStore/` | Vertical (multi-level) caching store implementation |

## Key Types

### Fingerprinting
- `WeakFingerprint` — Hash of static pip specification (exe, args, declared inputs)
- `StrongFingerprint` — WeakFingerprint + observed file access hashes
- `Pathset` — Record of observed file accesses during pip execution
- `ContentHash` — Hash of file content (VSO-Hash algorithm)

### Storage
- `IContentStore` — Interface for content-addressable blob storage
- `IMemoizationStore` — Interface for fingerprint-to-content mapping
- `ContentHashList` — List of output content hashes for a cached pip result

## Shared Cache Configuration

Azure Blob Storage backed shared cache:
```json
{
  "Assembly": "BuildXL.Cache.MemoizationStoreAdapter",
  "Type": "BuildXL.Cache.MemoizationStoreAdapter.BlobWithLocalCacheFactory",
  "RemoteCache": {
    "CacheId": "myremotecache",
    "Universe": "default",
    "RetentionPolicyInDays": 6
  },
  "LocalCache": {
    "CacheId": "mylocalcache",
    "MaxCacheSizeInMB": 40480
  }
}
```

**Authentication**: Managed Identity (recommended), Codespaces Auth, or Interactive Browser (`/interactive`).

**Developer cache pattern**: Publishing builds write (read/write); dev builds consume read-only (`"IsReadOnly": true`).

## Common Pitfalls
- **Universe mismatch**: Builds in different universes never share cache hits — verify `Universe` config matches
- **Retention policy**: Must match Azure Blob account lifecycle policies or content silently disappears
- **Pathset explosion**: High pathset counts degrade cache performance — augmentation helps but check if lookup is slow
- **Fingerprint changes upstream**: Any change to fingerprinting logic invalidates all caches
